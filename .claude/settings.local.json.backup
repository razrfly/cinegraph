{
  "permissions": {
    "allow": [
      "Bash(gh issue create:*)",
      "Bash(find:*)",
      "Bash(mkdir:*)",
      "Bash(gh issue:*)",
      "Bash(gh repo view:*)",
      "Bash(ls:*)",
      "Bash(env)",
      "WebFetch(domain:docs.anthropic.com)",
      "Bash(elixir:*)",
      "Bash(mix:*)",
      "Bash(npx:*)",
      "Bash(node:*)",
      "Bash(npm:*)",
      "Bash(/doctor)",
      "Bash(rm:*)",
      "Bash(source .env)",
      "Bash(echo:*)",
      "Bash(TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 mix run -e \"Cinegraph.Services.TMDb.test_connection()\")",
      "Bash(TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 mix run -e \"Cinegraph.Services.TMDb.explore_movie(550)\")",
      "Bash(TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 mix run -e \"\n{:ok, results} = Cinegraph.Services.TMDb.search_movies(\"\"Inception\"\")\nIO.puts(\"\"\\nðŸ” Search Results for ''Inception'':\"\")\nIO.puts(\"\"Total results: #{results[\"\"total_results\"\"]}\"\")\nIO.puts(\"\"\\nFirst 3 movies:\"\")\nresults[\"\"results\"\"] |> Enum.take(3) |> Enum.each(fn movie ->\n  IO.puts(\"\"- #{movie[\"\"title\"\"]} (#{movie[\"\"release_date\"\"]}) - ID: #{movie[\"\"id\"\"]}\"\")\nend)\n\")",
      "Bash(TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 mix run -e \"\n# Fetch different types of movies to understand data variations\nmovie_ids = [550, 27205, 238, 278, 680]  # Fight Club, Inception, Godfather, Shawshank, Pulp Fiction\n\nIO.puts(\"\"\\nðŸ“Š Analyzing TMDb Data Patterns\"\")\nIO.puts(\"\"=\"\" <> String.duplicate(\"\"=\"\", 50))\n\nEnum.each(movie_ids, fn id ->\n  case Cinegraph.Services.TMDb.get_movie(id) do\n    {:ok, movie} ->\n      IO.puts(\"\"\\n#{movie[\"\"title\"\"]} (#{movie[\"\"release_date\"\"]})\"\")\n      IO.puts(\"\"  Genres: #{movie[\"\"genres\"\"] |> Enum.map(&(&1[\"\"name\"\"])) |> Enum.join(\"\", \"\")}\"\")\n      IO.puts(\"\"  Vote: #{movie[\"\"vote_average\"\"]}/10 (#{movie[\"\"vote_count\"\"]} votes)\"\")\n      IO.puts(\"\"  Budget: $#movie[\"\"budget\"\"] |> Number.Delimit.number_to_delimited()}\"\")\n      IO.puts(\"\"  Revenue: $#movie[\"\"revenue\"\"] |> Number.Delimit.number_to_delimited()}\"\")\n      \n    {:error, _} ->\n      IO.puts(\"\"Error fetching movie #{id}\"\")\n  end\nend)\n\")",
      "Bash(TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 mix run -e \"\n# Fetch different types of movies to understand data variations\nmovie_ids = [550, 27205, 238, 278, 680]  # Fight Club, Inception, Godfather, Shawshank, Pulp Fiction\n\nIO.puts(\"\"\\nðŸ“Š Analyzing TMDb Data Patterns\"\")\nIO.puts(\"\"=\"\" <> String.duplicate(\"\"=\"\", 50))\n\nEnum.each(movie_ids, fn id ->\n  case Cinegraph.Services.TMDb.get_movie(id) do\n    {:ok, movie} ->\n      IO.puts(\"\"\\n#{movie[\"\"title\"\"]} (#{movie[\"\"release_date\"\"]})\"\")\n      IO.puts(\"\"  Genres: #{movie[\"\"genres\"\"] |> Enum.map(&(&1[\"\"name\"\"])) |> Enum.join(\"\", \"\")}\"\")\n      IO.puts(\"\"  Vote: #{movie[\"\"vote_average\"\"]}/10 (#{movie[\"\"vote_count\"\"]} votes)\"\")\n      IO.puts(\"\"  Budget: #{movie[\"\"budget\"\"]}\"\")\n      IO.puts(\"\"  Revenue: #{movie[\"\"revenue\"\"]}\"\")\n      IO.puts(\"\"  Runtime: #{movie[\"\"runtime\"\"]} minutes\"\")\n      IO.puts(\"\"  Production Countries: #{movie[\"\"production_countries\"\"] |> Enum.map(&(&1[\"\"name\"\"])) |> Enum.join(\"\", \"\")}\"\")\n      \n    {:error, _} ->\n      IO.puts(\"\"Error fetching movie #{id}\"\")\n  end\nend)\n\")",
      "WebFetch(domain:developer.themoviedb.org)",
      "WebFetch(domain:github.com)",
      "Bash(export TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8)",
      "Bash(grep:*)",
      "Bash(export TMDB_API_KEY)",
      "Bash(export SUPABASE_DATABASE_URL)",
      "Bash(psql:*)",
      "Bash(git rm:*)",
      "mcp__context7__resolve-library-id",
      "mcp__context7__get-library-docs",
      "Bash(git add:*)",
      "Bash(git commit:*)",
      "mcp__playwright__browser_navigate",
      "Bash(pkill:*)",
      "mcp__playwright__browser_take_screenshot",
      "mcp__playwright__browser_click",
      "mcp__playwright__browser_snapshot",
      "mcp__playwright__browser_close",
      "mcp__playwright__browser_evaluate",
      "Bash(test:*)",
      "Bash(true)",
      "Bash(MIX_ENV=dev mix run populate_real_movies.exs)",
      "mcp__playwright__browser_navigate_back",
      "Bash(MIX_ENV=dev mix run -e \"IO.inspect Cinegraph.Cultural.list_authorities(), label: ''Authorities''\")",
      "Bash(MIX_ENV=dev mix run -e \"Cinegraph.Cultural.seed_authorities()\")",
      "Bash(MIX_ENV=dev mix run fetch_sample_awards.exs)",
      "Bash(MIX_ENV=dev mix compile)",
      "Bash(MIX_ENV=dev mix run test_award_fetch.exs)",
      "Bash(MIX_ENV=dev mix run audit_tmdb_data.exs)",
      "Bash(MIX_ENV=dev mix run test_ultra_fetch.exs)",
      "Bash(MIX_ENV=dev mix run test_data_output.exs)",
      "Bash(MIX_ENV=dev mix run examine_reviews_and_lists.exs)",
      "Bash(MIX_ENV=dev mix run test_aggregate_metrics.exs)",
      "Bash(MIX_ENV=dev mix run -e 'IO.inspect Cinegraph.ExternalSources.get_movie_ratings(23), label: \"\"Ratings\"\", pretty: true')",
      "WebFetch(domain:www.omdbapi.com)",
      "WebFetch(domain:omdbpy.readthedocs.io)",
      "Bash(export OMDB_API_KEY=e291bc36)",
      "Bash(iex:*)",
      "mcp__playwright__browser_navigate",
      "mcp__playwright__browser_close",
      "Bash(pkill:*)",
      "Bash(curl:*)",
      "mcp__playwright__browser_take_screenshot",
      "mcp__playwright__browser_evaluate",
      "Bash(OMDB_API_KEY=e291bc36 mix import_movies --enrich)",
      "Bash(Single entry point for all movie imports.)",
      "Bash(Fetches from TMDb and enriches with OMDb data.)",
      "Bash(\"\"\"\n  \n  def import_movies(count: 100) do\n    # 1. Fetch from TMDb (paginated)\n    # 2. For each movie:\n    #    a. Create/update movie record\n    #    b. Store credits\n    #    c. Store keywords (WITH junction table)\n    #    d. Store videos\n    #    e. Store release dates\n    #    f. Store production companies (WITH junction table)\n    #    g. Extract IMDb ID\n    #    h. If IMDb ID exists, fetch OMDb data\n    #    i. Store all ratings\n    #    j. Store enhanced metadata\n    # 3. Return import stats\n  end\n  \n  def import_trending do\n    # Daily job to fetch trending movies\n  end\n  \n  def import_upcoming do\n    # Weekly job to fetch upcoming releases\n  end\nend\n```\n\n## Benefits of Cleanup\n\n1. **Simpler Schema**: Remove 6 unused tables (~26% reduction)\n2. **Better Data Utilization**: Store 100% of fetched data\n3. **Clearer Purpose**: Each table has a clear role\n4. **Future-Ready**: Keep tables needed for planned features (CRI, curated lists)\n5. **Performance**: Less complexity = faster queries\n\n## Action Items\n\n- [ ] Create migration to drop unused tables\n- [ ] Fix junction table population in importers\n- [ ] Update comprehensive importer to extract all fetched data\n- [ ] Add trending/upcoming movie importers\n- [ ] Document which tables are for future features\n- [ ] Update README with current schema documentation\n\n## Questions to Resolve\n\n1. Should we keep alternative_titles and translations tables, or just store in movie JSON?\n2. Do we want to track temporal data (movie_data_changes) in the future?\n3. Should we implement the cultural authority system, or simplify to just awards?\n\n/cc @razrfly\nEOF\n)\")",
      "mcp__context7__resolve-library-id",
      "mcp__context7__get-library-docs",
      "Bash(TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=e291bc36 mix import_movies --pages 2)",
      "Bash(TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=e291bc36 mix ecto.drop)",
      "Bash(TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=e291bc36 mix ecto.create)",
      "Bash(TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=e291bc36 mix ecto.migrate)",
      "Bash(TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=e291bc36 psql $SUPABASE_DATABASE_URL -c \"\\dt\")",
      "Bash(TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=e291bc36 mix run -e \"IO.inspect(Cinegraph.Repo.config())\")",
      "Bash(TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=e291bc36 mix run check_tables.exs)",
      "Bash(TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=e291bc36 mix import_movies --pages 1)",
      "Bash(supabase status:*)",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=e291bc36 mix ecto.migrate)",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=e291bc36 mix import_movies --pages 1)",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=e291bc36 mix import_movies --pages 5)",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres mix run check_import_status.exs)",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres mix run -e '\nimport Ecto.Query\nmovie = Cinegraph.Repo.one(from m in Cinegraph.Movies.Movie, limit: 1)\nIO.inspect(movie, label: \"\"Sample Movie\"\")\nIO.puts(\"\"\\nTMDb data keys:\"\")\nif movie.tmdb_data, do: IO.inspect(Map.keys(movie.tmdb_data))\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres mix run -e '\nimport Ecto.Query\n# Check for movies with runtime (indicates detailed data was fetched)\nwith_runtime = Cinegraph.Repo.one(from m in Cinegraph.Movies.Movie, where: not is_nil(m.runtime), select: count(m.id))\nIO.puts(\"\"Movies with runtime: #{with_runtime}\"\")\n\n# Check a movie with more details\nmovie = Cinegraph.Repo.one(from m in Cinegraph.Movies.Movie, where: m.tmdb_id == 1087192, preload: [:genres, :keywords, :production_companies])\nIO.puts(\"\"\\nMovie: #{movie.title}\"\")\nIO.puts(\"\"Runtime: #{movie.runtime || \"\"nil\"\"}\"\")\nIO.puts(\"\"Budget: #{movie.budget || \"\"nil\"\"}\"\")\nIO.puts(\"\"Revenue: #{movie.revenue || \"\"nil\"\"}\"\")\nIO.puts(\"\"Status: #{movie.status || \"\"nil\"\"}\"\")\nIO.puts(\"\"Homepage: #{movie.homepage || \"\"nil\"\"}\"\")\nIO.puts(\"\"Tagline: #{movie.tagline || \"\"nil\"\"}\"\")\nIO.puts(\"\"Genres: #{length(movie.genres)}\"\")\nIO.puts(\"\"Keywords: #{length(movie.keywords)}\"\")\nIO.puts(\"\"Production Companies: #{length(movie.production_companies)}\"\")\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=e291bc36 mix import_movies --pages 2)",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres mix run -e '\nimport Ecto.Query\n\n# Get final counts\nmovies_count = Cinegraph.Repo.aggregate(Cinegraph.Movies.Movie, :count)\nwith_imdb = Cinegraph.Repo.one(from m in Cinegraph.Movies.Movie, where: not is_nil(m.imdb_id), select: count(m.id))\nwith_runtime = Cinegraph.Repo.one(from m in Cinegraph.Movies.Movie, where: not is_nil(m.runtime), select: count(m.id))\nratings_count = Cinegraph.Repo.aggregate(Cinegraph.ExternalSources.Rating, :count)\ngenres_count = Cinegraph.Repo.aggregate(Cinegraph.Movies.Genre, :count)\nkeywords_count = Cinegraph.Repo.aggregate(Cinegraph.Movies.Keyword, :count)\ncredits_count = Cinegraph.Repo.aggregate(Cinegraph.Movies.Credit, :count)\n\nIO.puts(\"\"\\\\n=== Final Import Summary ===\"\")\nIO.puts(\"\"Total movies: #{movies_count}\"\")\nIO.puts(\"\"Movies with IMDb IDs: #{with_imdb}\"\")\nIO.puts(\"\"Movies with runtime (detailed data): #{with_runtime}\"\")\nIO.puts(\"\"Total external ratings: #{ratings_count}\"\")\nIO.puts(\"\"Total genres: #{genres_count}\"\")\nIO.puts(\"\"Total keywords: #{keywords_count}\"\")\nIO.puts(\"\"Total credits: #{credits_count}\"\")\n\n# Sample rating data\nsample_ratings = Cinegraph.Repo.all(\n  from r in Cinegraph.ExternalSources.Rating,\n  join: m in Cinegraph.Movies.Movie, on: m.id == r.movie_id,\n  limit: 5,\n  select: {m.title, r.rating_type, r.value, r.metadata}\n)\n\nIO.puts(\"\"\\\\n=== Sample External Ratings ===\"\")\nEnum.each(sample_ratings, fn {title, type, value, metadata} ->\n  source = metadata[\"\"source_name\"\"] || \"\"OMDb\"\"\n  IO.puts(\"\"#{title}: #{type} - #{value} (#{source})\"\")\nend)\n')",
      "Bash(cat:*)",
      "Bash(chmod:*)",
      "Bash(git ls-tree:*)",
      "mcp__playwright__browser_snapshot",
      "mcp__playwright__browser_click",
      "Bash(kill:*)",
      "Bash(PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT COUNT(*) AS movie_count FROM movies;\")",
      "Bash(PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\nSELECT \n    ''movie_keywords'' AS table_name, COUNT(*) AS row_count FROM movie_keywords\nUNION ALL\nSELECT \n    ''movie_videos'' AS table_name, COUNT(*) AS row_count FROM movie_videos\nUNION ALL\nSELECT \n    ''movie_credits'' AS table_name, COUNT(*) AS row_count FROM movie_credits\nUNION ALL\nSELECT \n    ''movie_release_dates'' AS table_name, COUNT(*) AS row_count FROM movie_release_dates\nUNION ALL\nSELECT \n    ''external_ratings'' AS table_name, COUNT(*) AS row_count FROM external_ratings\nORDER BY table_name;\")",
      "Bash(PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT * FROM movies WHERE id = 2 \\gx\")",
      "Bash(PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -x -c \"SELECT * FROM movies WHERE id = 2;\")",
      "Bash(PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -x -c \"SELECT * FROM external_ratings WHERE movie_id = 2 LIMIT 1;\")",
      "Bash(MIX_ENV=dev mix do ecto.drop, ecto.create, ecto.migrate)",
      "Bash(TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=3ba3f8f9 mix import_movies --fresh --pages 1 --verbose)",
      "Bash(TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=3ba3f8f9 mix import_movies --fresh --pages 10)",
      "Bash(./scripts/enrich_with_omdb.sh:*)",
      "Bash(./scripts/import_with_env.sh:*)",
      "Bash(touch:*)",
      "Bash(MIX_ENV=dev mix ecto.reset)",
      "Bash(PGPASSWORD=postgres psql -U postgres -d postgres -h 127.0.0.1 -p 54332 -c \"\\dt\")",
      "Bash(PGPASSWORD=postgres psql -U postgres -d postgres -h 127.0.0.1 -p 54332 -c \"\\d movies\")",
      "Bash(PGPASSWORD=postgres psql -U postgres -d postgres -h 127.0.0.1 -p 54332 -c \"SELECT COUNT(*) FROM movies WHERE tmdb_data IS NOT NULL AND omdb_data IS NOT NULL;\")",
      "Bash(PGPASSWORD=postgres psql -U postgres -d postgres -h 127.0.0.1 -p 54332 -c \"SELECT COUNT(DISTINCT movie_id) FROM movie_genres;\")",
      "Bash(PGPASSWORD=postgres psql -U postgres -d postgres -h 127.0.0.1 -p 54332 -c \"SELECT m.id, m.title, g.name FROM movies m JOIN movie_genres mg ON m.id = mg.movie_id JOIN genres g ON mg.genre_id = g.id WHERE m.id = 1;\")",
      "Bash(mv:*)",
      "Bash(export OMDB_API_KEY=$OMDB_API_KEY)",
      "Bash(export TMDB_API_KEY=$TMDB_API_KEY)",
      "Bash(PGPASSWORD=postgres psql -U postgres -d postgres -h 127.0.0.1 -p 54332 -c \"SELECT COUNT(*) FROM movies WHERE omdb_data IS NOT NULL;\")",
      "Bash(MIX_ENV=dev mix ecto.create)",
      "Bash(MIX_ENV=dev mix ecto.migrate)",
      "Bash(cp:*)",
      "Bash(gh label:*)",
      "Bash(gh api:*)",
      "Bash(awk:*)",
      "WebFetch(domain:hexdocs.pm)",
      "WebFetch(domain:elixirforum.com)",
      "Bash(git checkout:*)",
      "Bash(MIX_ENV=test mix compile --force)",
      "Bash(./cleanup_project.sh:*)",
      "Bash(MIX_ENV=dev mix run -e 'IO.puts(\"\"Environment: #{Mix.env()}\"\")')",
      "Bash(PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT COUNT(*) FILTER (WHERE tmdb_data IS NOT NULL) as with_tmdb, COUNT(*) FILTER (WHERE omdb_data IS NOT NULL) as with_omdb, COUNT(*) FILTER (WHERE imdb_id IS NOT NULL) as with_imdb_id FROM movies;\")",
      "Bash(PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT COUNT(*) FROM movie_genres mg JOIN genres g ON mg.genre_id = g.id;\")",
      "Bash(PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT COUNT(*) FROM movie_keywords mk JOIN keywords k ON mk.keyword_id = k.id;\")",
      "Bash(PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT COUNT(*) FROM movie_credits;\")",
      "Bash(PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT COUNT(*) FROM external_ratings;\")",
      "Bash(PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT import_type, status, movies_found, movies_imported, current_page, total_pages FROM import_progress ORDER BY id DESC LIMIT 5;\")",
      "Bash(PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT worker, state, COUNT(*) FROM oban_jobs GROUP BY worker, state ORDER BY worker, state;\")",
      "Bash(PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT COUNT(DISTINCT m.id) FROM movies m WHERE EXISTS (SELECT 1 FROM movie_videos mv WHERE mv.movie_id = m.id);\")",
      "Bash(PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT COUNT(*) FROM people;\")",
      "Bash(MIX_ENV=dev mix ecto.rollback)",
      "Bash(PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"DROP TABLE IF EXISTS import_progress CASCADE;\")",
      "Bash(PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT * FROM schema_migrations ORDER BY version DESC LIMIT 5;\")",
      "Bash(PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\\di movies*\")",
      "Bash(MIX_ENV=dev mix compile --force)",
      "Bash(git fetch:*)",
      "Bash(git merge:*)",
      "Bash(PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -c \"TRUNCATE TABLE movies, people, movie_credits, collaborations, collaboration_details, movie_genres, movie_keywords, movie_videos, movie_release_dates, movie_production_companies, external_ratings, skipped_imports CASCADE;\")",
      "Bash(PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -c \"DELETE FROM collaboration_details; DELETE FROM collaborations; DELETE FROM movie_credits; DELETE FROM external_ratings; DELETE FROM movie_release_dates; DELETE FROM movie_videos; DELETE FROM movie_keywords; DELETE FROM movie_genres; DELETE FROM movie_production_companies; DELETE FROM people; DELETE FROM movies; DELETE FROM skipped_imports;\")",
      "Bash(MIX_ENV=dev mix test_concurrent_import popular 2)",
      "Bash(PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\\dt\")",
      "Bash(PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT COUNT(*) as total_movies, COUNT(CASE WHEN import_status = ''full'' THEN 1 END) as full_imports, COUNT(CASE WHEN import_status = ''soft'' THEN 1 END) as soft_imports FROM movies;\")",
      "Bash(PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT COUNT(DISTINCT person_a_id), COUNT(DISTINCT person_b_id), COUNT(*) as total_collabs, AVG(collaboration_count)::numeric(10,2) as avg_collabs FROM collaborations;\")",
      "Bash(PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT COUNT(*) as total_people, COUNT(CASE WHEN profile_path IS NOT NULL THEN 1 END) as with_profile, COUNT(CASE WHEN popularity > 0 THEN 1 END) as with_popularity FROM people;\")",
      "Bash(PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT department, COUNT(*) as count FROM movie_credits GROUP BY department ORDER BY count DESC LIMIT 10;\")",
      "Bash(PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT role, COUNT(*) as count FROM movie_credits GROUP BY role ORDER BY count DESC LIMIT 5;\")",
      "Bash(PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\\d movie_credits\")",
      "Bash(PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT credit_type, COUNT(*) as count FROM movie_credits GROUP BY credit_type ORDER BY count DESC;\")",
      "Bash(PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT COUNT(*) as keywords, COUNT(DISTINCT movie_id) as movies_with_keywords FROM movie_keywords;\")",
      "Bash(PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT COUNT(*) FROM skipped_imports;\")",
      "Bash(PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT reason, COUNT(*) FROM skipped_imports GROUP BY reason ORDER BY COUNT(*) DESC LIMIT 5;\")",
      "Bash(PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT title, vote_count, popularity, import_status FROM movies WHERE import_status = ''full'' ORDER BY popularity DESC LIMIT 10;\")",
      "Bash(PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT title, vote_count, popularity, import_status FROM movies WHERE import_status = ''soft'' ORDER BY popularity DESC LIMIT 10;\")",
      "Bash(PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT title, criteria_failed FROM skipped_imports LIMIT 10;\")",
      "Bash(MIX_ENV=dev mix ecto.drop)",
      "Bash(PGPASSWORD=postgres psql -h 127.0.0.1 -p 54322 -U postgres -c \"SELECT pg_terminate_backend(pid) FROM pg_stat_activity WHERE datname = ''postgres'' AND pid <> pg_backend_pid();\")",
      "Bash(PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT ''Movies'' as table_name, COUNT(*) as count FROM movies UNION ALL SELECT ''People'', COUNT(*) FROM people UNION ALL SELECT ''Credits'', COUNT(*) FROM movie_credits UNION ALL SELECT ''Oban Jobs'', COUNT(*) FROM oban_jobs;\")",
      "WebFetch(domain:www.oscars.org)",
      "WebFetch(domain:raw.githubusercontent.com)",
      "Bash(PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\\d movies\")",
      "Bash(MIX_ENV=dev iex -S mix)",
      "Bash(MIX_ENV=dev mix run -e '\n# Load environment variables\nDotenvy.source()\n\n# Get a ceremony\nceremony = Cinegraph.Cultural.list_oscar_ceremonies() |> List.first()\n\n# Import just that ceremony with verbose output\nIO.puts(\"\"Testing Oscar import for ceremony #{ceremony.year}...\"\")\n\n# Import the ceremony with full logging\nresult = Cinegraph.Cultural.OscarImporter.import_ceremony(ceremony, create_movies: true, create_partial: false)\n\nIO.inspect(result, label: \"\"Import Result\"\")\n')",
      "Bash(MIX_ENV=dev mix run -e '\n# Load environment variables\nDotenvy.source(\"\".env\"\", [])\n\n# Get a ceremony\nceremony = Cinegraph.Cultural.list_oscar_ceremonies() |> List.first()\n\n# Import just that ceremony with verbose output\nIO.puts(\"\"Testing Oscar import for ceremony #{ceremony.year}...\"\")\n\n# Import the ceremony with full logging\nresult = Cinegraph.Cultural.OscarImporter.import_ceremony(ceremony, create_movies: true, create_partial: false)\n\nIO.inspect(result, label: \"\"Import Result\"\")\n')",
      "Bash(MIX_ENV=dev mix run -e '\n# Load environment variables\nDotenvy.source(\"\".env\"\", [])\n\n# Get a ceremony\nceremony = Cinegraph.Cultural.list_oscar_ceremonies() |> List.first()\n\nIO.puts(\"\"Enhancing ceremony #{ceremony.year} with IMDb data...\"\")\n\n# Enhance with IMDb data\ncase Cinegraph.Scrapers.ImdbOscarScraper.enhance_ceremony_with_imdb(ceremony) do\n  {:ok, enhanced_data} ->\n    IO.puts(\"\"Successfully enhanced!\"\")\n    \n    # Count nominees with IMDb IDs\n    nominees_with_imdb = \n      enhanced_data[\"\"categories\"\"]\n      |> Enum.flat_map(fn cat -> cat[\"\"nominees\"\"] || [] end)\n      |> Enum.count(fn n -> n[\"\"film_imdb_id\"\"] != nil end)\n    \n    IO.puts(\"\"Nominees with IMDb IDs: #{nominees_with_imdb}\"\")\n    \n    # Update the ceremony\n    changeset = Ecto.Changeset.change(ceremony, data: enhanced_data)\n    {:ok, updated} = Cinegraph.Repo.update(changeset)\n    \n    IO.puts(\"\"Ceremony updated in database\"\")\n    \n  {:error, reason} ->\n    IO.puts(\"\"Failed to enhance: #{inspect(reason)}\"\")\nend\n')",
      "Bash(MIX_ENV=dev mix run -e '\n# Load environment variables\nDotenvy.source(\"\".env\"\", [])\n\n# Get a ceremony\nceremony = Cinegraph.Cultural.list_oscar_ceremonies() |> List.first()\n\nIO.puts(\"\"Enhancing ceremony #{ceremony.year} with IMDb data...\"\")\n\n# Enhance with IMDb data\ncase Cinegraph.Scrapers.ImdbOscarScraper.enhance_ceremony_with_imdb(ceremony) do\n  {:ok, enhanced_data} ->\n    IO.puts(\"\"Successfully enhanced!\"\")\n    \n    # Count nominees with IMDb IDs\n    nominees_with_imdb = \n      enhanced_data[\"\"categories\"\"]\n      |> Enum.flat_map(fn cat -> cat[\"\"nominees\"\"] || [] end)\n      |> Enum.count(fn n -> n[\"\"film_imdb_id\"\"] != nil end)\n    \n    IO.puts(\"\"Nominees with IMDb IDs: #{nominees_with_imdb}\"\")\n    \n    # Update the ceremony\n    changeset = Ecto.Changeset.change(ceremony, data: enhanced_data)\n    {:ok, updated} = Cinegraph.Repo.update(changeset)\n    \n    IO.puts(\"\"Ceremony updated in database\"\")\n    \n  {:error, reason} ->\n    IO.puts(\"\"Failed to enhance: #{inspect(reason)}\"\")\nend\n')",
      "Bash(MIX_ENV=dev mix run enhance_oscar_with_imdb.exs)",
      "Bash(PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"DELETE FROM movies WHERE tmdb_id IS NULL;\")",
      "Bash(ZYTE_API_KEY=9e754bb61e684aad88a98eceada363ba MIX_ENV=dev mix run enhance_oscar_with_imdb.exs)",
      "Bash(TMDB_API_KEY=$TMDB_API_KEY MIX_ENV=dev mix run -e '\n# Get a ceremony\nceremony = Cinegraph.Cultural.list_oscar_ceremonies() |> List.first()\n\n# Import just that ceremony with verbose output\nIO.puts(\"\"Testing Oscar import for ceremony #{ceremony.year}...\"\")\n\n# Import the ceremony with full logging\nresult = Cinegraph.Cultural.OscarImporter.import_ceremony(ceremony, create_movies: true, create_partial: false)\n\nIO.inspect(result, label: \"\"Import Result\"\")\n')",
      "Bash(PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT jsonb_pretty(data) FROM oscar_ceremonies WHERE year = 2024 LIMIT 1;\")",
      "Bash(MIX_ENV=dev mix run -e '\n# Fetch a test page to see the HTML structure\nurl = \"\"https://www.oscars.org/oscars/ceremonies/2024\"\"\ncase Cinegraph.Scrapers.OscarScraper.fetch_html(url) do\n  {:ok, html} ->\n    # Save to file for analysis\n    File.write!(\"\"oscar_2024_sample.html\"\", html)\n    IO.puts(\"\"HTML saved to oscar_2024_sample.html\"\")\n    IO.puts(\"\"File size: #{byte_size(html)} bytes\"\")\n  {:error, reason} ->\n    IO.puts(\"\"Error: #{inspect(reason)}\"\")\nend\n')",
      "Bash(MIX_ENV=dev mix run -e '\n# Fetch a test page to see the HTML structure\nurl = \"\"https://www.oscars.org/oscars/ceremonies/2024\"\"\ncase Cinegraph.Scrapers.OscarScraper.fetch_html(url) do\n  {:ok, html} ->\n    # Save to file for analysis\n    File.write(\"\"oscar_2024_sample.html\"\", html)\n    IO.puts(\"\"HTML saved to oscar_2024_sample.html\"\")\n    IO.puts(\"\"File size: #{byte_size(html)} bytes\"\")\n  {:error, reason} ->\n    IO.puts(\"\"Error: #{inspect(reason)}\"\")\nend\n')",
      "Bash(PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT * FROM oscar_categories WHERE tracks_person = true;\")",
      "Bash(PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT ceremony_id, category_id, movie_id, COUNT(*) as count FROM oscar_nominations GROUP BY ceremony_id, category_id, movie_id HAVING COUNT(*) > 1 ORDER BY count DESC LIMIT 10;\")",
      "Bash(PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT * FROM oscar_ceremonies WHERE id = 3;\")",
      "Bash(PGPASSWORD=postgres psql:*)",
      "Bash(MIX_ENV=dev mix run -e 'result = Cinegraph.Cultural.import_oscar_years(2015..2024); IO.inspect(result, label: \"\"Import Result\"\")')",
      "Bash(MIX_ENV=dev mix run -e 'status = Cinegraph.Cultural.get_oscar_import_status(); IO.inspect(status, label: \"\"Oscar Import Status\"\")')",
      "Bash(MIX_ENV=dev mix run -e '\n# Find and retry failed TMDbDetailsWorker jobs\nimport Ecto.Query\n\nfailed_jobs = from(j in Oban.Job, \n  where: j.worker == \"\"Cinegraph.Workers.TMDbDetailsWorker\"\" and\n         j.state in [\"\"retryable\"\", \"\"executing\"\"] and\n         j.attempt > 1\n) |> Cinegraph.Repo.all()\n\nIO.puts(\"\"Found #{length(failed_jobs)} failed TMDbDetailsWorker jobs\"\")\n\n# Cancel the broken jobs (they have nested args)\nEnum.each(failed_jobs, fn job ->\n  Oban.cancel_job(job)\n  IO.puts(\"\"Cancelled job #{job.id}\"\")\nend)\n')",
      "Bash(MIX_ENV=dev mix run:*)",
      "Bash(ZYTE_API_KEY=9e754bb61e684aad88a98eceada363ba mix run -e \"Cinegraph.Cultural.CanonicalImporter.import_1001_movies()\")",
      "Bash(MIX_ENV=dev mix import_canonical --help)",
      "Bash(MIX_ENV=dev mix import_canonical --list 1001_movies --dry-run)",
      "Bash(MIX_ENV=dev mix phx.server)",
      "Bash(./scripts/clear_database.sh:*)",
      "WebFetch(domain:www.imdb.com)",
      "WebFetch(domain:www.festival-cannes.com)",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres mix run -e 'IO.inspect(Cinegraph.CanonicalLists.all(), label: \"\"All Lists\"\"); {:ok, cannes} = Cinegraph.CanonicalLists.get(\"\"cannes_winners\"\"); IO.inspect(cannes, label: \"\"Cannes Config\"\")')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=3ba3f8f9 mix run -e '\ncase Cinegraph.Scrapers.ImdbCanonicalScraper.fetch_single_page(\"\"ls527026601\"\", 1) do\n  {:ok, movies} ->\n    IO.puts(\"\"\\\\n=== Cannes List Sample Data ===\"\")\n    IO.puts(\"\"Found #{length(movies)} movies on first page\"\")\n    \n    # Show first 3 movies with details\n    movies\n    |> Enum.take(3)\n    |> Enum.with_index(1)\n    |> Enum.each(fn {movie, idx} ->\n      IO.puts(\"\"\\\\n#{idx}. #{movie.title} (#{movie.year})\"\")\n      IO.puts(\"\"   IMDb ID: #{movie.imdb_id}\"\")\n      IO.puts(\"\"   Position: #{movie.position}\"\")\n    end)\n    \n  {:error, reason} ->\n    IO.puts(\"\"Error: #{inspect(reason)}\"\")\nend\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=3ba3f8f9 mix run -e '\n# Import just the first 3 movies from Cannes list to see JSON structure\nIO.puts(\"\"Testing Cannes import with first 3 movies...\"\")\n\ncase Cinegraph.Scrapers.ImdbCanonicalScraper.fetch_single_page(\"\"ls527026601\"\", 1) do\n  {:ok, movies} ->\n    # Process just first 3 movies\n    test_movies = Enum.take(movies, 3)\n    \n    list_config = %{\n      list_id: \"\"ls527026601\"\",\n      source_key: \"\"cannes_winners\"\",\n      name: \"\"Cannes Film Festival Award Winners: 2023-1939\"\",\n      metadata: %{\n        \"\"festival\"\" => \"\"Cannes Film Festival\"\",\n        \"\"test_run\"\" => true\n      }\n    }\n    \n    {:ok, results} = Cinegraph.Scrapers.ImdbCanonicalScraper.process_canonical_movies(test_movies, list_config)\n    \n    IO.puts(\"\"\\\\nProcessed #{results.summary.total} movies\"\")\n    IO.puts(\"\"- Created: #{results.summary.created}\"\")\n    IO.puts(\"\"- Updated: #{results.summary.updated}\"\")\n    IO.puts(\"\"- Queued: #{results.summary.queued}\"\")\n    \n    # Wait a moment for jobs to process\n    Process.sleep(5000)\n    \n    # Check what got stored in canonical_sources\n    IO.puts(\"\"\\\\n=== Checking canonical_sources JSON ===\"\")\n    \n    import Ecto.Query\n    movies_with_cannes = Cinegraph.Repo.all(\n      from m in Cinegraph.Movies.Movie,\n      where: fragment(\"\"? -> ? IS NOT NULL\"\", m.canonical_sources, \"\"cannes_winners\"\"),\n      limit: 3\n    )\n    \n    Enum.each(movies_with_cannes, fn movie ->\n      IO.puts(\"\"\\\\n#{movie.title} (#{movie.imdb_id})\"\")\n      cannes_data = movie.canonical_sources[\"\"cannes_winners\"\"]\n      IO.inspect(cannes_data, label: \"\"  Cannes JSON\"\")\n    end)\n    \n  {:error, reason} ->\n    IO.puts(\"\"Error: #{inspect(reason)}\"\")\nend\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=3ba3f8f9 mix run -e '\n# Import Cannes list using the public API, but limit to just first page for testing\nIO.puts(\"\"Testing Cannes list import (limited to first entries)...\"\")\n\n# Use the scrape_list_by_key function which should work\ncase Cinegraph.Scrapers.ImdbCanonicalScraper.scrape_list_by_key(\"\"cannes_winners\"\") do\n  {:ok, result} ->\n    IO.puts(\"\"Import completed!\"\")\n    IO.inspect(result.summary, label: \"\"Summary\"\")\n    \n    # Wait for jobs to process\n    Process.sleep(10000)\n    \n    # Check what got stored in canonical_sources\n    IO.puts(\"\"\\\\n=== Checking canonical_sources JSON ===\"\")\n    \n    import Ecto.Query\n    movies_with_cannes = Cinegraph.Repo.all(\n      from m in Cinegraph.Movies.Movie,\n      where: fragment(\"\"? -> ? IS NOT NULL\"\", m.canonical_sources, \"\"cannes_winners\"\"),\n      order_by: [asc: fragment(\"\"(? -> ? ->> ?)\"\", m.canonical_sources, \"\"cannes_winners\"\", \"\"list_position\"\")],\n      limit: 5\n    )\n    \n    IO.puts(\"\"Found #{length(movies_with_cannes)} movies with Cannes data\"\")\n    \n    Enum.each(movies_with_cannes, fn movie ->\n      IO.puts(\"\"\\\\n#{movie.title} (#{movie.imdb_id})\"\")\n      cannes_data = movie.canonical_sources[\"\"cannes_winners\"\"]\n      IO.inspect(cannes_data, label: \"\"  Cannes JSON\"\", pretty: true)\n    end)\n    \n  {:error, reason} ->\n    IO.puts(\"\"Error: #{inspect(reason)}\"\")\nend\n')",
      "Bash(git stash:*)",
      "Bash(MIX_ENV=dev mix run test_cannes_enhanced_extraction.exs)",
      "Bash(MIX_ENV=dev mix run test_cannes_direct.exs)",
      "Bash(MIX_ENV=dev mix run verify_cannes_implementation.exs)",
      "Bash(PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT COUNT(*) FROM movies WHERE canonical_sources -> ''cannes_winners'' IS NOT NULL;\")",
      "Bash(PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT title, canonical_sources -> ''cannes_winners'' AS cannes_data FROM movies WHERE canonical_sources -> ''cannes_winners'' IS NOT NULL ORDER BY (canonical_sources -> ''cannes_winners'' ->> ''list_position'')::int LIMIT 3;\" -t)",
      "Bash(PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT title, canonical_sources -> ''cannes_winners'' AS cannes_data FROM movies WHERE canonical_sources -> ''cannes_winners'' -> ''raw_description'' IS NOT NULL LIMIT 1;\" -t)",
      "Bash(PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT source_key, tracks_awards, award_types, last_import_at FROM movie_lists WHERE source_key = ''cannes_winners'';\" -x)",
      "Bash(MIX_ENV=dev mix ecto.gen.migration remove_unreliable_import_tracking_fields)",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=3ba3f8f9 mix run verify_enhanced_extraction_ready.exs)",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=3ba3f8f9 mix run test_actual_scraper_functions.exs)",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=3ba3f8f9 mix run test_scraper_data_flow.exs)",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=3ba3f8f9 mix run -e '\ncase Cinegraph.Scrapers.ImdbCanonicalScraper.get_expected_movie_count(\"\"ls527026601\"\") do\n  {:ok, count} -> IO.puts(\"\"Success: #{count}\"\")\n  nil -> IO.puts(\"\"Returned nil\"\")\n  {:error, reason} -> IO.puts(\"\"Error: #{inspect(reason)}\"\")\n  other -> IO.puts(\"\"Unexpected: #{inspect(other)}\"\")\nend\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=3ba3f8f9 mix run fetch_imdb_html.exs)",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=3ba3f8f9 mix run -e '\ncase Cinegraph.Scrapers.ImdbCanonicalScraper.get_expected_movie_count(\"\"ls527026601\"\") do\n  {:ok, count} -> IO.puts(\"\"Success: #{count}\"\")\n  nil -> IO.puts(\"\"Returned nil\"\")\n  {:error, reason} -> IO.puts(\"\"Error: #{inspect(reason)}\"\")\n  other -> IO.puts(\"\"Unexpected: #{inspect(other)}\"\")\nend\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=3ba3f8f9 mix run -e '\ncase Cinegraph.Scrapers.ImdbCanonicalScraper.get_expected_movie_count(\"\"ls527026601\"\") do\n  {:ok, count} -> IO.puts(\"\"Success: #{count}\"\")\n  nil -> IO.puts(\"\"Returned nil\"\")\n  {:error, reason} -> IO.puts(\"\"Error: #{inspect(reason)}\"\")\n  other -> IO.puts(\"\"Unexpected: #{inspect(other)}\"\")\nend\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=3ba3f8f9 mix run -e '\ncase Cinegraph.Scrapers.ImdbCanonicalScraper.get_expected_movie_count(\"\"ls527026601\"\") do\n  {:ok, count} -> IO.puts(\"\"Success: #{count}\"\")\n  nil -> IO.puts(\"\"Returned nil\"\")\n  {:error, reason} -> IO.puts(\"\"Error: #{inspect(reason)}\"\")\n  other -> IO.puts(\"\"Unexpected: #{inspect(other)}\"\")\nend\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=3ba3f8f9 mix run -e '\n# Test importing just 1 page of Cannes list to verify the fixes\nimport_job = %{\n  \"\"action\"\" => \"\"orchestrate_import\"\",\n  \"\"list_key\"\" => \"\"cannes_winners\"\"\n}\n\ncase Cinegraph.Workers.CanonicalImportOrchestrator.perform(%Oban.Job{args: import_job}) do\n  :ok -> \n    IO.puts(\"\"Import orchestration started successfully\"\")\n    \n    # Wait a moment and check the movie list metadata\n    Process.sleep(5000)\n    \n    case Cinegraph.Movies.MovieLists.get_by_source_key(\"\"cannes_winners\"\") do\n      nil -> IO.puts(\"\"Movie list not found\"\")\n      list -> \n        IO.puts(\"\"Movie list found:\"\")\n        IO.puts(\"\"  Last import: #{list.last_import_at}\"\")\n        IO.puts(\"\"  Last status: #{list.last_import_status}\"\")\n        IO.puts(\"\"  Expected count in metadata: #{list.metadata[\\\"\"expected_movie_count\\\"\"]}\"\")\n    end\n    \n  {:error, reason} -> \n    IO.puts(\"\"Import failed: #{inspect(reason)}\"\")\nend\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=3ba3f8f9 mix run test_import_flow.exs)",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres mix run -e '\ncase Cinegraph.Movies.MovieLists.get_config(\"\"cannes_winners\"\") do\n  {:ok, config} ->\n    IO.puts(\"\"=== Full Config Structure ===\"\")\n    IO.inspect(config, pretty: true)\n    \n    # Check specifically for tracks_awards\n    tracks_awards = get_in(config.metadata, [\"\"tracks_awards\"\"])\n    IO.puts(\"\"\\ntracks_awards value: #{inspect(tracks_awards)}\"\")\n    IO.puts(\"\"tracks_awards == true: #{tracks_awards == true}\"\")\n    \n  {:error, reason} ->\n    IO.puts(\"\"Error: #{reason}\"\")\nend\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=3ba3f8f9 mix run debug_scraper_execution.exs)",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres mix run test_real_scraper_path.exs)",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres mix run debug_enhanced_flow.exs)",
      "Bash(CANONICAL_IMPORT_AUDIT_ISSUE.md )",
      "Bash(FINAL_AUDIT_AND_ISSUE_UPDATE.md )",
      "Bash(IMPORT_STATS_FIX_V2_SUMMARY.md )",
      "Bash(audit_comment.md )",
      "Bash(debug_enhanced_flow.exs )",
      "Bash(debug_scraper_execution.exs )",
      "Bash(root_cause_analysis.md )",
      "Bash(verify_cannes_implementation.exs )",
      "Bash(verify_enhanced_extraction_ready.exs)",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres mix run -e '\n# Test the new parsing function with sample award text\naward_text = \"\"[2023]: Palme d&apos;Or winner (Best Film).\"\"\n\n# Call the parsing function directly - need to create a module to access private function\ndefmodule TestParser do\n  def test_parsing do\n    # Simulate the parsing logic\n    award_parts = String.split(\"\"[2023]: Palme d&apos;Or winner (Best Film).\"\", \"\" | \"\")\n    \n    award_parts\n    |> Enum.map(fn award_text ->\n      trimmed = String.trim(award_text)\n      \n      # Pattern 1: [YYYY]: Award Name (Category).\n      case Regex.run(~r/\\[(\\d{4})\\]:\\s*([^(]+?)(?:\\s*\\(([^)]+)\\))?\\s*\\.?$/i, trimmed) do\n        [_, year, award_name, category] ->\n          %{\n            award_name: String.trim(award_name),\n            award_category: if(category && category != \"\"\"\", do: String.trim(category), else: nil),\n            award_year: year,\n            raw_text: trimmed\n          }\n          \n        [_, year, award_name] ->\n          %{\n            award_name: String.trim(award_name),\n            award_category: nil,\n            award_year: year,\n            raw_text: trimmed\n          }\n          \n        _ ->\n          %{award_name: \"\"fallback\"\", raw_text: trimmed}\n      end\n    end)\n  end\nend\n\nresult = TestParser.test_parsing()\nIO.puts(\"\"\\n=== Award Parsing Test ===\"\")\nIO.inspect(result, label: \"\"Parsed Awards\"\", pretty: true)\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres mix run test_award_parsing.exs)",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=3ba3f8f9 mix run -e '\n# Test enhanced extraction with a single Cannes movie\nLogger.configure(level: :info)\n\n# Clear any existing data first\nPGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\"DELETE FROM movies WHERE canonical_sources -> \\\"\"cannes_winners\\\"\" IS NOT NULL;\"\"\n\nIO.puts(\"\"\\n=== Testing Enhanced Award Extraction ===\"\")\n\ncase Cinegraph.Scrapers.ImdbCanonicalScraper.fetch_single_page(\"\"ls527026601\"\", 1) do\n  {:ok, movies} ->\n    IO.puts(\"\"Fetched #{length(movies)} movies from Cannes list\"\")\n    \n    # Test just the first movie to see the enhanced data structure\n    if length(movies) > 0 do\n      first_movie = List.first(movies)\n      IO.puts(\"\"\\n=== First Movie Data Structure ===\"\")\n      IO.puts(\"\"Title: #{first_movie.title}\"\")\n      IO.puts(\"\"Year: #{first_movie.year}\"\")\n      IO.puts(\"\"IMDb ID: #{first_movie.imdb_id}\"\")\n      \n      # Check if enhanced data exists\n      if Map.has_key?(first_movie, :award_text) do\n        IO.puts(\"\"\\n=== Enhanced Award Data ===\"\")\n        IO.puts(\"\"Award Text: #{inspect(first_movie.award_text)}\"\")\n        IO.puts(\"\"Extracted Awards:\"\")\n        if first_movie.extracted_awards do\n          Enum.each(first_movie.extracted_awards, fn award ->\n            IO.puts(\"\"  - #{award.award_name}\"\")\n            if award.award_category, do: IO.puts(\"\"    Category: #{award.award_category}\"\")\n            if award.award_year, do: IO.puts(\"\"    Year: #{award.award_year}\"\")\n          end)\n        else\n          IO.puts(\"\"  (No structured awards extracted)\"\")\n        end\n      else\n        IO.puts(\"\"\\nâš ï¸  No enhanced award data found\"\")\n      end\n    end\n    \n  {:error, reason} ->\n    IO.puts(\"\"Error fetching Cannes data: #{inspect(reason)}\"\")\nend\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=3ba3f8f9 mix run test_enhanced_extraction.exs)",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres mix run -e '\n# Check the current Cannes configuration to see if tracks_awards is set\ncase Cinegraph.Movies.MovieLists.get_config(\"\"cannes_winners\"\") do\n  {:ok, config} ->\n    IO.puts(\"\"=== Current Cannes Config ===\"\")\n    IO.inspect(config, pretty: true)\n    \n    tracks_awards = get_in(config.metadata, [\"\"tracks_awards\"\"])\n    IO.puts(\"\"\\ntracks_awards setting: #{inspect(tracks_awards)}\"\")\n    \n  {:error, reason} ->\n    IO.puts(\"\"Error getting config: #{reason}\"\")  \nend\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=3ba3f8f9 mix run test_cannes_awards.exs)",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres mix run -e '\n# Test enhanced extraction logic directly\nsample_html = \"\"\"\"\"\"\n<div class=\"\"lister-item\"\">\n  <h3 class=\"\"titleColumn\"\">\n    <a href=\"\"/title/tt17009710/\"\">Anatomy of a Fall</a>\n    <span class=\"\"secondaryInfo\"\">(2023)</span>\n  </h3>\n  <p class=\"\"text-muted\"\">\n    A woman is suspected of murder after her husband&apos;s death...\n    <span class=\"\"text-small\"\">[2023]: Palme d&apos;Or winner (Best Film).</span>\n  </p>\n  <p class=\"\"text-muted\"\">\n    Director: Justine Triet | Stars: Sandra HÃ¼ller, Swann Arlaud\n  </p>\n</div>\n\"\"\"\"\"\"\n\n# Parse with Floki\ndocument = Floki.parse_document!(sample_html)\nitem = Floki.find(document, \"\".lister-item\"\") |> List.first()\n\n# Simulate what our parser does\nfull_text = Floki.text(item)\nIO.puts(\"\"=== Full Text Extracted ===\"\")\nIO.puts(full_text)\n\n# Test award text extraction patterns directly\naward_patterns = [\n  ~r/\\[20\\d{2}\\]:\\s*Palme d&apos;Or[^.]*\\./i,\n  ~r/\\[20\\d{2}\\]:\\s*Grand Prix[^.]*\\./i,\n  ~r/Palme d&apos;Or winner[^.]*\\./i\n]\n\nIO.puts(\"\"\\n=== Award Pattern Matching ===\"\")\naward_matches = award_patterns\n|> Enum.flat_map(fn pattern ->\n  matches = Regex.scan(pattern, full_text, capture: :all)\n  IO.puts(\"\"Pattern #{inspect(pattern)} found: #{inspect(matches)}\"\")\n  matches |> Enum.map(fn [match] -> String.trim(match) end)\nend)\n|> Enum.reject(&(&1 == \"\"\"\"))\n|> Enum.uniq()\n\nIO.puts(\"\"\\nExtracted award matches: #{inspect(award_matches)}\"\")\n\nif length(award_matches) > 0 do\n  IO.puts(\"\"\\n=== Testing Award Parsing ===\"\")\n  award_text = Enum.join(award_matches, \"\" | \"\")\n  IO.puts(\"\"Award text: #{award_text}\"\")\n  \n  # Test parsing (manually since the function is private)\n  case Regex.run(~r/\\[(\\d{4})\\]:\\s*([^(]+?)(?:\\s*\\(([^)]+)\\))?\\s*\\.?$/i, award_text) do\n    [_, year, award_name, category] ->\n      clean_award_name = String.trim(award_name) |> String.replace(~r/\\s+winner\\s*$/i, \"\"\"\")\n      parsed = %{\n        award_name: clean_award_name,\n        award_category: if(category && category != \"\"\"\", do: String.trim(category), else: nil),\n        award_year: year,\n        raw_text: award_text\n      }\n      IO.puts(\"\"Parsed award: #{inspect(parsed, pretty: true)}\"\")\n    _ ->\n      IO.puts(\"\"No structured parsing match\"\")\n  end\nend\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=3ba3f8f9 mix run -e '\n# Test fetching just the first page to see what these lists contain\nlist_ids = [\"\"ls020806626\"\", \"\"ls073833905\"\"]\n\nEnum.each(list_ids, fn list_id ->\n  IO.puts(\"\"\\n=== Testing List #{list_id} ===\"\")\n  case Cinegraph.Scrapers.ImdbCanonicalScraper.fetch_single_page(list_id, 1) do\n    {:ok, movies} when length(movies) > 0 ->\n      first_movie = List.first(movies)\n      IO.puts(\"\"Found #{length(movies)} movies on first page\"\")\n      IO.puts(\"\"First movie: #{first_movie.title} (#{first_movie.year})\"\")\n      IO.puts(\"\"Position: #{first_movie.position}\"\")\n      if first_movie.description && String.length(first_movie.description) > 0 do\n        IO.puts(\"\"Description sample: #{String.slice(first_movie.description, 0, 100)}...\"\")\n      end\n    {:ok, []} ->\n      IO.puts(\"\"List found but no movies returned\"\")\n    {:error, reason} ->\n      IO.puts(\"\"Error: #{inspect(reason)}\"\")\n  end\nend)\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=3ba3f8f9 mix run -e '\n# Test fetching just the first page to see what these lists contain\nlist_ids = [\"\"ls020806626\"\", \"\"ls073833905\"\"]\n\nEnum.each(list_ids, fn list_id ->\n  IO.puts(\"\"\\n=== Testing List #{list_id} ===\"\")\n  case Cinegraph.Scrapers.ImdbCanonicalScraper.fetch_single_page(list_id, 1) do\n    {:ok, movies} when movies != [] ->\n      first_movie = List.first(movies)\n      IO.puts(\"\"Found #{length(movies)} movies on first page\"\")\n      IO.puts(\"\"First movie: #{first_movie.title} (#{first_movie.year})\"\")\n      IO.puts(\"\"Position: #{first_movie.position}\"\")\n      IO.puts(\"\"IMDb ID: #{first_movie.imdb_id}\"\")\n    {:ok, []} ->\n      IO.puts(\"\"List found but no movies returned\"\")\n    {:error, reason} ->\n      IO.puts(\"\"Error: #{inspect(reason)}\"\")\n  end\nend)\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=3ba3f8f9 mix run -e '\n# Test fetching just the first page to see what these lists contain\nlist_ids = [\"\"ls020806626\"\", \"\"ls073833905\"\"]\n\nEnum.each(list_ids, fn list_id ->\n  IO.puts(\"\"\\n=== Testing List #{list_id} ===\"\")\n  case Cinegraph.Scrapers.ImdbCanonicalScraper.fetch_single_page(list_id, 1) do\n    {:ok, []} ->\n      IO.puts(\"\"List found but no movies returned\"\")\n    {:ok, movies} ->\n      first_movie = List.first(movies)\n      IO.puts(\"\"Found #{length(movies)} movies on first page\"\")\n      IO.puts(\"\"First movie: #{first_movie.title} (#{first_movie.year})\"\")\n      IO.puts(\"\"Position: #{first_movie.position}\"\")\n      IO.puts(\"\"IMDb ID: #{first_movie.imdb_id}\"\")\n    {:error, reason} ->\n      IO.puts(\"\"Error: #{inspect(reason)}\"\")\n  end\nend)\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=3ba3f8f9 mix run -e '\n# Test getting list titles by checking the count method which often includes metadata\nlist_ids = [\"\"ls020806626\"\", \"\"ls073833905\"\"]\n\nEnum.each(list_ids, fn list_id ->\n  IO.puts(\"\"\\n=== Testing List #{list_id} ===\"\")\n  case Cinegraph.Scrapers.ImdbCanonicalScraper.get_expected_movie_count(list_id) do\n    {:ok, count} ->\n      IO.puts(\"\"Expected movie count: #{count}\"\")\n    {:error, reason} ->\n      IO.puts(\"\"Error getting count: #{inspect(reason)}\"\")\n    nil ->\n      IO.puts(\"\"Count returned nil\"\")\n  end\nend)\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres mix ecto.rollback --step 3)",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres mix ecto.migrate)",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres mix run -e '\n# Create the Cannes list configuration without award_types\nalias Cinegraph.Movies.MovieLists\n\nattrs = %{\n  source_key: \"\"cannes_winners\"\",\n  name: \"\"Cannes Film Festival Award Winners: 2023-1939\"\",\n  description: \"\"Complete list of Cannes Film Festival award winners from 2023 back to 1939, including Palme dOr, Grand Prix, and other major awards.\"\",\n  source_type: \"\"imdb\"\",\n  source_url: \"\"https://www.imdb.com/list/ls527026601/\"\",\n  source_id: \"\"ls527026601\"\",\n  category: \"\"awards\"\",\n  active: true,\n  tracks_awards: true,\n  metadata: %{\n    \"\"festival\"\" => \"\"Cannes Film Festival\"\",\n    \"\"note\"\" => \"\"Winners only - no nominees. Award details mixed in descriptions.\"\",\n    \"\"expected_movie_count\"\" => 297,\n    \"\"source\"\" => \"\"IMDB User List\"\",\n    \"\"reliability\"\" => \"\"85%\"\",\n    \"\"data_extraction\"\" => \"\"Enhanced extraction with dynamic award discovery\"\",\n    \"\"tracks_awards\"\" => true\n  }\n}\n\ncase MovieLists.create_movie_list(attrs) do\n  {:ok, list} ->\n    IO.puts(\"\"âœ… Created Cannes list configuration:\"\")\n    IO.puts(\"\"   Source Key: #{list.source_key}\"\")\n    IO.puts(\"\"   Name: #{list.name}\"\")\n    IO.puts(\"\"   Tracks Awards: #{list.tracks_awards}\"\")\n    IO.puts(\"\"   List ID: #{list.source_id}\"\")\n    \n  {:error, changeset} ->\n    IO.puts(\"\"âŒ Error creating list:\"\")\n    IO.inspect(changeset.errors)\nend\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=3ba3f8f9 timeout 60 mix run test_dynamic_discovery.exs)",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=3ba3f8f9 mix run test_dynamic_discovery.exs)",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres mix run test_award_extraction.exs)",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres mix run test_manual_config.exs)",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres mix run -e '\n# Test the tracks_awards? function\nconfig = %{metadata: %{}}\n\nberlin_tracks = Cinegraph.Movies.MovieLists.send(:tracks_awards?, \"\"berlin_golden_bear\"\", config)\nvenice_tracks = Cinegraph.Movies.MovieLists.send(:tracks_awards?, \"\"venice_golden_lion\"\", config)\ncannes_tracks = Cinegraph.Movies.MovieLists.send(:tracks_awards?, \"\"cannes_winners\"\", config)\ncriterion_tracks = Cinegraph.Movies.MovieLists.send(:tracks_awards?, \"\"criterion\"\", config)\n\nIO.puts(\"\"ðŸŽ¬ Testing tracks_awards detection:\"\")\nIO.puts(\"\"  Berlin Golden Bear: #{berlin_tracks}\"\")\nIO.puts(\"\"  Venice Golden Lion: #{venice_tracks}\"\")  \nIO.puts(\"\"  Cannes Winners: #{cannes_tracks}\"\")\nIO.puts(\"\"  Criterion (should be false): #{criterion_tracks}\"\")\n\nif berlin_tracks && venice_tracks && cannes_tracks && !criterion_tracks do\n  IO.puts(\"\"âœ… All festival awards correctly detected!\"\")\nelse\n  IO.puts(\"\"âŒ Award detection not working correctly\"\")\nend\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres mix run -e '\n# Test the tracks_awards? function\nconfig = %{metadata: %{}}\n\nberlin_tracks = Cinegraph.Movies.MovieLists.send(:tracks_awards?, \"\"berlin_golden_bear\"\", config)\nvenice_tracks = Cinegraph.Movies.MovieLists.send(:tracks_awards?, \"\"venice_golden_lion\"\", config)\ncannes_tracks = Cinegraph.Movies.MovieLists.send(:tracks_awards?, \"\"cannes_winners\"\", config)\ncriterion_tracks = Cinegraph.Movies.MovieLists.send(:tracks_awards?, \"\"criterion\"\", config)\n\nIO.puts(\"\"ðŸŽ¬ Testing tracks_awards detection:\"\")\nIO.puts(\"\"  Berlin Golden Bear: #{berlin_tracks}\"\")\nIO.puts(\"\"  Venice Golden Lion: #{venice_tracks}\"\")  \nIO.puts(\"\"  Cannes Winners: #{cannes_tracks}\"\")\nIO.puts(\"\"  Criterion (should be false): #{criterion_tracks}\"\")\n\nif berlin_tracks && venice_tracks && cannes_tracks && (not criterion_tracks) do\n  IO.puts(\"\"âœ… All festival awards correctly detected!\"\")\nelse\n  IO.puts(\"\"âŒ Award detection not working correctly\"\")\nend\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres mix run -e '\n# Test that migrate_hardcoded_lists would correctly set tracks_awards for festivals\nresult = Cinegraph.Movies.MovieLists.migrate_hardcoded_lists()\n\nIO.puts(\"\"ðŸŽ¬ Migration Results:\"\")\nIO.puts(\"\"  Created: #{result.created}\"\")  \nIO.puts(\"\"  Already existed: #{result.existed}\"\")\nIO.puts(\"\"  Errors: #{length(result.errors)}\"\")\n\n# Check tracks_awards values after migration\nimport Ecto.Query\nawards_lists = Cinegraph.Repo.all(\n  from ml in Cinegraph.Movies.MovieList,\n  where: ml.tracks_awards == true,\n  select: {ml.source_key, ml.name}\n)  \n\nIO.puts(\"\"\\nðŸ† Lists tracking awards:\"\")\nEnum.each(awards_lists, fn {key, name} ->\n  IO.puts(\"\"  âœ“ #{key}: #{name}\"\")\nend)\n\nexpected_awards = [\"\"berlin_golden_bear\"\", \"\"cannes_winners\"\", \"\"venice_golden_lion\"\"]\nactual_awards = Enum.map(awards_lists, fn {key, _name} -> key end)\n\nif Enum.sort(expected_awards) == Enum.sort(actual_awards) do\n  IO.puts(\"\"\\nâœ… SUCCESS: All three festival lists correctly track awards!\"\")\nelse\n  IO.puts(\"\"\\nâŒ MISMATCH: Expected #{inspect(expected_awards)}, got #{inspect(actual_awards)}\"\")\nend\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres mix run -e '\n# Test the get_canonical_list_stats function behavior\n# This simulates what the UI shows in the \"\"List Statistics\"\" section\n\nimport Ecto.Query\nalias Cinegraph.{Repo, Movies.MovieLists}\n\n# Get all canonical lists from database and their counts (same logic as UI)\nlist_stats = MovieLists.all_as_config()\n|> Enum.map(fn {list_key, config} ->\n  # Use raw SQL to avoid Ecto escaping issues with the ? operator\n  {:ok, %{rows: [[count]]}} = Repo.query(\n    \"\"SELECT COUNT(*) FROM movies WHERE canonical_sources ? $1\"\",\n    [list_key]\n  )\n  \n  # Get expected count from database metadata if available\n  expected_count = case MovieLists.get_active_by_source_key(list_key) do\n    nil -> nil\n    list -> list.metadata[\"\"expected_movie_count\"\"]\n  end\n  \n  %{\n    key: list_key,\n    name: config.name,\n    count: count,\n    expected_count: expected_count\n  }\nend)\n|> Enum.sort_by(& &1.count, :desc)\n\nIO.puts(\"\"ðŸ“Š List Statistics (same as UI shows):\"\")\nIO.puts(\"\"=\"\" <> String.duplicate(\"\"=\"\", 50))\n\nEnum.each(list_stats, fn stat ->\n  expected_text = if stat.expected_count, do: \"\" / #{stat.expected_count}\"\", else: \"\"\"\"\n  IO.puts(\"\"#{stat.name}\"\")\n  IO.puts(\"\"#{stat.count}#{expected_text} movies\"\")\n  IO.puts(\"\"\"\")\nend)\n\nIO.puts(\"\"ðŸ” Source Verification:\"\")\nIO.puts(\"\"Total lists shown: #{length(list_stats)}\"\")\n\n# Check if all these lists exist in database\ndb_lists = MovieLists.list_all_movie_lists()\nIO.puts(\"\"Database lists count: #{length(db_lists)}\"\")\n\nif length(list_stats) == length(db_lists) do\n  IO.puts(\"\"âœ… SUCCESS: List statistics are based on database-managed lists\"\")\nelse\n  IO.puts(\"\"âŒ MISMATCH: Statistics may still include hardcoded lists\"\")\nend\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres mix run -e '\n# Test the new dynamic system\nIO.puts(\"\"ðŸ§ª Testing Dynamic Movie Lists System\"\")\nIO.puts(\"\"=\"\" <> String.duplicate(\"\"=\"\", 50))\n\n# Test getting active source keys\nall_keys = Cinegraph.Movies.MovieLists.get_active_source_keys()\nIO.puts(\"\"\\nðŸ“‹ All Active Source Keys:\"\")\nEnum.each(all_keys, fn key -> IO.puts(\"\"  - #{key}\"\") end)\n\n# Test filtering by category\nawards_keys = Cinegraph.Movies.MovieLists.get_active_source_keys(category: \"\"awards\"\")\nIO.puts(\"\"\\nðŸ† Awards Category Source Keys:\"\")\nEnum.each(awards_keys, fn key -> IO.puts(\"\"  - #{key}\"\") end)\n\n# Test filtering by tracks_awards\ntracking_keys = Cinegraph.Movies.MovieLists.get_active_source_keys(tracks_awards: true)\nIO.puts(\"\"\\nðŸŽ¯ Lists Tracking Awards:\"\")\nEnum.each(tracking_keys, fn key -> IO.puts(\"\"  - #{key}\"\") end)\n\n# Test individual lookups\nIO.puts(\"\"\\nðŸ” Individual Lookups:\"\")\ntest_keys = [\"\"cannes_winners\"\", \"\"criterion\"\", \"\"berlin_golden_bear\"\"]\nEnum.each(test_keys, fn key ->\n  category = Cinegraph.Movies.MovieLists.get_category_for_source_key(key)\n  tracks_awards = Cinegraph.Movies.MovieLists.tracks_awards_for_source_key?(key)\n  IO.puts(\"\"  #{key}: category=#{category}, tracks_awards=#{tracks_awards}\"\")\nend)\n\nIO.puts(\"\"\\nâœ… Dynamic system working! No hardcoded values needed.\"\")\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres mix run -e '\n# Test that new list is automatically picked up\nIO.puts(\"\"ðŸ§ª Testing New List Added Without Code Changes\"\")\nIO.puts(\"\"=\"\" <> String.duplicate(\"\"=\"\", 60))\n\n# Test it appears in all active lists\nall_keys = Cinegraph.Movies.MovieLists.get_active_source_keys()\nIO.puts(\"\"\\nðŸ“‹ All Active Source Keys (should include test_festival):\"\")\nEnum.each(all_keys, fn key -> \n  marker = if key == \"\"test_festival\"\", do: \"\" â­ NEW\"\", else: \"\"\"\"\n  IO.puts(\"\"  - #{key}#{marker}\"\") \nend)\n\n# Test it appears in awards category\nawards_keys = Cinegraph.Movies.MovieLists.get_active_source_keys(category: \"\"awards\"\")\nIO.puts(\"\"\\nðŸ† Awards Category (should include test_festival):\"\")\nEnum.each(awards_keys, fn key -> \n  marker = if key == \"\"test_festival\"\", do: \"\" â­ NEW\"\", else: \"\"\"\"\n  IO.puts(\"\"  - #{key}#{marker}\"\") \nend)\n\n# Test it tracks awards\ntracking_keys = Cinegraph.Movies.MovieLists.get_active_source_keys(tracks_awards: true)\nIO.puts(\"\"\\nðŸŽ¯ Lists Tracking Awards (should include test_festival):\"\")\nEnum.each(tracking_keys, fn key -> \n  marker = if key == \"\"test_festival\"\", do: \"\" â­ NEW\"\", else: \"\"\"\"\n  IO.puts(\"\"  - #{key}#{marker}\"\") \nend)\n\n# Test individual lookup\ncategory = Cinegraph.Movies.MovieLists.get_category_for_source_key(\"\"test_festival\"\")\ntracks_awards = Cinegraph.Movies.MovieLists.tracks_awards_for_source_key?(\"\"test_festival\"\")\nIO.puts(\"\"\\nðŸ” New List Properties:\"\")\nIO.puts(\"\"  test_festival: category=#{category}, tracks_awards=#{tracks_awards}\"\")\n\n# Test it appears in UI dropdown\navailable_lists = Cinegraph.Workers.CanonicalImportOrchestrator.available_lists()\nif Map.has_key?(available_lists, \"\"test_festival\"\") do\n  config = available_lists[\"\"test_festival\"\"]\n  IO.puts(\"\"\\nâœ… SUCCESS: New list appears in UI dropdown!\"\")\n  IO.puts(\"\"  Name: #{config.name}\"\")\n  IO.puts(\"\"  Category: #{config.category}\"\")\nelse\n  IO.puts(\"\"\\nâŒ FAILED: New list not in UI dropdown\"\")\nend\n\nhas_test = \"\"test_festival\"\" in all_keys\nif has_test do\n  IO.puts(\"\"\\nðŸŽ‰ PERFECT! New list added with ZERO CODE CHANGES!\"\")\n  IO.puts(\"\"  âœ… Appears in all queries\"\")\n  IO.puts(\"\"  âœ… Filtered by category correctly\"\") \n  IO.puts(\"\"  âœ… Filtered by tracks_awards correctly\"\")\n  IO.puts(\"\"  âœ… Available in UI dropdown\"\")\n  IO.puts(\"\"\\n  This proves the system is now fully database-driven! ðŸš€\"\")\nelse\n  IO.puts(\"\"\\nâŒ System still has hardcoded dependencies\"\")\nend\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres mix run -e '\n# Test the complete database-driven system\n\n# 1. Get all canonical lists from database and show they include category\nIO.puts(\"\"=== Testing Complete Database-Driven System ===\"\")\n\nimport Ecto.Query\nalias Cinegraph.{Repo, Movies.MovieLists}\n\n# Get all active lists as config (this is what the UI uses)\nconfig_map = MovieLists.all_as_config()\n\nIO.puts(\"\"\\nðŸ“Š All Lists as Config (same as UI dropdown):\"\")\nEnum.each(config_map, fn {key, config} ->\n  IO.puts(\"\"âœ“ #{key}: #{config.name}\"\")\n  IO.puts(\"\"  Category: #{config.category}\"\")\n  IO.puts(\"\"  Tracks Awards: #{config.metadata[\"\"tracks_awards\"\"] == true}\"\")\n  IO.puts(\"\"\"\")\nend)\n\n# 2. Verify dynamic queries work\nawards_lists = MovieLists.get_active_source_keys(tracks_awards: true)\nfestival_lists = MovieLists.get_active_source_keys(category: \"\"awards\"\")\n\nIO.puts(\"\"ðŸ† Lists that track awards: #{inspect(awards_lists)}\"\")\nIO.puts(\"\"ðŸŽ¬ Festival/awards category lists: #{inspect(festival_lists)}\"\")\n\nif Enum.sort(awards_lists) == Enum.sort(festival_lists) do\n  IO.puts(\"\"âœ… SUCCESS: Award tracking and festival categories match perfectly!\"\")\nelse\n  IO.puts(\"\"âŒ MISMATCH: Different results from award vs category queries\"\")\nend\n\n# 3. Test that we can get individual list configs without errors\nIO.puts(\"\"\\nðŸ” Testing individual list configurations:\"\")\nEnum.each([\"\"cannes_winners\"\", \"\"venice_golden_lion\"\", \"\"berlin_golden_bear\"\"], fn key ->\n  case MovieLists.get_config(key) do\n    {:ok, config} ->\n      IO.puts(\"\"âœ“ #{key}: #{config.name} (category: #{config.category})\"\")\n    {:error, reason} ->\n      IO.puts(\"\"âŒ #{key}: #{reason}\"\")\n  end\nend)\n\nIO.puts(\"\"\\nðŸŽ¯ System is fully database-driven - no hardcoded logic remaining!\"\")\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres mix run -e '\n# Remove the test_festival entry\nimport Ecto.Query\nalias Cinegraph.{Repo, Movies.MovieLists}\n\ncase MovieLists.get_by_source_key(\"\"test_festival\"\") do\n  nil -> IO.puts(\"\"Test festival already removed\"\")\n  list -> \n    {:ok, _} = MovieLists.delete_movie_list(list)\n    IO.puts(\"\"âœ… Removed test festival entry\"\")\nend\n\n# Verify final state\nconfig_map = MovieLists.all_as_config()\nIO.puts(\"\"\\nðŸ“Š Final Active Lists:\"\")\nEnum.each(config_map, fn {key, config} ->\n  category_emoji = case config.category do\n    \"\"awards\"\" -> \"\"ðŸ†\"\"\n    \"\"curated\"\" -> \"\"ðŸ“š\"\"\n    \"\"critics\"\" -> \"\"ðŸŽ­\"\"\n    \"\"registry\"\" -> \"\"ðŸ›ï¸\"\"\n    _ -> \"\"ðŸ“\"\"\n  end\n  tracks_awards = if config.metadata[\"\"tracks_awards\"\"] == true, do: \"\" [Awards]\"\", else: \"\"\"\"\n  IO.puts(\"\"#{category_emoji} #{key}: #{config.name}#{tracks_awards}\"\")\nend)\n\nIO.puts(\"\"\\nâœ… SUCCESS: System is completely database-driven!\"\")\nIO.puts(\"\"   - All hardcoded logic removed\"\")\nIO.puts(\"\"   - Dynamic queries work perfectly\"\") \nIO.puts(\"\"   - Adding new lists requires zero code changes\"\")\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres mix run -e '\n# Verify the final state of the database after clearing and reseeding\nIO.puts(\"\"=== Database State After Clear and Reseed ===\"\")\n\nimport Ecto.Query\nalias Cinegraph.{Repo, Movies.MovieLists}\n\n# Check movie lists\nlists = MovieLists.list_all_movie_lists()\nIO.puts(\"\"\\nðŸ“Š Movie Lists in Database: #{length(lists)}\"\")\nEnum.each(lists, fn list ->\n  category_emoji = case list.category do\n    \"\"awards\"\" -> \"\"ðŸ†\"\"\n    \"\"curated\"\" -> \"\"ðŸ“š\"\"\n    \"\"critics\"\" -> \"\"ðŸŽ­\"\"\n    \"\"registry\"\" -> \"\"ðŸ›ï¸\"\"\n    _ -> \"\"ðŸ“\"\"\n  end\n  awards = if list.tracks_awards, do: \"\" [Tracks Awards]\"\", else: \"\"\"\"\n  IO.puts(\"\"#{category_emoji} #{list.source_key}: #{list.name}#{awards}\"\")\nend)\n\n# Check that Venice and Berlin are correctly configured\nfestival_lists = MovieLists.get_active_source_keys(category: \"\"awards\"\", tracks_awards: true)\nIO.puts(\"\"\\nðŸŽ¬ Festival Lists with Awards:\"\")\nEnum.each(festival_lists, fn key ->\n  IO.puts(\"\"  - #{key}\"\")\nend)\n\nIO.puts(\"\"\\nâœ… Database has been successfully cleared and reseeded!\"\")\nIO.puts(\"\"âœ… Venice and Berlin festivals are properly configured with category=\\\"\"awards\\\"\" and tracks_awards=true\"\")\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=3ba3f8f9 mix run -e '\n# Clear existing Cannes data to test fresh\nIO.puts(\"\"Clearing existing Cannes data...\"\")\nimport Ecto.Query\nCinegraph.Repo.update_all(\n  from(m in Cinegraph.Movies.Movie, where: fragment(\"\"? \\\\? ?\"\", m.canonical_sources, \"\"cannes_winners\"\")),\n  set: [canonical_sources: fragment(\"\"? - ?\"\", m.canonical_sources, \"\"cannes_winners\"\")]\n)\n\n# Test with just one page to verify fix\nIO.puts(\"\"\\nTesting with limited data to verify extracted_awards is preserved...\"\")\n\n# Get the config and process just first page\ncase Cinegraph.Movies.MovieLists.get_config(\"\"cannes_winners\"\") do\n  {:ok, config} ->\n    IO.puts(\"\"Found Cannes config with tracks_awards: #{config.metadata[\"\"tracks_awards\"\"]}\"\")\n    \n    # Fetch and process just first page\n    case Cinegraph.Scrapers.ImdbCanonicalScraper.fetch_single_page(config.list_id, 1) do\n      {:ok, movies} ->\n        IO.puts(\"\"Fetched #{length(movies)} movies from page 1\"\")\n        \n        # Process just first 3 movies with the config\n        test_movies = Enum.take(movies, 3)\n        {:ok, results} = Cinegraph.Scrapers.ImdbCanonicalScraper.process_canonical_movies(test_movies, config)\n        \n        IO.puts(\"\"\\nProcessed #{results.summary.total} movies\"\")\n        IO.puts(\"\"Queued: #{results.summary.queued}\"\")\n        \n        # Wait for workers to process\n        IO.puts(\"\"\\nWaiting for workers to process...\"\")\n        Process.sleep(10000)\n        \n        # Check results\n        IO.puts(\"\"\\n=== Checking Results ===\"\")\n        movies_with_awards = Cinegraph.Repo.all(\n          from m in Cinegraph.Movies.Movie,\n          where: fragment(\"\"? -> ? -> ? IS NOT NULL\"\", m.canonical_sources, \"\"cannes_winners\"\", \"\"extracted_awards\"\"),\n          select: %{\n            title: m.title,\n            awards: fragment(\"\"? -> ? -> ?\"\", m.canonical_sources, \"\"cannes_winners\"\", \"\"extracted_awards\"\")\n          }\n        )\n        \n        IO.puts(\"\"Movies with extracted_awards: #{length(movies_with_awards)}\"\")\n        if length(movies_with_awards) > 0 do\n          IO.puts(\"\"\\nâœ… SUCCESS! extracted_awards field is now being preserved!\"\")\n          Enum.each(movies_with_awards, fn movie ->\n            IO.puts(\"\"  - #{movie.title}: #{inspect(movie.awards)}\"\")\n          end)\n        else\n          IO.puts(\"\"\\nâŒ Still no extracted_awards found\"\")\n        end\n        \n      {:error, reason} ->\n        IO.puts(\"\"Error fetching page: #{inspect(reason)}\"\")\n    end\n    \n  {:error, reason} ->\n    IO.puts(\"\"Error getting config: #{reason}\"\")\nend\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=3ba3f8f9 mix run -e '\n# Clear existing Cannes data to test fresh\nIO.puts(\"\"Clearing existing Cannes data...\"\")\n\n# Direct module call for canonical_movies function - need proper access\nalias Cinegraph.Scrapers.ImdbCanonicalScraper\n\n# Test with the public interface\nIO.puts(\"\"\\nRe-importing a few Cannes movies to test fix...\"\")\n\n# Use the public scrape_list_by_key function which properly handles everything\n# But limit to avoid timeout - we can check Oban jobs instead\ncase ImdbCanonicalScraper.fetch_single_page(\"\"ls527026601\"\", 1) do\n  {:ok, movies} ->\n    IO.puts(\"\"Fetched #{length(movies)} movies\"\")\n    \n    # Just show first few to verify we have data\n    movies\n    |> Enum.take(3)\n    |> Enum.each(fn movie ->\n      IO.puts(\"\"  - #{movie.title} (#{movie.year})\"\")\n    end)\n    \n    IO.puts(\"\"\\nTo verify the fix, run a full import and check:\"\")\n    IO.puts(\"\"SELECT COUNT(*) FROM movies WHERE canonical_sources -> \\\"\"cannes_winners\\\"\" -> \\\"\"extracted_awards\\\"\" IS NOT NULL;\"\")\n    \n  {:error, reason} ->\n    IO.puts(\"\"Error: #{inspect(reason)}\"\")\nend\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=3ba3f8f9 mix run -e '\n# Test the fix by importing a few Cannes movies\nIO.puts(\"\"\\n=== Testing Cannes Import After Fix ===\"\")\nIO.puts(\"\"Testing that extracted_awards is preserved through the import pipeline...\"\")\n\n# Clear any existing Cannes data first\nimport Ecto.Query\nCinegraph.Repo.update_all(\n  from(m in Cinegraph.Movies.Movie, where: fragment(\"\"? \\\\? ?\"\", m.canonical_sources, \"\"cannes_winners\"\")),\n  set: [canonical_sources: fragment(\"\"? - ?\"\", m.canonical_sources, \"\"cannes_winners\"\")]\n)\n\n# Import just first page to test\ncase Cinegraph.Scrapers.ImdbCanonicalScraper.scrape_list_by_key(\"\"cannes_winners\"\", pages: 1) do\n  {:ok, result} ->\n    IO.puts(\"\"\\nImport completed!\"\")\n    IO.puts(\"\"Summary: #{inspect(result.summary)}\"\")\n    \n    # Wait for workers to process\n    IO.puts(\"\"\\nWaiting 15 seconds for workers to complete...\"\")\n    Process.sleep(15000)\n    \n    # Check results\n    IO.puts(\"\"\\n=== Checking Results ===\"\")\n    \n    # Count movies with extracted_awards\n    movies_with_awards = Cinegraph.Repo.all(\n      from m in Cinegraph.Movies.Movie,\n      where: fragment(\"\"? -> ? -> ? IS NOT NULL\"\", m.canonical_sources, \"\"cannes_winners\"\", \"\"extracted_awards\"\"),\n      select: %{\n        id: m.id,\n        title: m.title,\n        imdb_id: m.imdb_id,\n        awards: fragment(\"\"? -> ? -> ?\"\", m.canonical_sources, \"\"cannes_winners\"\", \"\"extracted_awards\"\")\n      }\n    )\n    \n    total_cannes_movies = Cinegraph.Repo.one(\n      from m in Cinegraph.Movies.Movie,\n      where: fragment(\"\"? \\\\? ?\"\", m.canonical_sources, \"\"cannes_winners\"\"),\n      select: count(m.id)\n    )\n    \n    IO.puts(\"\"\\nTotal movies with Cannes data: #{total_cannes_movies}\"\")\n    IO.puts(\"\"Movies with extracted_awards: #{length(movies_with_awards)}\"\")\n    \n    if length(movies_with_awards) > 0 do\n      IO.puts(\"\"\\nâœ… SUCCESS! The fix worked - extracted_awards is now being preserved!\"\")\n      IO.puts(\"\"\\n=== Sample Movies with Awards ===\"\")\n      movies_with_awards\n      |> Enum.take(3)\n      |> Enum.each(fn movie ->\n        IO.puts(\"\"\\n#{movie.title} (#{movie.imdb_id})\"\")\n        IO.puts(\"\"Awards: #{inspect(movie.awards, pretty: true)}\"\")\n      end)\n    else\n      IO.puts(\"\"\\nâŒ FAILED: Still no extracted_awards found after fix\"\")\n      \n      # Debug: Check what actually got stored\n      sample_movie = Cinegraph.Repo.one(\n        from m in Cinegraph.Movies.Movie,\n        where: fragment(\"\"? \\\\? ?\"\", m.canonical_sources, \"\"cannes_winners\"\"),\n        limit: 1\n      )\n      \n      if sample_movie do\n        IO.puts(\"\"\\n=== Debug: Sample Cannes Data ===\"\")\n        IO.puts(\"\"Movie: #{sample_movie.title}\"\")\n        cannes_data = sample_movie.canonical_sources[\"\"cannes_winners\"\"]\n        IO.puts(\"\"Keys in cannes_winners: #{inspect(Map.keys(cannes_data))}\"\")\n        IO.puts(\"\"Full data: #{inspect(cannes_data, pretty: true)}\"\")\n      end\n    end\n    \n  {:error, reason} ->\n    IO.puts(\"\"Error running import: #{inspect(reason)}\"\")\nend\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres mix run -e '\n# Verify database state after clear and reseed\nIO.puts(\"\"=== Verifying Database State ===\"\")\n\nimport Ecto.Query\nalias Cinegraph.{Repo, Movies.MovieLists}\n\n# Check movie lists\nlists = MovieLists.list_all_movie_lists()\nIO.puts(\"\"\\nðŸ“Š Movie Lists in Database: #{length(lists)}\"\")\nEnum.each(lists, fn list ->\n  category_emoji = case list.category do\n    \"\"awards\"\" -> \"\"ðŸ†\"\"\n    \"\"curated\"\" -> \"\"ðŸ“š\"\"\n    \"\"critics\"\" -> \"\"ðŸŽ­\"\"\n    \"\"registry\"\" -> \"\"ðŸ›ï¸\"\"\n    _ -> \"\"ðŸ“\"\"\n  end\n  awards = if list.tracks_awards, do: \"\" [Tracks Awards]\"\", else: \"\"\"\"\n  IO.puts(\"\"#{category_emoji} #{list.source_key}: #{list.name}#{awards}\"\")\nend)\n\n# Verify empty tables\nmovie_count = Repo.aggregate(Cinegraph.Movies.Movie, :count)\npeople_count = Repo.aggregate(Cinegraph.Movies.Person, :count)\noscar_count = Repo.aggregate(Cinegraph.Cultural.OscarCeremony, :count)\n\nIO.puts(\"\"\\nðŸ“Š Database Counts:\"\")\nIO.puts(\"\"  Movies: #{movie_count}\"\")\nIO.puts(\"\"  People: #{people_count}\"\")\nIO.puts(\"\"  Oscar Ceremonies: #{oscar_count}\"\")\n\n# Check that our festival lists are there\nfestival_lists = MovieLists.get_active_source_keys(category: \"\"awards\"\", tracks_awards: true)\nIO.puts(\"\"\\nðŸŽ¬ Festival Lists with Awards:\"\")\nEnum.each(festival_lists, fn key ->\n  IO.puts(\"\"  - #{key}\"\")\nend)\n\nIO.puts(\"\"\\nâœ… Database successfully cleared and reseeded according to README!\"\")\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres mix run -e '\n# Verify database state after reset and reseed\nIO.puts(\"\"=== Database State After Reset and Reseed ===\"\")\n\nimport Ecto.Query\nalias Cinegraph.{Repo, Movies.MovieLists}\n\n# Check movie lists\nlists = MovieLists.list_all_movie_lists()\nIO.puts(\"\"\\nðŸ“Š Movie Lists in Database: #{length(lists)}\"\")\nEnum.each(lists, fn list ->\n  category_emoji = case list.category do\n    \"\"awards\"\" -> \"\"ðŸ†\"\"\n    \"\"curated\"\" -> \"\"ðŸ“š\"\"\n    \"\"critics\"\" -> \"\"ðŸŽ­\"\"\n    \"\"registry\"\" -> \"\"ðŸ›ï¸\"\"\n    _ -> \"\"ðŸ“\"\"\n  end\n  awards = if list.tracks_awards, do: \"\" [Tracks Awards]\"\", else: \"\"\"\"\n  IO.puts(\"\"#{category_emoji} #{list.source_key}: #{list.name}#{awards}\"\")\nend)\n\n# Verify empty tables\nmovie_count = Repo.aggregate(Cinegraph.Movies.Movie, :count)\npeople_count = Repo.aggregate(Cinegraph.Movies.Person, :count)\noscar_count = Repo.aggregate(Cinegraph.Cultural.OscarCeremony, :count)\noban_jobs = Repo.aggregate(Oban.Job, :count)\n\nIO.puts(\"\"\\nðŸ“Š Database Counts:\"\")\nIO.puts(\"\"  Movies: #{movie_count}\"\")\nIO.puts(\"\"  People: #{people_count}\"\")\nIO.puts(\"\"  Oscar Ceremonies: #{oscar_count}\"\")\nIO.puts(\"\"  Oban Jobs: #{oban_jobs}\"\")\n\n# Check that our festival lists are properly configured\nfestival_lists = MovieLists.get_active_source_keys(category: \"\"awards\"\", tracks_awards: true)\nIO.puts(\"\"\\nðŸŽ¬ Festival Lists with Awards:\"\")\nEnum.each(festival_lists, fn key ->\n  IO.puts(\"\"  - #{key}\"\")\nend)\n\nIO.puts(\"\"\\nâœ… Database successfully reset and reseeded!\"\")\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=3ba3f8f9 mix run test_cannes_import_fix.exs)",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=3ba3f8f9 mix run test_cannes_import_fix_simple.exs)",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=3ba3f8f9 mix run test_cannes_manual.exs)",
      "Bash(timeout 30 mix run test_full_extraction.exs)",
      "Bash(timeout 20 mix run test_simple_scrape.exs)",
      "Bash(timeout:*)",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres mix run -e '\nIO.puts(\"\"=== Auditing Current Cannes Import Status ===\"\")\n\nimport Ecto.Query\nalias Cinegraph.Repo\n\n# Check if any Cannes movies have been imported\ncannes_movies = Repo.all(\n  from m in Cinegraph.Movies.Movie,\n  where: fragment(\"\"? \\\\? ?\"\", m.canonical_sources, \"\"cannes_winners\"\"),\n  select: %{\n    id: m.id,\n    title: m.title,\n    imdb_id: m.imdb_id,\n    cannes_data: fragment(\"\"? -> ?\"\", m.canonical_sources, \"\"cannes_winners\"\")\n  },\n  limit: 10\n)\n\nIO.puts(\"\"\\\\nFound #{length(cannes_movies)} Cannes movies in database\"\")\n\nif length(cannes_movies) > 0 do\n  IO.puts(\"\"\\\\n=== Sample Cannes Movies ===\"\")\n  \n  Enum.each(cannes_movies, fn movie ->\n    IO.puts(\"\"\\\\n#{movie.title} (#{movie.imdb_id})\"\")\n    \n    cannes_data = movie.cannes_data\n    \n    # Check specifically for extracted_awards\n    extracted_awards = get_in(cannes_data, [\"\"extracted_awards\"\"])\n    award_text = get_in(cannes_data, [\"\"award_text\"\"])\n    list_position = get_in(cannes_data, [\"\"list_position\"\"])\n    scraped_at = get_in(cannes_data, [\"\"scraped_at\"\"])\n    \n    IO.puts(\"\"  Position: #{list_position}\"\")\n    IO.puts(\"\"  Scraped at: #{scraped_at}\"\")\n    IO.puts(\"\"  Award text: #{if award_text, do: String.slice(award_text, 0, 100), else: \"\"nil\"\"}...\"\")\n    \n    if extracted_awards do\n      IO.puts(\"\"  âœ… HAS extracted_awards: #{inspect(extracted_awards)}\"\")\n    else\n      IO.puts(\"\"  âŒ NO extracted_awards field\"\")\n    end\n  end)\n  \n  # Count how many have extracted_awards\n  with_awards = Enum.count(cannes_movies, fn movie ->\n    get_in(movie.cannes_data, [\"\"extracted_awards\"\"]) != nil\n  end)\n  \n  IO.puts(\"\"\\\\nðŸ“Š Summary:\"\")\n  IO.puts(\"\"  Movies with extracted_awards: #{with_awards}/#{length(cannes_movies)}\"\")\n  \n  if with_awards > 0 do\n    IO.puts(\"\"  âœ… SUCCESS: Award extraction is working!\"\")\n  else\n    IO.puts(\"\"  âŒ ISSUE: No movies have extracted_awards yet\"\")\n    \n    # Check if import is still running\n    IO.puts(\"\"\\\\nðŸ” Checking if import is still running...\"\")\n    import_jobs = Repo.all(\n      from j in Oban.Job,\n      where: j.worker in [\"\"Cinegraph.Workers.CanonicalImportOrchestrator\"\", \"\"Cinegraph.Workers.CanonicalPageWorker\"\"],\n      where: j.state in [\"\"executing\"\", \"\"available\"\", \"\"retryable\"\"],\n      select: %{worker: j.worker, state: j.state, args: j.args}\n    )\n    \n    if length(import_jobs) > 0 do\n      IO.puts(\"\"  ðŸ”„ Import still running: #{length(import_jobs)} jobs\"\")\n      Enum.each(import_jobs, fn job ->\n        IO.puts(\"\"    #{job.worker}: #{job.state}\"\")\n      end)\n    else\n      IO.puts(\"\"  â¹ï¸  No active import jobs - import may be complete\"\")\n    end\n  end\nelse\n  IO.puts(\"\"\\\\nâš ï¸  No Cannes movies found yet\"\")\n  \n  # Check if import jobs are running\n  import_jobs = Repo.all(\n    from j in Oban.Job,\n    where: j.worker in [\"\"Cinegraph.Workers.CanonicalImportOrchestrator\"\", \"\"Cinegraph.Workers.CanonicalPageWorker\"\"],\n    where: j.state in [\"\"executing\"\", \"\"available\"\", \"\"retryable\"\"],\n    select: %{worker: j.worker, state: j.state}\n  )\n  \n  if length(import_jobs) > 0 do\n    IO.puts(\"\"  ðŸ”„ Import jobs still running: #{length(import_jobs)}\"\")\n  else\n    IO.puts(\"\"  â“ No import jobs found\"\")\n  end\nend\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres mix run -e '\nIO.puts(\"\"=== Auditing Current Cannes Import Status ===\"\")\n\nimport Ecto.Query\nalias Cinegraph.Repo\n\n# Check if any Cannes movies have been imported\ncannes_movies = Repo.all(\n  from m in Cinegraph.Movies.Movie,\n  where: fragment(\"\"? ? ?\"\", m.canonical_sources, \"\"?\"\", \"\"cannes_winners\"\"),\n  select: %{\n    id: m.id,\n    title: m.title,\n    imdb_id: m.imdb_id,\n    cannes_data: fragment(\"\"? -> ?\"\", m.canonical_sources, \"\"cannes_winners\"\")\n  },\n  limit: 10\n)\n\nIO.puts(\"\"Found #{length(cannes_movies)} Cannes movies in database\"\")\n\nif length(cannes_movies) > 0 do\n  IO.puts(\"\"\\n=== Sample Cannes Movies ===\"\")\n  \n  Enum.each(cannes_movies, fn movie ->\n    IO.puts(\"\"\\n#{movie.title} (#{movie.imdb_id})\"\")\n    \n    cannes_data = movie.cannes_data\n    \n    # Check specifically for extracted_awards\n    extracted_awards = get_in(cannes_data, [\"\"extracted_awards\"\"])\n    award_text = get_in(cannes_data, [\"\"award_text\"\"])\n    list_position = get_in(cannes_data, [\"\"list_position\"\"])\n    scraped_at = get_in(cannes_data, [\"\"scraped_at\"\"])\n    \n    IO.puts(\"\"  Position: #{list_position}\"\")\n    IO.puts(\"\"  Scraped at: #{scraped_at}\"\")\n    IO.puts(\"\"  Award text: #{if award_text, do: String.slice(award_text, 0, 100), else: \"\"nil\"\"}...\"\")\n    \n    if extracted_awards do\n      IO.puts(\"\"  âœ… HAS extracted_awards: #{inspect(extracted_awards)}\"\")\n    else\n      IO.puts(\"\"  âŒ NO extracted_awards field\"\")\n    end\n  end)\n  \n  # Count how many have extracted_awards\n  with_awards = Enum.count(cannes_movies, fn movie ->\n    get_in(movie.cannes_data, [\"\"extracted_awards\"\"]) != nil\n  end)\n  \n  IO.puts(\"\"\\nðŸ“Š Summary:\"\")\n  IO.puts(\"\"  Movies with extracted_awards: #{with_awards}/#{length(cannes_movies)}\"\")\n  \n  if with_awards > 0 do\n    IO.puts(\"\"  âœ… SUCCESS: Award extraction is working!\"\")\n  else\n    IO.puts(\"\"  âŒ ISSUE: No movies have extracted_awards yet\"\")\n    \n    # Check if import is still running\n    IO.puts(\"\"\\nðŸ” Checking if import is still running...\"\")\n    import_jobs = Repo.all(\n      from j in Oban.Job,\n      where: j.worker in [\"\"Cinegraph.Workers.CanonicalImportOrchestrator\"\", \"\"Cinegraph.Workers.CanonicalPageWorker\"\"],\n      where: j.state in [\"\"executing\"\", \"\"available\"\", \"\"retryable\"\"]\n    )\n    \n    if length(import_jobs) > 0 do\n      IO.puts(\"\"  ðŸ”„ Import still running: #{length(import_jobs)} jobs\"\")\n    else\n      IO.puts(\"\"  â¹ï¸  No active import jobs - import may be complete\"\")\n    end\n  end\nelse\n  IO.puts(\"\"\\nâš ï¸  No Cannes movies found yet\"\")\nend\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres mix run test_server_code_version.exs)",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres mix run test_direct_import.exs)",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres mix run -e '\nimport Ecto.Query\nalias Cinegraph.Repo\n\n# Check if import jobs are running\nimport_jobs = Repo.all(\n  from j in Oban.Job,\n  where: j.worker in [\"\"Cinegraph.Workers.CanonicalImportOrchestrator\"\", \"\"Cinegraph.Workers.CanonicalPageWorker\"\"],\n  where: j.state in [\"\"executing\"\", \"\"available\"\", \"\"retryable\"\"],\n  select: %{id: j.id, worker: j.worker, state: j.state, args: j.args}\n)\n\nIO.puts(\"\"=== Import Job Status ===\"\")\nif length(import_jobs) > 0 do\n  IO.puts(\"\"Found #{length(import_jobs)} active import jobs:\"\")\n  Enum.each(import_jobs, fn job ->\n    worker_short = String.replace(job.worker, \"\"Cinegraph.Workers.\"\", \"\"\"\")\n    IO.puts(\"\"  #{job.id}: #{worker_short} (#{job.state})\"\")\n  end)\nelse\n  IO.puts(\"\"No active import jobs found\"\")\nend\n\n# Check total movies\ntotal_movies = Repo.aggregate(Cinegraph.Movies.Movie, :count)\nIO.puts(\"\"\\\\nTotal movies in database: #{total_movies}\"\")\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres mix run -e '\nimport Ecto.Query\nalias Cinegraph.Repo\n\n# Check all jobs related to import\njobs = Repo.all(\n  from j in Oban.Job,\n  where: j.worker in [\"\"Cinegraph.Workers.CanonicalImportOrchestrator\"\", \"\"Cinegraph.Workers.CanonicalPageWorker\"\", \"\"Cinegraph.Workers.TMDbDetailsWorker\"\"],\n  where: j.state in [\"\"executing\"\", \"\"available\"\", \"\"retryable\"\", \"\"scheduled\"\"],\n  order_by: [desc: j.id],\n  limit: 10,\n  select: %{id: j.id, worker: j.worker, state: j.state, inserted_at: j.inserted_at}\n)\n\nIO.puts(\"\"=== Recent Import-Related Jobs ===\"\")\nif length(jobs) > 0 do\n  Enum.each(jobs, fn job ->\n    worker_short = String.replace(job.worker, \"\"Cinegraph.Workers.\"\", \"\"\"\")\n    inserted_time = job.inserted_at |> DateTime.to_string()\n    IO.puts(\"\"#{job.id}: #{worker_short} (#{job.state}) - #{inserted_time}\"\")\n  end)\nelse\n  IO.puts(\"\"No recent import-related jobs found\"\")\nend\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres mix run debug_worker_path.exs)",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres mix compile)",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres mix run test_complete_pipeline.exs)",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres mix run -e '\nimport Ecto.Query\nalias Cinegraph.Repo\n\n# Check job status\njob = Repo.get(Oban.Job, 14098)\nif job do\n  IO.puts(\"\"Job 14098 status: #{job.state}\"\")\n  if job.state == \"\"completed\"\" do\n    IO.puts(\"\"âœ… Job completed successfully\"\")\n  else\n    IO.puts(\"\"Job not completed yet, state: #{job.state}\"\")\n  end\nelse\n  IO.puts(\"\"Job not found\"\")\nend\n\n# Check for any Cannes movies\n{:ok, result} = Repo.query(\"\"SELECT COUNT(*) FROM movies WHERE canonical_sources ? ?\"\", [\"\"cannes_winners\"\"])\n[[count]] = result.rows\nIO.puts(\"\"Cannes movies in database: #{count}\"\")\n\n# Check for movies with extracted_awards\n{:ok, result2} = Repo.query(\"\"SELECT COUNT(*) FROM movies WHERE canonical_sources -> ? -> ? IS NOT NULL\"\", [\"\"cannes_winners\"\", \"\"extracted_awards\"\"])\n[[with_awards]] = result2.rows\nIO.puts(\"\"Movies with extracted_awards: #{with_awards}\"\")\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres mix run -e '\nimport Ecto.Query\nalias Cinegraph.Repo\n\n# Check all recent jobs\njobs = Repo.all(\n  from j in Oban.Job,\n  where: j.id >= 14098,\n  order_by: [desc: j.id],\n  limit: 10,\n  select: %{id: j.id, worker: j.worker, state: j.state, inserted_at: j.inserted_at}\n)\n\nIO.puts(\"\"=== Recent Jobs (>= 14098) ===\"\")\nEnum.each(jobs, fn job ->\n  worker_short = String.replace(job.worker, \"\"Cinegraph.Workers.\"\", \"\"\"\")\n  IO.puts(\"\"#{job.id}: #{worker_short} (#{job.state})\"\")\nend)\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres mix run -e '\nimport Ecto.Query\nalias Cinegraph.Repo\n\n# Check the main job\njob = Repo.get(Oban.Job, 14098)\nIO.puts(\"\"CanonicalPageWorker 14098 status: #{job.state}\"\")\n\nif job.state == \"\"failed\"\" and job.errors do\n  IO.puts(\"\"âŒ Job failed with errors:\"\")\n  IO.puts(inspect(job.errors))\nend\n\n# Check for any TMDbDetailsWorker jobs created after our test\ndetail_jobs = Repo.all(\n  from j in Oban.Job,\n  where: j.worker == \"\"Cinegraph.Workers.TMDbDetailsWorker\"\" and j.id > 14098,\n  order_by: [desc: j.id],\n  limit: 5,\n  select: %{id: j.id, state: j.state, args: j.args}\n)\n\nIO.puts(\"\"\\\\nTMDbDetailsWorker jobs created after 14098:\"\")\nif length(detail_jobs) > 0 do\n  Enum.each(detail_jobs, fn job ->\n    imdb_id = get_in(job.args, [\"\"imdb_id\"\"])\n    IO.puts(\"\"  #{job.id}: #{job.state} (#{imdb_id})\"\")\n  end)\nelse\n  IO.puts(\"\"  No TMDbDetailsWorker jobs found\"\")\nend\n\n# Final check for Cannes data\n{:ok, result} = Repo.query(\"\"SELECT COUNT(*) FROM movies WHERE canonical_sources ? $1\"\", [\"\"cannes_winners\"\"])\n[[count]] = result.rows\nIO.puts(\"\"\\\\nCannes movies in database: #{count}\"\")\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres mix run -e '\n# Deep dive analysis of awards JSON with fixed JSONB queries\nIO.puts(\"\"ðŸ” === Deep Dive Awards JSON Analysis ===\"\")\nIO.puts(\"\"Analyzing award data quality across all three festivals\"\")\n\nimport Ecto.Query\nalias Cinegraph.Repo\n\n# 1. Overall Festival Statistics\nIO.puts(\"\"\\nðŸ“Š === Festival Overview ===\"\")\n\nfestivals = [\n  {\"\"cannes_winners\"\", \"\"Cannes Film Festival\"\"},\n  {\"\"berlin_golden_bear\"\", \"\"Berlin International Film Festival\"\"},\n  {\"\"venice_golden_lion\"\", \"\"Venice International Film Festival\"\"}\n]\n\nfestival_stats = Enum.map(festivals, fn {source_key, name} ->\n  {:ok, result} = Repo.query(\"\"SELECT COUNT(*) FROM movies WHERE canonical_sources ? $1\"\", [source_key])\n  [[count]] = result.rows\n  \n  # Check extraction rates\n  {:ok, award_result} = Repo.query(\"\"SELECT COUNT(*) FROM movies WHERE canonical_sources -> $1 ->> \\\"\"extracted_awards\\\"\" IS NOT NULL\"\", [source_key])\n  [[with_awards]] = award_result.rows\n  \n  {:ok, text_result} = Repo.query(\"\"SELECT COUNT(*) FROM movies WHERE canonical_sources -> $1 ->> \\\"\"award_text\\\"\" IS NOT NULL\"\", [source_key])\n  [[with_text]] = text_result.rows\n  \n  %{\n    source_key: source_key,\n    name: name,\n    total_movies: count,\n    with_extracted_awards: with_awards,\n    with_award_text: with_text,\n    extraction_rate: if(count > 0, do: Float.round(with_awards / count * 100, 1), else: 0)\n  }\nend)\n\nEnum.each(festival_stats, fn stat ->\n  IO.puts(\"\"#{stat.name}:\"\")\n  IO.puts(\"\"  Total movies: #{stat.total_movies}\"\")\n  IO.puts(\"\"  With extracted_awards: #{stat.with_extracted_awards} (#{stat.extraction_rate}%)\"\")\n  IO.puts(\"\"  With award_text: #{stat.with_award_text}\"\")\n  IO.puts(\"\"\"\")\nend)\n\ntotal_movies = Enum.sum(Enum.map(festival_stats, & &1.total_movies))\ntotal_with_awards = Enum.sum(Enum.map(festival_stats, & &1.with_extracted_awards))\noverall_rate = if total_movies > 0, do: Float.round(total_with_awards / total_movies * 100, 1), else: 0\n\nIO.puts(\"\"ðŸŽ¯ Overall Statistics:\"\")\nIO.puts(\"\"  Total festival movies: #{total_movies}\"\")\nIO.puts(\"\"  Total with awards: #{total_with_awards}\"\")\nIO.puts(\"\"  Overall extraction rate: #{overall_rate}%\"\")\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres mix run -e '\n# Deep dive analysis with corrected JSONB queries\nIO.puts(\"\"ðŸ” === Deep Dive Awards JSON Analysis ===\"\")\n\nimport Ecto.Query\nalias Cinegraph.Repo\n\n# 1. Festival Overview with correct JSONB syntax\nIO.puts(\"\"\\nðŸ“Š === Festival Overview ===\"\")\n\nfestivals = [\n  {\"\"cannes_winners\"\", \"\"Cannes Film Festival\"\"},\n  {\"\"berlin_golden_bear\"\", \"\"Berlin International Film Festival\"\"}, \n  {\"\"venice_golden_lion\"\", \"\"Venice International Film Festival\"\"}\n]\n\nfestival_stats = Enum.map(festivals, fn {source_key, name} ->\n  # Total movies\n  {:ok, result} = Repo.query(\"\"SELECT COUNT(*) FROM movies WHERE canonical_sources ? $1\"\", [source_key])\n  [[count]] = result.rows\n  \n  # Movies with extracted_awards (correct JSONB path)\n  {:ok, award_result} = Repo.query(\"\"SELECT COUNT(*) FROM movies WHERE canonical_sources -> $1 -> \\\"\"extracted_awards\\\"\" IS NOT NULL\"\", [source_key])\n  [[with_awards]] = award_result.rows\n  \n  # Movies with award_text\n  {:ok, text_result} = Repo.query(\"\"SELECT COUNT(*) FROM movies WHERE canonical_sources -> $1 -> \\\"\"award_text\\\"\" IS NOT NULL\"\", [source_key])\n  [[with_text]] = text_result.rows\n  \n  %{\n    source_key: source_key,\n    name: name,\n    total_movies: count,\n    with_extracted_awards: with_awards,\n    with_award_text: with_text,\n    extraction_rate: if(count > 0, do: Float.round(with_awards / count * 100, 1), else: 0)\n  }\nend)\n\nEnum.each(festival_stats, fn stat ->\n  IO.puts(\"\"#{stat.name}:\"\")\n  IO.puts(\"\"  Total movies: #{stat.total_movies}\"\")\n  IO.puts(\"\"  With extracted_awards: #{stat.with_extracted_awards} (#{stat.extraction_rate}%)\"\")\n  IO.puts(\"\"  With award_text: #{stat.with_award_text}\"\")\n  IO.puts(\"\"\"\")\nend)\n\ntotal_movies = Enum.sum(Enum.map(festival_stats, & &1.total_movies))\ntotal_with_awards = Enum.sum(Enum.map(festival_stats, & &1.with_extracted_awards))\noverall_rate = if total_movies > 0, do: Float.round(total_with_awards / total_movies * 100, 1), else: 0\n\nIO.puts(\"\"ðŸŽ¯ Overall Statistics:\"\")\nIO.puts(\"\"  Total festival movies: #{total_movies}\"\")\nIO.puts(\"\"  Total with awards: #{total_with_awards}\"\")\nIO.puts(\"\"  Overall extraction rate: #{overall_rate}%\"\")\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres mix run -e '\n# Deep dive analysis with correct understanding of data structure\nIO.puts(\"\"ðŸ” === Deep Dive Awards JSON Analysis ===\"\")\n\nimport Ecto.Query\nalias Cinegraph.Repo\n\n# 1. Festival Overview Statistics\nIO.puts(\"\"\\nðŸ“Š === Festival Overview ===\"\")\n\nfestivals = [\n  {\"\"cannes_winners\"\", \"\"Cannes Film Festival\"\"},\n  {\"\"berlin_golden_bear\"\", \"\"Berlin International Film Festival\"\"}, \n  {\"\"venice_golden_lion\"\", \"\"Venice International Film Festival\"\"}\n]\n\nfestival_stats = Enum.map(festivals, fn {source_key, name} ->\n  # Use direct SQL queries to avoid JSONB operator issues in Ecto\n  {:ok, total_result} = Repo.query(\"\"SELECT COUNT(*) FROM movies WHERE canonical_sources ? $1\"\", [source_key])\n  [[total_count]] = total_result.rows\n  \n  # Check for extracted_awards presence\n  {:ok, awards_result} = Repo.query(\n    \"\"SELECT COUNT(*) FROM movies WHERE canonical_sources -> $1 -> $2 IS NOT NULL\"\", \n    [source_key, \"\"extracted_awards\"\"]\n  )\n  [[awards_count]] = awards_result.rows\n  \n  # Check for award_text presence\n  {:ok, text_result} = Repo.query(\n    \"\"SELECT COUNT(*) FROM movies WHERE canonical_sources -> $1 -> $2 IS NOT NULL\"\", \n    [source_key, \"\"award_text\"\"]\n  )\n  [[text_count]] = text_result.rows\n  \n  extraction_rate = if total_count > 0, do: Float.round(awards_count / total_count * 100, 1), else: 0\n  \n  %{\n    source_key: source_key,\n    name: name,\n    total_movies: total_count,\n    with_extracted_awards: awards_count,\n    with_award_text: text_count,\n    extraction_rate: extraction_rate\n  }\nend)\n\nEnum.each(festival_stats, fn stat ->\n  IO.puts(\"\"#{stat.name}:\"\")\n  IO.puts(\"\"  Total movies: #{stat.total_movies}\"\")\n  IO.puts(\"\"  With extracted_awards: #{stat.with_extracted_awards} (#{stat.extraction_rate}%)\"\")\n  IO.puts(\"\"  With award_text: #{stat.with_award_text}\"\")\n  IO.puts(\"\"\"\")\nend)\n\ntotal_movies = Enum.sum(Enum.map(festival_stats, & &1.total_movies))\ntotal_with_awards = Enum.sum(Enum.map(festival_stats, & &1.with_extracted_awards))\noverall_rate = if total_movies > 0, do: Float.round(total_with_awards / total_movies * 100, 1), else: 0\n\nIO.puts(\"\"ðŸŽ¯ Overall Statistics:\"\")\nIO.puts(\"\"  Total festival movies: #{total_movies}\"\")\nIO.puts(\"\"  Total with awards: #{total_with_awards}\"\")\nIO.puts(\"\"  Overall extraction rate: #{overall_rate}%\"\")\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres mix run -e '\n# Detailed award quality analysis\nIO.puts(\"\"\\nðŸ† === Award Quality Analysis ===\"\")\n\nimport Ecto.Query\nalias Cinegraph.Repo\n\n# 2. Award Structure Quality by Festival\nfestivals = [\n  {\"\"cannes_winners\"\", \"\"Cannes Film Festival\"\"},\n  {\"\"berlin_golden_bear\"\", \"\"Berlin International Film Festival\"\"}, \n  {\"\"venice_golden_lion\"\", \"\"Venice International Film Festival\"\"}\n]\n\nEnum.each(festivals, fn {source_key, name} ->\n  IO.puts(\"\"\\n=== #{name} ===\"\")\n  \n  # Get sample awards to understand structure\n  {:ok, sample_result} = Repo.query(\"\"\"\"\"\"\n    SELECT title, canonical_sources -> $1 -> $2 as awards,\n           canonical_sources -> $1 -> $3 as award_text\n    FROM movies \n    WHERE canonical_sources ? $1 \n    LIMIT 5\n  \"\"\"\"\"\", [source_key, \"\"extracted_awards\"\", \"\"award_text\"\"])\n  \n  award_types = %{}\n  total_awards = 0\n  awards_with_year = 0\n  awards_with_category = 0\n  \n  Enum.each(sample_result.rows, fn [title, awards_json, award_text] ->\n    if awards_json do\n      awards = Jason.decode!(awards_json)\n      total_awards = total_awards + length(awards)\n      \n      Enum.each(awards, fn award ->\n        # Count structured fields\n        if award[\"\"award_year\"\"], do: awards_with_year = awards_with_year + 1\n        if award[\"\"award_category\"\"], do: awards_with_category = awards_with_category + 1\n        \n        # Track award types\n        award_name = award[\"\"award_name\"\"] || \"\"Unknown\"\"\n        award_types = Map.update(award_types, award_name, 1, &(&1 + 1))\n      end)\n      \n      IO.puts(\"\"#{title}:\"\")\n      IO.puts(\"\"  Award text: #{String.slice(award_text || \"\"\"\", 0, 60)}...\"\")\n      IO.puts(\"\"  Structured awards: #{length(awards)}\"\")\n      Enum.each(awards, fn award ->\n        year_info = if award[\"\"award_year\"\"], do: \"\" (#{award[\"\"award_year\"\"]})\"\", else: \"\"\"\"\n        category_info = if award[\"\"award_category\"\"], do: \"\" - #{award[\"\"award_category\"\"]}\"\", else: \"\"\"\"\n        IO.puts(\"\"    - #{award[\"\"award_name\"\"]}#{year_info}#{category_info}\"\")\n      end)\n      IO.puts(\"\"\"\")\n    end\n  end)\n  \n  IO.puts(\"\"Quality Metrics:\"\")\n  IO.puts(\"\"  Total sample awards: #{total_awards}\"\")\n  IO.puts(\"\"  Awards with year: #{awards_with_year} (#{if total_awards > 0, do: Float.round(awards_with_year/total_awards*100, 1), else: 0}%)\"\")\n  IO.puts(\"\"  Awards with category: #{awards_with_category} (#{if total_awards > 0, do: Float.round(awards_with_category/total_awards*100, 1), else: 0}%)\"\")\n  \n  IO.puts(\"\"\\nAward Types Found:\"\")\n  award_types\n  |> Enum.sort_by(fn {_, count} -> count end, :desc)\n  |> Enum.take(10)\n  |> Enum.each(fn {name, count} ->\n    IO.puts(\"\"  #{name}: #{count}\"\")\n  end)\nend)\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres mix run -e '\n# Detailed award quality analysis\nIO.puts(\"\"\\nðŸ† === Award Quality Analysis ===\"\")\n\nimport Ecto.Query\nalias Cinegraph.Repo\n\n# 2. Award Structure Quality by Festival\nfestivals = [\n  {\"\"cannes_winners\"\", \"\"Cannes Film Festival\"\"},\n  {\"\"berlin_golden_bear\"\", \"\"Berlin International Film Festival\"\"}, \n  {\"\"venice_golden_lion\"\", \"\"Venice International Film Festival\"\"}\n]\n\nEnum.each(festivals, fn {source_key, name} ->\n  IO.puts(\"\"\\n=== #{name} ===\"\")\n  \n  # Get sample awards to understand structure\n  {:ok, sample_result} = Repo.query(\"\"\"\"\"\"\n    SELECT title, canonical_sources -> $1 -> $2 as awards,\n           canonical_sources -> $1 -> $3 as award_text\n    FROM movies \n    WHERE canonical_sources ? $1 \n    LIMIT 5\n  \"\"\"\"\"\", [source_key, \"\"extracted_awards\"\", \"\"award_text\"\"])\n  \n  total_awards = 0\n  awards_with_year = 0\n  awards_with_category = 0\n  award_types = []\n  \n  Enum.each(sample_result.rows, fn [title, awards_json, award_text] ->\n    if awards_json do\n      # Awards are already parsed as Elixir data structures from JSONB\n      awards = if is_binary(awards_json), do: Jason.decode!(awards_json), else: awards_json\n      total_awards = total_awards + length(awards)\n      \n      Enum.each(awards, fn award ->\n        # Count structured fields\n        if award[\"\"award_year\"\"], do: awards_with_year = awards_with_year + 1\n        if award[\"\"award_category\"\"], do: awards_with_category = awards_with_category + 1\n        \n        # Track award types\n        award_name = award[\"\"award_name\"\"] || \"\"Unknown\"\"\n        award_types = [award_name | award_types]\n      end)\n      \n      IO.puts(\"\"#{title}:\"\")\n      IO.puts(\"\"  Award text: #{String.slice(award_text || \\\"\"\\\"\", 0, 60)}...\"\")\n      IO.puts(\"\"  Structured awards: #{length(awards)}\"\")\n      Enum.each(awards, fn award ->\n        year_info = if award[\"\"award_year\"\"], do: \"\" (#{award[\"\"award_year\"\"]})\"\", else: \"\"\"\"\n        category_info = if award[\"\"award_category\"\"], do: \"\" - #{award[\"\"award_category\"\"]}\"\", else: \"\"\"\"\n        IO.puts(\"\"    - #{award[\"\"award_name\"\"]}#{year_info}#{category_info}\"\")\n      end)\n      IO.puts(\"\"\"\")\n    end\n  end)\n  \n  IO.puts(\"\"Quality Metrics:\"\")\n  IO.puts(\"\"  Total sample awards: #{total_awards}\"\")\n  IO.puts(\"\"  Awards with year: #{awards_with_year} (#{if total_awards > 0, do: Float.round(awards_with_year/total_awards*100, 1), else: 0}%)\"\")\n  IO.puts(\"\"  Awards with category: #{awards_with_category} (#{if total_awards > 0, do: Float.round(awards_with_category/total_awards*100, 1), else: 0}%)\"\")\n  \n  IO.puts(\"\"\\nAward Types Found:\"\")\n  award_types\n  |> Enum.frequencies()\n  |> Enum.sort_by(fn {_, count} -> count end, :desc)\n  |> Enum.take(10)\n  |> Enum.each(fn {name, count} ->\n    IO.puts(\"\"  #{name}: #{count}\"\")\n  end)\nend)\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres mix run awards_quality_analysis.exs)",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT jsonb_pretty(data) FROM oscar_ceremonies WHERE year = 2024 LIMIT 1;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT id, name, imdb_id FROM people WHERE name LIKE ''%Oppenheimer%'' OR name LIKE ''%Maestro%'' OR name = ''Cillian Murphy'' OR name = ''Bradley Cooper'' LIMIT 10;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT on.id, on.person_id, on.won, on.details, p.name as person_name, m.title as movie_title FROM oscar_nominations on LEFT JOIN people p ON on.person_id = p.id LEFT JOIN movies m ON on.movie_id = m.id WHERE on.ceremony_id = (SELECT id FROM oscar_ceremonies WHERE year = 2024) LIMIT 10;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT nom.id, nom.person_id, nom.won, nom.details, p.name as person_name, m.title as movie_title FROM oscar_nominations nom LEFT JOIN people p ON nom.person_id = p.id LEFT JOIN movies m ON nom.movie_id = m.id WHERE nom.ceremony_id = (SELECT id FROM oscar_ceremonies WHERE year = 2024) LIMIT 10;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT jsonb_pretty(data -> ''categories'' -> 0 -> ''nominees'' -> 0) FROM oscar_ceremonies WHERE year = 2024;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT nom.id, nom.person_id, nom.won, nom.details, p.name as person_name, m.title as movie_title FROM oscar_nominations nom LEFT JOIN people p ON nom.person_id = p.id LEFT JOIN movies m ON nom.movie_id = m.id WHERE m.title = ''Oppenheimer'' AND nom.ceremony_id = (SELECT id FROM oscar_ceremonies WHERE year = 2024) LIMIT 5;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT name, tracks_person FROM oscar_categories WHERE name = ''Actor in a Leading Role'' OR name LIKE ''%Best Picture%'' OR name LIKE ''%Animated Feature%'';\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=3ba3f8f9 mix run -e '\n# Test the data flow by examining one ceremony\nceremony = Cinegraph.Cultural.list_oscar_ceremonies() |> Enum.find(&(&1.year == 2024))\n\nif ceremony do\n  # Get first category (Actor in a Leading Role)\n  first_category = ceremony.data[\"\"categories\"\"] |> List.first()\n  first_nominee = first_category[\"\"nominees\"\"] |> List.first()\n  \n  IO.puts(\"\"=== Debug Oscar Nomination Data Flow ===\"\")\n  IO.puts(\"\"Category: #{first_category[\"\"category\"\"]}\"\")\n  IO.puts(\"\"Raw nominee data:\"\")\n  IO.inspect(first_nominee, pretty: true)\n  IO.puts(\"\"\"\") \n  IO.puts(\"\"Key fields:\"\")\n  IO.puts(\"\"  nominee[\\\"\"name\\\"\"]: #{first_nominee[\"\"name\"\"]}\"\")\n  IO.puts(\"\"  nominee[\\\"\"film\\\"\"]: #{first_nominee[\"\"film\"\"]}\"\")  \n  IO.puts(\"\"  nominee[\\\"\"person_imdb_ids\\\"\"]: #{inspect(first_nominee[\"\"person_imdb_ids\"\"])}\"\")\nelse\n  IO.puts(\"\"No 2024 ceremony found\"\")\nend\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=3ba3f8f9 mix run -e '\n# Test what happens during nomination creation\nceremony = Cinegraph.Cultural.list_oscar_ceremonies() |> Enum.find(&(&1.year == 2024))\n\nif ceremony do\n  # Get the Oppenheimer movie\n  movie = Cinegraph.Movies.get_movie_by_imdb_id(\"\"tt15398776\"\")\n  \n  if movie do\n    IO.puts(\"\"Found movie: #{movie.title}\"\")\n    \n    # Get first category and nominee\n    first_category = ceremony.data[\"\"categories\"\"] |> List.first()\n    first_nominee = first_category[\"\"nominees\"\"] |> List.first()\n    category_name = first_category[\"\"category\"\"]\n    \n    IO.puts(\"\"Processing nominee: #{first_nominee[\"\"name\"\"]} for #{first_nominee[\"\"film\"\"]}\"\")\n    \n    # Check if the category exists and tracks person\n    category = Cinegraph.Repo.get_by(Cinegraph.Cultural.OscarCategory, name: category_name)\n    \n    if category do\n      IO.puts(\"\"Category found: #{category.name}, tracks_person: #{category.tracks_person}\"\")\n      \n      # Check what the nomination attrs would be\n      attrs = %{\n        ceremony_id: ceremony.id,\n        category_id: category.id,\n        movie_id: movie.id,\n        person_id: nil, # We will debug this separately\n        won: first_nominee[\"\"winner\"\"] || false,\n        details: %{\n          \"\"nominee_names\"\" => first_nominee[\"\"name\"\"],\n          \"\"person_imdb_ids\"\" => first_nominee[\"\"person_imdb_ids\"\"] || []\n        }\n      }\n      \n      IO.puts(\"\"Nomination attrs that would be created:\"\")\n      IO.inspect(attrs, pretty: true)\n    else\n      IO.puts(\"\"Category not found: #{category_name}\"\")\n    end\n  else\n    IO.puts(\"\"Movie not found for IMDb ID: tt15398776\"\")\n  end\nelse\n  IO.puts(\"\"No 2024 ceremony found\"\")\nend\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\\d oscar_nominations\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"DELETE FROM oscar_nominations WHERE id IN (SELECT id FROM oscar_nominations WHERE ceremony_id = (SELECT id FROM oscar_ceremonies WHERE year = 2024) LIMIT 3);\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=3ba3f8f9 mix run -e '\n# Test re-importing 2024 ceremony\nceremony = Cinegraph.Cultural.list_oscar_ceremonies() |> Enum.find(&(&1.year == 2024))\n\nif ceremony do\n  IO.puts(\"\"Re-importing 2024 ceremony...\"\")\n  result = Cinegraph.Cultural.OscarImporter.import_ceremony(ceremony)\n  IO.inspect(result, label: \"\"Import Result\"\")\n  \n  # Check what nominations were created\n  Process.sleep(2000)\n  \n  import Ecto.Query\n  new_nominations = Cinegraph.Repo.all(\n    from n in Cinegraph.Cultural.OscarNomination,\n    where: n.ceremony_id == ^ceremony.id,\n    limit: 5,\n    select: %{\n      id: n.id,\n      won: n.won,\n      details: n.details\n    }\n  )\n  \n  IO.puts(\"\"\\nFirst 5 nominations after re-import:\"\")\n  Enum.each(new_nominations, fn nom ->\n    nominee_names = nom.details[\"\"nominee_names\"\"]\n    person_imdb_ids = nom.details[\"\"person_imdb_ids\"\"]\n    IO.puts(\"\"  ID #{nom.id}: #{nominee_names} (IMDb: #{inspect(person_imdb_ids)})\"\")\n  end)\nelse\n  IO.puts(\"\"No 2024 ceremony found\"\")\nend\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT id, details FROM oscar_nominations WHERE ceremony_id = (SELECT id FROM oscar_ceremonies WHERE year = 2024) AND category_id = (SELECT id FROM oscar_categories WHERE name = ''Actor in a Leading Role'') AND movie_id = (SELECT id FROM movies WHERE imdb_id = ''tt5535276'');\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"DELETE FROM oscar_nominations WHERE ceremony_id = (SELECT id FROM oscar_ceremonies WHERE year = 2024);\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=3ba3f8f9 mix run -e '\n# Test re-importing 2024 ceremony with fixes\nceremony = Cinegraph.Cultural.list_oscar_ceremonies() |> Enum.find(&(&1.year == 2024))\n\nif ceremony do\n  IO.puts(\"\"Re-importing 2024 ceremony with bug fixes...\"\")\n  result = Cinegraph.Cultural.OscarImporter.import_ceremony(ceremony)\n  IO.inspect(result, label: \"\"Import Result\"\")\n  \n  # Check what nominations were created\n  Process.sleep(2000)\n  \n  import Ecto.Query\n  sample_nominations = Cinegraph.Repo.all(\n    from n in Cinegraph.Cultural.OscarNomination,\n    join: c in Cinegraph.Cultural.OscarCategory, on: n.category_id == c.id,\n    join: m in Cinegraph.Movies.Movie, on: n.movie_id == m.id,\n    left_join: p in Cinegraph.Movies.Person, on: n.person_id == p.id,\n    where: n.ceremony_id == ^ceremony.id and c.tracks_person == true,\n    limit: 5,\n    select: %{\n      id: n.id,\n      category: c.name,\n      movie_title: m.title,\n      person_name: p.name,\n      person_id: n.person_id,\n      nominee_names: fragment(\"\"? ->> ?\"\", n.details, \"\"nominee_names\"\"),\n      person_imdb_ids: fragment(\"\"? -> ?\"\", n.details, \"\"person_imdb_ids\"\")\n    }\n  )\n  \n  IO.puts(\"\"\\nFirst 5 person-based nominations:\"\")\n  Enum.each(sample_nominations, fn nom ->\n    person_status = if nom.person_id, do: \"\"âœ… LINKED\"\", else: \"\"âŒ NO LINK\"\"\n    IO.puts(\"\"  #{nom.category}: #{nom.nominee_names} (#{person_status})\"\")\n    IO.puts(\"\"    Movie: #{nom.movie_title}\"\")\n    if nom.person_name, do: IO.puts(\"\"    Person: #{nom.person_name}\"\")\n    IO.puts(\"\"    IMDb IDs: #{inspect(nom.person_imdb_ids)}\"\")\n    IO.puts(\"\"\"\")\n  end)\nelse\n  IO.puts(\"\"No 2024 ceremony found\"\")\nend\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=3ba3f8f9 mix run -e '\n# Test re-importing 2024 ceremony with simplified fix\nceremony = Cinegraph.Cultural.list_oscar_ceremonies() |> Enum.find(&(&1.year == 2024))\n\nif ceremony do\n  IO.puts(\"\"Re-importing 2024 ceremony...\"\")\n  result = Cinegraph.Cultural.OscarImporter.import_ceremony(ceremony)\n  IO.inspect(result, label: \"\"Import Result\"\")\n  \n  # Check what nominations were created\n  Process.sleep(1000)\n  \n  import Ecto.Query\n  sample_nominations = Cinegraph.Repo.all(\n    from n in Cinegraph.Cultural.OscarNomination,\n    join: c in Cinegraph.Cultural.OscarCategory, on: n.category_id == c.id,\n    join: m in Cinegraph.Movies.Movie, on: n.movie_id == m.id,\n    where: n.ceremony_id == ^ceremony.id and c.tracks_person == true,\n    limit: 5,\n    select: %{\n      category: c.name,\n      movie_title: m.title,\n      nominee_names: fragment(\"\"? ->> ?\"\", n.details, \"\"nominee_names\"\"),\n      person_imdb_ids: fragment(\"\"? -> ?\"\", n.details, \"\"person_imdb_ids\"\")\n    }\n  )\n  \n  IO.puts(\"\"\\nFirst 5 person-based nominations:\"\")\n  Enum.each(sample_nominations, fn nom ->\n    IO.puts(\"\"  #{nom.category}: #{nom.nominee_names}\"\")\n    IO.puts(\"\"    Movie: #{nom.movie_title}\"\")\n    IO.puts(\"\"    IMDb IDs: #{inspect(nom.person_imdb_ids)}\"\")\n    IO.puts(\"\"\"\")\n  end)\n  \n  # Check overall counts\n  total_noms = Cinegraph.Repo.one(\n    from n in Cinegraph.Cultural.OscarNomination,\n    where: n.ceremony_id == ^ceremony.id,\n    select: count(n.id)\n  )\n  \n  person_noms = Cinegraph.Repo.one(\n    from n in Cinegraph.Cultural.OscarNomination,\n    join: c in Cinegraph.Cultural.OscarCategory, on: n.category_id == c.id,\n    where: n.ceremony_id == ^ceremony.id and c.tracks_person == true,\n    select: count(n.id)\n  )\n  \n  IO.puts(\"\"ðŸ“Š Totals: #{total_noms} nominations, #{person_noms} person-based\"\")\nelse\n  IO.puts(\"\"No 2024 ceremony found\"\")\nend\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT nom.id, c.name as category, m.title as movie, nom.details ->> ''nominee_names'' as person_name, nom.details -> ''person_imdb_ids'' as imdb_ids FROM oscar_nominations nom JOIN oscar_categories c ON nom.category_id = c.id JOIN movies m ON nom.movie_id = m.id WHERE nom.ceremony_id = (SELECT id FROM oscar_ceremonies WHERE year = 2024) AND c.tracks_person = true ORDER BY c.name, m.title LIMIT 10;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\n-- Overall Oscar nomination statistics\nSELECT \n  ''Total Nominations'' as metric,\n  COUNT(*) as count\nFROM oscar_nominations\nWHERE ceremony_id = (SELECT id FROM oscar_ceremonies WHERE year = 2024)\n\nUNION ALL\n\nSELECT \n  ''Person-based Categories'' as metric,\n  COUNT(*) as count\nFROM oscar_nominations nom\nJOIN oscar_categories cat ON nom.category_id = cat.id\nWHERE nom.ceremony_id = (SELECT id FROM oscar_ceremonies WHERE year = 2024)\n  AND cat.tracks_person = true\n\nUNION ALL\n\nSELECT \n  ''Film-based Categories'' as metric,\n  COUNT(*) as count\nFROM oscar_nominations nom\nJOIN oscar_categories cat ON nom.category_id = cat.id\nWHERE nom.ceremony_id = (SELECT id FROM oscar_ceremonies WHERE year = 2024)\n  AND cat.tracks_person = false\n\nUNION ALL\n\nSELECT \n  ''With Person Names'' as metric,\n  COUNT(*) as count\nFROM oscar_nominations nom\nJOIN oscar_categories cat ON nom.category_id = cat.id\nWHERE nom.ceremony_id = (SELECT id FROM oscar_ceremonies WHERE year = 2024)\n  AND cat.tracks_person = true\n  AND nom.details ->> ''nominee_names'' IS NOT NULL\n  AND nom.details ->> ''nominee_names'' != ''''\n\nUNION ALL\n\nSELECT \n  ''With IMDb IDs'' as metric,\n  COUNT(*) as count\nFROM oscar_nominations nom\nJOIN oscar_categories cat ON nom.category_id = cat.id\nWHERE nom.ceremony_id = (SELECT id FROM oscar_ceremonies WHERE year = 2024)\n  AND cat.tracks_person = true\n  AND jsonb_array_length(nom.details -> ''person_imdb_ids'') > 0;\n\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT ''Total 2024 Nominations'' as metric, COUNT(*) as count FROM oscar_nominations WHERE ceremony_id = (SELECT id FROM oscar_ceremonies WHERE year = 2024);\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT id, year FROM oscar_ceremonies ORDER BY year DESC LIMIT 5;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT COUNT(*) as total_nominations FROM oscar_nominations WHERE ceremony_id = 21;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT ceremony_id, COUNT(*) as count FROM oscar_nominations GROUP BY ceremony_id ORDER BY ceremony_id DESC;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\nSELECT \n  nom.id,\n  cer.year,\n  cat.name as category,\n  mov.title as movie,\n  nom.details ->> ''nominee_names'' as nominee_names,\n  nom.details -> ''person_imdb_ids'' as person_imdb_ids,\n  cat.tracks_person\nFROM oscar_nominations nom\nJOIN oscar_ceremonies cer ON nom.ceremony_id = cer.id\nJOIN oscar_categories cat ON nom.category_id = cat.id\nJOIN movies mov ON nom.movie_id = mov.id\nWHERE cat.tracks_person = true\nORDER BY nom.id DESC\nLIMIT 10;\n\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\nSELECT \n  nom.id,\n  cer.year,\n  cat.name as category,\n  mov.title as movie,\n  nom.details ->> ''nominee_names'' as nominee_names,\n  nom.details -> ''person_imdb_ids'' as person_imdb_ids\nFROM oscar_nominations nom\nJOIN oscar_ceremonies cer ON nom.ceremony_id = cer.id\nJOIN oscar_categories cat ON nom.category_id = cat.id\nJOIN movies mov ON nom.movie_id = mov.id\nWHERE cat.name LIKE ''Actor%'' OR cat.name LIKE ''Actress%''\nORDER BY nom.id DESC\nLIMIT 10;\n\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT name, tracks_person, COUNT(nom.id) as nomination_count FROM oscar_categories cat LEFT JOIN oscar_nominations nom ON cat.id = nom.category_id GROUP BY cat.id, cat.name, cat.tracks_person ORDER BY nomination_count DESC, cat.name;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=3ba3f8f9 mix run -e '\n# Test importing 2024 ceremony to see if acting nominations get created\nceremony = Cinegraph.Cultural.list_oscar_ceremonies() |> Enum.find(&(&1.year == 2024))\n\nif ceremony do\n  IO.puts(\"\"=== Testing 2024 Oscar Import ===\"\")\n  \n  # Check if we have the right ceremony ID\n  IO.puts(\"\"Ceremony: #{ceremony.year} (ID: #{ceremony.id})\"\")\n  \n  try do\n    result = Cinegraph.Cultural.OscarImporter.import_ceremony(ceremony)\n    IO.inspect(result, label: \"\"Import Result\"\")\n    \n    # Check what was created\n    Process.sleep(2000)\n    \n    import Ecto.Query\n    new_nominations = Cinegraph.Repo.all(\n      from n in Cinegraph.Cultural.OscarNomination,\n      join: c in Cinegraph.Cultural.OscarCategory, on: n.category_id == c.id,\n      where: n.ceremony_id == ^ceremony.id,\n      limit: 10,\n      select: %{\n        category: c.name,\n        tracks_person: c.tracks_person,\n        nominee_names: fragment(\"\"? ->> ?\"\", n.details, \"\"nominee_names\"\")\n      }\n    )\n    \n    IO.puts(\"\"\\nNominations created:\"\")\n    Enum.each(new_nominations, fn nom ->\n      person_indicator = if nom.tracks_person, do: \"\"[PERSON]\"\", else: \"\"[FILM]\"\"\n      IO.puts(\"\"  #{person_indicator} #{nom.category}: #{nom.nominee_names}\"\")\n    end)\n    \n  rescue\n    e -> IO.puts(\"\"Error during import: #{inspect(e)}\"\")\n  end\nelse\n  IO.puts(\"\"No 2024 ceremony found\"\")\nend\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\n-- Comprehensive Oscar Nomination Audit\nSELECT \n  ''Total 2024 Nominations'' as metric,\n  COUNT(*) as count\nFROM oscar_nominations \nWHERE ceremony_id = 21\n\nUNION ALL\n\nSELECT \n  ''Person-Based Categories'' as metric,\n  COUNT(*) as count\nFROM oscar_nominations nom\nJOIN oscar_categories cat ON nom.category_id = cat.id\nWHERE nom.ceremony_id = 21 AND cat.tracks_person = true\n\nUNION ALL\n\nSELECT \n  ''Film-Based Categories'' as metric,\n  COUNT(*) as count\nFROM oscar_nominations nom\nJOIN oscar_categories cat ON nom.category_id = cat.id\nWHERE nom.ceremony_id = 21 AND cat.tracks_person = false\n\nUNION ALL\n\nSELECT \n  ''Person Names Present'' as metric,\n  COUNT(*) as count\nFROM oscar_nominations nom\nJOIN oscar_categories cat ON nom.category_id = cat.id\nWHERE nom.ceremony_id = 21 \n  AND cat.tracks_person = true\n  AND nom.details ->> ''nominee_names'' IS NOT NULL\n  AND nom.details ->> ''nominee_names'' != ''''\n\nUNION ALL\n\nSELECT \n  ''Person IMDb IDs Present'' as metric,\n  COUNT(*) as count\nFROM oscar_nominations nom\nJOIN oscar_categories cat ON nom.category_id = cat.id\nWHERE nom.ceremony_id = 21\n  AND cat.tracks_person = true\n  AND jsonb_array_length(nom.details -> ''person_imdb_ids'') > 0;\n\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\n-- 2024 Oscar Nominations Comprehensive Audit\nSELECT \n    ''Total nominations'' as metric, \n    COUNT(*)::text as value \nFROM oscar_nominations nom \nWHERE nom.ceremony_id = (SELECT id FROM oscar_ceremonies WHERE year = 2024)\n\nUNION ALL\n\nSELECT \n    ''Person-based categories'' as metric,\n    COUNT(*)::text as value\nFROM oscar_nominations nom\nJOIN oscar_categories cat ON nom.category_id = cat.id\nWHERE nom.ceremony_id = (SELECT id FROM oscar_ceremonies WHERE year = 2024)\nAND cat.tracks_person = true\n\nUNION ALL\n\nSELECT \n    ''Film-based categories'' as metric,\n    COUNT(*)::text as value  \nFROM oscar_nominations nom\nJOIN oscar_categories cat ON nom.category_id = cat.id\nWHERE nom.ceremony_id = (SELECT id FROM oscar_ceremonies WHERE year = 2024)\nAND cat.tracks_person = false\n\nUNION ALL\n\nSELECT \n    ''Person nominations with person names'' as metric,\n    COUNT(*)::text as value\nFROM oscar_nominations nom\nJOIN oscar_categories cat ON nom.category_id = cat.id\nWHERE nom.ceremony_id = (SELECT id FROM oscar_ceremonies WHERE year = 2024)\nAND cat.tracks_person = true\nAND nom.details ->> ''nominee_names'' IS NOT NULL\nAND nom.details ->> ''nominee_names'' <> ''''\n\nUNION ALL\n\nSELECT \n    ''Person nominations with IMDb IDs'' as metric,\n    COUNT(*)::text as value\nFROM oscar_nominations nom\nJOIN oscar_categories cat ON nom.category_id = cat.id\nWHERE nom.ceremony_id = (SELECT id FROM oscar_ceremonies WHERE year = 2024)\nAND cat.tracks_person = true\nAND nom.details -> ''person_imdb_ids'' IS NOT NULL\n\nORDER BY metric;\n\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\n-- Sample person-based nominations to verify fix quality\nSELECT \n    cat.name as category,\n    m.title as movie,\n    nom.details ->> ''nominee_names'' as person_name,\n    nom.details -> ''person_imdb_ids'' as imdb_ids,\n    nom.won\nFROM oscar_nominations nom\nJOIN oscar_categories cat ON nom.category_id = cat.id  \nJOIN movies m ON nom.movie_id = m.id\nWHERE nom.ceremony_id = (SELECT id FROM oscar_ceremonies WHERE year = 2024)\nAND cat.tracks_person = true\nORDER BY cat.name, m.title\nLIMIT 10;\n\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\n-- Sample film-based nominations  \nSELECT \n    cat.name as category,\n    m.title as movie,\n    nom.details ->> ''nominee_names'' as stored_name,\n    nom.won\nFROM oscar_nominations nom\nJOIN oscar_categories cat ON nom.category_id = cat.id\nJOIN movies m ON nom.movie_id = m.id  \nWHERE nom.ceremony_id = (SELECT id FROM oscar_ceremonies WHERE year = 2024)\nAND cat.tracks_person = false\nORDER BY cat.name, m.title\nLIMIT 8;\n\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\n-- Final audit: Verify person names vs movie titles in person-based categories\nSELECT \n    CASE \n        WHEN nom.details ->> ''nominee_names'' = m.title THEN ''ERROR: Movie title stored''\n        WHEN nom.details ->> ''nominee_names'' != m.title THEN ''CORRECT: Person name stored''\n        ELSE ''UNKNOWN''\n    END as validation_result,\n    COUNT(*) as count\nFROM oscar_nominations nom\nJOIN oscar_categories cat ON nom.category_id = cat.id\nJOIN movies m ON nom.movie_id = m.id\nWHERE nom.ceremony_id = (SELECT id FROM oscar_ceremonies WHERE year = 2024)\nAND cat.tracks_person = true\nGROUP BY validation_result\nORDER BY validation_result;\n\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\n-- Final audit: Verify person names vs movie titles in person-based categories  \nSELECT \n    CASE \n        WHEN nom.details ->> ''nominee_names'' = m.title THEN ''ERROR: Movie title stored''\n        WHEN nom.details ->> ''nominee_names'' <> m.title THEN ''CORRECT: Person name stored''\n        ELSE ''UNKNOWN''\n    END as validation_result,\n    COUNT(*) as count\nFROM oscar_nominations nom\nJOIN oscar_categories cat ON nom.category_id = cat.id\nJOIN movies m ON nom.movie_id = m.id\nWHERE nom.ceremony_id = (SELECT id FROM oscar_ceremonies WHERE year = 2024)\nAND cat.tracks_person = true\nGROUP BY validation_result\nORDER BY validation_result;\n\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\n-- Fresh Oscar Nominations Audit\nSELECT \n    ''Total nominations'' as metric, \n    COUNT(*)::text as value \nFROM oscar_nominations nom \nWHERE nom.ceremony_id = (SELECT id FROM oscar_ceremonies WHERE year = 2024)\n\nUNION ALL\n\nSELECT \n    ''People nominations (actors/directors/etc)'' as metric,\n    COUNT(*)::text as value\nFROM oscar_nominations nom\nJOIN oscar_categories cat ON nom.category_id = cat.id\nWHERE nom.ceremony_id = (SELECT id FROM oscar_ceremonies WHERE year = 2024)\nAND cat.tracks_person = true\n\nUNION ALL\n\nSELECT \n    ''People nominations with correct names'' as metric,\n    COUNT(*)::text as value\nFROM oscar_nominations nom\nJOIN oscar_categories cat ON nom.category_id = cat.id\nWHERE nom.ceremony_id = (SELECT id FROM oscar_ceremonies WHERE year = 2024)\nAND cat.tracks_person = true\nAND nom.details ->> ''nominee_names'' IS NOT NULL\nAND nom.details ->> ''nominee_names'' <> ''''\n\nUNION ALL\n\nSELECT \n    ''People nominations storing movie titles (ERROR)'' as metric,\n    COUNT(*)::text as value\nFROM oscar_nominations nom\nJOIN oscar_categories cat ON nom.category_id = cat.id\nJOIN movies m ON nom.movie_id = m.id\nWHERE nom.ceremony_id = (SELECT id FROM oscar_ceremonies WHERE year = 2024)\nAND cat.tracks_person = true\nAND nom.details ->> ''nominee_names'' = m.title\n\nORDER BY metric;\n\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\n-- Check category breakdown for 2024\nSELECT \n    cat.name as category,\n    cat.tracks_person,\n    COUNT(nom.id) as nominations\nFROM oscar_categories cat\nLEFT JOIN oscar_nominations nom ON cat.id = nom.category_id \n    AND nom.ceremony_id = (SELECT id FROM oscar_ceremonies WHERE year = 2024)\nWHERE cat.tracks_person = true\nGROUP BY cat.id, cat.name, cat.tracks_person\nORDER BY cat.name;\n\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\n-- Sample the people nominations we do have\nSELECT \n    cat.name as category,\n    m.title as movie,\n    nom.details ->> ''nominee_names'' as person_names,\n    nom.won\nFROM oscar_nominations nom\nJOIN oscar_categories cat ON nom.category_id = cat.id\nJOIN movies m ON nom.movie_id = m.id\nWHERE nom.ceremony_id = (SELECT id FROM oscar_ceremonies WHERE year = 2024)\nAND cat.tracks_person = true\nORDER BY cat.name, m.title\nLIMIT 15;\n\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\n-- Test the query logic for People Nominations display\nSELECT \n    ''Total People Nominations'' as metric,\n    COUNT(*)::text as value\nFROM oscar_nominations on_table\nJOIN oscar_categories cat ON on_table.category_id = cat.id\nWHERE cat.tracks_person = true\n\nUNION ALL\n\nSELECT \n    ''People Nominations with Names'' as metric,\n    COUNT(*)::text as value\nFROM oscar_nominations on_table\nJOIN oscar_categories cat ON on_table.category_id = cat.id\nWHERE cat.tracks_person = true \n  AND on_table.details ->> ''nominee_names'' IS NOT NULL \n  AND on_table.details ->> ''nominee_names'' != ''''\n\nUNION ALL\n\nSELECT \n    ''Display Value'' as metric,\n    CASE \n        WHEN (SELECT COUNT(*) FROM oscar_nominations on1 JOIN oscar_categories cat1 ON on1.category_id = cat1.id WHERE cat1.tracks_person = true) = \n             (SELECT COUNT(*) FROM oscar_nominations on2 JOIN oscar_categories cat2 ON on2.category_id = cat2.id WHERE cat2.tracks_person = true AND on2.details ->> ''nominee_names'' IS NOT NULL AND on2.details ->> ''nominee_names'' != '''')\n        THEN (SELECT COUNT(*)::text || '' âœ…'' FROM oscar_nominations on3 JOIN oscar_categories cat3 ON on3.category_id = cat3.id WHERE cat3.tracks_person = true)\n        ELSE (SELECT COUNT(*)::text FROM oscar_nominations on4 JOIN oscar_categories cat4 ON on4.category_id = cat4.id WHERE cat4.tracks_person = true AND on4.details ->> ''nominee_names'' IS NOT NULL AND on4.details ->> ''nominee_names'' != '''') || ''/'' || \n             (SELECT COUNT(*)::text FROM oscar_nominations on5 JOIN oscar_categories cat5 ON on5.category_id = cat5.id WHERE cat5.tracks_person = true) || '' âš ï¸''\n    END\n\nORDER BY metric;\n\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\n-- Test the query logic for People Nominations display\nSELECT \n    ''Total People Nominations'' as metric,\n    COUNT(*)::text as value\nFROM oscar_nominations on_table\nJOIN oscar_categories cat ON on_table.category_id = cat.id\nWHERE cat.tracks_person = true\n\nUNION ALL\n\nSELECT \n    ''People Nominations with Names'' as metric,\n    COUNT(*)::text as value\nFROM oscar_nominations on_table\nJOIN oscar_categories cat ON on_table.category_id = cat.id\nWHERE cat.tracks_person = true \n  AND on_table.details ->> ''nominee_names'' IS NOT NULL \n  AND on_table.details ->> ''nominee_names'' <> ''''\n\nORDER BY metric DESC;\n\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\n-- Comprehensive audit of current awards data state\nSELECT ''Oscar data in structured tables'' as category, COUNT(DISTINCT nom.id) as count\nFROM oscar_nominations nom\n\nUNION ALL\n\nSELECT ''Oscar data in movies.awards JSONB'' as category, COUNT(*) as count\nFROM movies \nWHERE awards IS NOT NULL \nAND awards ? ''oscar_nominations''\n\nUNION ALL\n\nSELECT ''Cannes data in canonical_sources'' as category, COUNT(*) as count\nFROM movies \nWHERE canonical_sources ? ''cannes_winners''\n\nUNION ALL\n\nSELECT ''Venice data in canonical_sources'' as category, COUNT(*) as count\nFROM movies \nWHERE canonical_sources ? ''venice_golden_lion''\n\nUNION ALL\n\nSELECT ''Berlin data in canonical_sources'' as category, COUNT(*) as count\nFROM movies \nWHERE canonical_sources ? ''berlin_golden_bear''\n\nUNION ALL\n\nSELECT ''Cannes with extracted_awards'' as category, COUNT(*) as count\nFROM movies \nWHERE canonical_sources -> ''cannes_winners'' -> ''extracted_awards'' IS NOT NULL\n\nUNION ALL\n\nSELECT ''Venice with extracted_awards'' as category, COUNT(*) as count\nFROM movies \nWHERE canonical_sources -> ''venice_golden_lion'' -> ''extracted_awards'' IS NOT NULL\n\nUNION ALL\n\nSELECT ''Berlin with extracted_awards'' as category, COUNT(*) as count\nFROM movies \nWHERE canonical_sources -> ''berlin_golden_bear'' -> ''extracted_awards'' IS NOT NULL\n\nORDER BY category;\n\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\n-- Check Oscar ceremonies and nominations\nSELECT \n    oc.year,\n    COUNT(DISTINCT on_table.id) as nominations,\n    COUNT(DISTINCT CASE WHEN on_table.won = true THEN on_table.id END) as wins\nFROM oscar_ceremonies oc\nLEFT JOIN oscar_nominations on_table ON on_table.ceremony_id = oc.id\nGROUP BY oc.year\nORDER BY oc.year DESC\nLIMIT 10;\n\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\n-- Audit Oscar data quality and person tracking\nSELECT \n    ''Total Oscar Categories'' as metric,\n    COUNT(*)::text as value\nFROM oscar_categories\n\nUNION ALL\n\nSELECT \n    ''Categories tracking people'' as metric,\n    COUNT(*)::text as value\nFROM oscar_categories\nWHERE tracks_person = true\n\nUNION ALL\n\nSELECT \n    ''Total Oscar nominations'' as metric,\n    COUNT(*)::text as value\nFROM oscar_nominations\n\nUNION ALL\n\nSELECT \n    ''Nominations with person_id linked'' as metric,\n    COUNT(*)::text as value\nFROM oscar_nominations\nWHERE person_id IS NOT NULL\n\nUNION ALL\n\nSELECT \n    ''People nominations with names in details'' as metric,\n    COUNT(*)::text as value\nFROM oscar_nominations nom\nJOIN oscar_categories cat ON nom.category_id = cat.id\nWHERE cat.tracks_person = true\nAND nom.details ->> ''nominee_names'' IS NOT NULL\n\nUNION ALL\n\nSELECT \n    ''People nominations with IMDb IDs'' as metric,\n    COUNT(*)::text as value\nFROM oscar_nominations nom\nJOIN oscar_categories cat ON nom.category_id = cat.id\nWHERE cat.tracks_person = true\nAND nom.details -> ''person_imdb_ids'' IS NOT NULL\n\nORDER BY metric;\n\")",
      "Bash(MIX_ENV=dev mix ecto.migrations)",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\n-- Check 2024 Oscar import results\nSELECT \n  ''Total Nominations'' as metric,\n  COUNT(*) as count\nFROM oscar_nominations\nWHERE ceremony_id = (SELECT id FROM oscar_ceremonies WHERE year = 2024)\n\nUNION ALL\n\nSELECT \n  ''Fuzzy Matched Movies'' as metric,\n  COUNT(DISTINCT movie_id) as count\nFROM oscar_nominations\nWHERE ceremony_id = (SELECT id FROM oscar_ceremonies WHERE year = 2024)\n\nUNION ALL\n\nSELECT \n  ''Categories with Nominations'' as metric,\n  COUNT(DISTINCT category_id) as count  \nFROM oscar_nominations\nWHERE ceremony_id = (SELECT id FROM oscar_ceremonies WHERE year = 2024)\n\nORDER BY metric;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\n-- Check which categories have nominations\nSELECT \n  c.name as category,\n  COUNT(n.id) as nominations\nFROM oscar_categories c\nLEFT JOIN oscar_nominations n ON n.category_id = c.id \n  AND n.ceremony_id = (SELECT id FROM oscar_ceremonies WHERE year = 2024)\nWHERE c.id IN (\n  SELECT DISTINCT category_id \n  FROM oscar_nominations \n  WHERE ceremony_id = (SELECT id FROM oscar_ceremonies WHERE year = 2024)\n)\nGROUP BY c.id, c.name\nORDER BY c.name;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\n-- Final audit of 2024 Oscar nominations\nSELECT \n  ''Total 2024 Nominations'' as metric,\n  COUNT(*) as value\nFROM oscar_nominations \nWHERE ceremony_id = (SELECT id FROM oscar_ceremonies WHERE year = 2024)\n\nUNION ALL\n\nSELECT \n  ''Person-based Nominations'' as metric,\n  COUNT(*) as value\nFROM oscar_nominations n\nJOIN oscar_categories c ON n.category_id = c.id\nWHERE n.ceremony_id = (SELECT id FROM oscar_ceremonies WHERE year = 2024)\n  AND c.tracks_person = true\n\nUNION ALL\n\nSELECT \n  ''Film-based Nominations'' as metric,\n  COUNT(*) as value\nFROM oscar_nominations n\nJOIN oscar_categories c ON n.category_id = c.id\nWHERE n.ceremony_id = (SELECT id FROM oscar_ceremonies WHERE year = 2024)\n  AND c.tracks_person = false\n\nUNION ALL\n\nSELECT \n  ''Unique Movies'' as metric,\n  COUNT(DISTINCT movie_id) as value\nFROM oscar_nominations\nWHERE ceremony_id = (SELECT id FROM oscar_ceremonies WHERE year = 2024)\n\nUNION ALL\n\nSELECT \n  ''Categories with Data'' as metric,\n  COUNT(DISTINCT category_id) as value\nFROM oscar_nominations\nWHERE ceremony_id = (SELECT id FROM oscar_ceremonies WHERE year = 2024)\n\nORDER BY metric;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres mix run -e 'IO.inspect(Cinegraph.Festivals.get_or_create_oscar_organization(), label: \"\"Oscar Org Result\"\")')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres mix run -e 'org = Cinegraph.Festivals.get_or_create_oscar_organization(); IO.puts(\"\"Created: #{org.name} (ID: #{org.id})\"\")')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT * FROM festival_organizations WHERE abbreviation = ''AMPAS'';\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres mix run -e 'IO.puts(\"\"Testing Oscar ceremonies: #{length(Cinegraph.Cultural.list_oscar_ceremonies())}\"\")')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres mix test --include slow)",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres mix run -e 'IO.puts(\"\"âœ… Dashboard Oscar stats test\"\"); org = Cinegraph.Festivals.get_or_create_oscar_organization(); IO.puts(\"\"Oscar org: #{org.name} (#{org.id})\"\")')",
      "Bash(gt continue:*)",
      "Bash(gt stack:*)",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\\dt\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\\d festival_organizations\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\\d festival_ceremonies\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT * FROM festival_organizations;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\nSELECT \n  ''Festival Ceremonies'' as table_name,\n  COUNT(*) as total_records,\n  COUNT(name) as name_filled,\n  COUNT(date) as date_filled, \n  COUNT(location) as location_filled,\n  COUNT(data_source) as data_source_filled,\n  COUNT(source_url) as source_url_filled,\n  COUNT(scraped_at) as scraped_at_filled\nFROM festival_ceremonies\n\nUNION ALL\n\nSELECT \n  ''Festival Organizations'' as table_name,\n  COUNT(*) as total_records,\n  COUNT(name) as name_filled,\n  COUNT(founded_year) as founded_year_filled,\n  COUNT(website) as website_filled,\n  COUNT(description) as description_filled,\n  COUNT(country) as country_filled,\n  COUNT(logo_url) as logo_url_filled\nFROM festival_organizations\n\nUNION ALL\n\nSELECT \n  ''Festival Categories'' as table_name,\n  COUNT(*) as total_records,\n  COUNT(name) as name_filled,\n  COUNT(category_type) as category_type_filled,\n  COUNT(description) as description_filled,\n  COALESCE(SUM(CASE WHEN tracks_person = true THEN 1 ELSE 0 END), 0) as tracks_person_true,\n  COALESCE(SUM(CASE WHEN tracks_person = false THEN 1 ELSE 0 END), 0) as tracks_person_false,\n  NULL as unused\nFROM festival_categories\n\nORDER BY table_name;\n\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\nSELECT \n  ''Festival Ceremonies'' as table_name,\n  COUNT(*) as total_records,\n  COUNT(name) as name_filled,\n  COUNT(date) as date_filled, \n  COUNT(location) as location_filled,\n  COUNT(data_source) as data_source_filled,\n  COUNT(source_url) as source_url_filled,\n  COUNT(scraped_at) as scraped_at_filled\nFROM festival_ceremonies\n\nUNION ALL\n\nSELECT \n  ''Festival Organizations'' as table_name,\n  COUNT(*) as total_records,\n  COUNT(name) as name_filled,\n  COUNT(founded_year) as founded_year_filled,\n  COUNT(website) as website_filled,\n  COUNT(country) as country_filled,\n  COUNT(logo_url) as logo_url_filled,\n  NULL as unused\nFROM festival_organizations\n\nUNION ALL\n\nSELECT \n  ''Festival Categories'' as table_name,\n  COUNT(*) as total_records,\n  COUNT(name) as name_filled,\n  COUNT(category_type) as category_type_filled,\n  COALESCE(SUM(CASE WHEN tracks_person = true THEN 1 ELSE 0 END), 0) as tracks_person_true,\n  COALESCE(SUM(CASE WHEN tracks_person = false THEN 1 ELSE 0 END), 0) as tracks_person_false,\n  NULL as unused1,\n  NULL as unused2\nFROM festival_categories\n\nORDER BY table_name;\n\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\\d festival_ceremonies\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\\d festival_organizations\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\\d festival_categories\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\\d festival_nominations\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\n-- Festival Ceremonies Field Usage Audit\nSELECT \n  ''Festival Ceremonies'' as table_name,\n  COUNT(*) as total_records,\n  COUNT(name) as name_filled,\n  COUNT(date) as date_filled, \n  COUNT(location) as location_filled,\n  COUNT(data_source) as data_source_filled,\n  COUNT(source_url) as source_url_filled,\n  COUNT(scraped_at) as scraped_at_filled\nFROM festival_ceremonies\n\nUNION ALL\n\n-- Festival Organizations Field Usage Audit  \nSELECT \n  ''Festival Organizations'' as table_name,\n  COUNT(*) as total_records,\n  COUNT(name) as name_filled,\n  COUNT(abbreviation) as abbreviation_filled,\n  COUNT(country) as country_filled,\n  COUNT(founded_year) as founded_year_filled,\n  COUNT(website) as website_filled,\n  NULL as unused\nFROM festival_organizations\n\nUNION ALL\n\n-- Festival Categories Field Usage Audit\nSELECT \n  ''Festival Categories'' as table_name,\n  COUNT(*) as total_records,\n  COUNT(name) as name_filled,\n  COUNT(category_type) as category_type_filled,\n  COALESCE(SUM(CASE WHEN tracks_person = true THEN 1 ELSE 0 END), 0) as tracks_person_true,\n  COALESCE(SUM(CASE WHEN tracks_person = false THEN 1 ELSE 0 END), 0) as tracks_person_false,\n  NULL as unused1,\n  NULL as unused2\nFROM festival_categories\n\nORDER BY table_name;\n\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\n-- Nominations Field Usage Audit\nSELECT \n  ''Festival Nominations'' as table_name,\n  COUNT(*) as total_records,\n  COUNT(movie_id) as movie_id_filled,\n  COUNT(person_id) as person_id_filled,\n  COUNT(prize_name) as prize_name_filled,\n  COALESCE(SUM(CASE WHEN won = true THEN 1 ELSE 0 END), 0) as won_true,\n  COALESCE(SUM(CASE WHEN won = false THEN 1 ELSE 0 END), 0) as won_false,\n  NULL as unused\nFROM festival_nominations;\n\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\n-- Sample data analysis\nSELECT ''Ceremony Sample'' as analysis_type,\n       year, name, date, location, ceremony_number, data_source\nFROM festival_ceremonies \nLIMIT 3\n\nUNION ALL\n\nSELECT ''Organization Sample'' as analysis_type,\n       name::text, abbreviation, country, founded_year::text, website, NULL\nFROM festival_organizations\nLIMIT 1;\n\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\n-- Ceremony Sample Data\nSELECT year, name, date, location, ceremony_number, data_source\nFROM festival_ceremonies \nORDER BY year \nLIMIT 5;\n\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\n-- Organization Sample Data\nSELECT name, abbreviation, country, founded_year, website\nFROM festival_organizations;\n\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\n-- Check if ceremony names exist in the data JSONB field\nSELECT year, data -> ''title'' as ceremony_title, data -> ''location'' as ceremony_location, data -> ''date'' as ceremony_date\nFROM festival_ceremonies \nORDER BY year \nLIMIT 3;\n\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=3ba3f8f9 ZYTE_API_KEY=9e754bb61e684aad88a98eceada363ba mix run -e '\n# Test Venice import functionality available through the UI\nIO.puts(\"\"=== Testing Festival Awards Import UI Integration ===\"\")\n\n# 1. Check if Venice functions are available (what UI would call)\nIO.puts(\"\"\\n1. Testing Cultural Venice functions...\"\")\nvenice_functions = [\n  {\"\"import_venice_year/2\"\", &Cinegraph.Cultural.import_venice_year/2},\n  {\"\"get_venice_import_status/0\"\", &Cinegraph.Cultural.get_venice_import_status/0},\n  {\"\"list_venice_ceremonies/0\"\", &Cinegraph.Cultural.list_venice_ceremonies/0}\n]\n\nEnum.each(venice_functions, fn {name, _func} ->\n  IO.puts(\"\"  âœ… #{name} - Available\"\")\nend)\n\n# 2. Check Venice organization exists (created by UI)\nvenice_org = Cinegraph.Festivals.get_organization_by_abbreviation(\"\"VIFF\"\")\nif venice_org do\n  IO.puts(\"\"\\n2. âœ… Venice Organization Found:\"\")\n  IO.puts(\"\"   Name: #{venice_org.name}\"\")\n  IO.puts(\"\"   Abbreviation: #{venice_org.abbreviation}\"\")\n  IO.puts(\"\"   Country: #{venice_org.country}\"\")\nelse\n  IO.puts(\"\"\\n2. â„¹ï¸ Venice Organization not yet created (will be created on first import)\"\")\nend\n\n# 3. Test the UI integration path (simulate what happens when user clicks Import)\nIO.puts(\"\"\\n3. Testing UI Integration Path...\"\")\nIO.puts(\"\"   User selects: Venice International Film Festival\"\")\nIO.puts(\"\"   User enters year: 2025\"\")\nIO.puts(\"\"   User clicks: Import Festival\"\")\n\n# 4. Check Venice import status (what UI shows)\nstatus = Cinegraph.Cultural.get_venice_import_status()\nIO.puts(\"\"\\n4. âœ… Venice Import Status (UI display):\"\")\nIO.puts(\"\"   Running jobs: #{status.running_jobs}\"\")\nIO.puts(\"\"   Queued jobs: #{status.queued_jobs}\"\")\nIO.puts(\"\"   Completed jobs: #{status.completed_jobs}\"\")\nIO.puts(\"\"   Failed jobs: #{status.failed_jobs}\"\")\n\n# 5. Check database stats (what UI shows in Database Statistics)\nvenice_count = try do\n  venice_org = Cinegraph.Festivals.get_organization_by_abbreviation(\"\"VIFF\"\")\n  if venice_org && venice_org.id do\n    import Ecto.Query\n    Cinegraph.Repo.one(\n      from n in Cinegraph.Festivals.FestivalNomination,\n      join: c in Cinegraph.Festivals.FestivalCeremony, on: n.ceremony_id == c.id,\n      where: c.organization_id == ^venice_org.id,\n      select: count(n.movie_id, :distinct)\n    ) || 0\n  else\n    0\n  end\ncatch\n  _ -> 0\nend\n\nIO.puts(\"\"\\n5. âœ… Database Statistics (UI Venice Movies count): #{venice_count}\"\")\n\nIO.puts(\"\"\\nðŸŽ‰ Festival Awards Import UI Integration Complete!\"\")\nIO.puts(\"\"   âœ… All Venice functions accessible\"\")\nIO.puts(\"\"   âœ… Festival import form ready\"\") \nIO.puts(\"\"   âœ… Progress tracking implemented\"\")\nIO.puts(\"\"   âœ… Statistics display configured\"\")\nIO.puts(\"\"   âœ… Database integration working\"\")\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres ZYTE_API_KEY=9e754bb61e684aad88a98eceada363ba mix run -e '\n# Check Venice scraper capabilities and see what years are available\nIO.puts(\"\"=== Venice Film Festival Scraper Analysis ===\"\")\n\n# 1. Check if we can get available years\nIO.puts(\"\"\\n1. Testing get_available_years function...\"\")\ncase Cinegraph.Scrapers.VeniceFilmFestivalScraper.get_available_years() do\n  {:ok, years} ->\n    IO.puts(\"\"âœ… Available years: #{inspect(Enum.sort(years))}\"\")\n    IO.puts(\"\"   Years count: #{length(years)}\"\")\n    IO.puts(\"\"   Range: #{Enum.min(years)}-#{Enum.max(years)}\"\")\n  {:error, reason} ->\n    IO.puts(\"\"âŒ Error getting years: #{inspect(reason)}\"\")\nend\n\n# 2. Check current Venice worker jobs\nimport Ecto.Query\njobs = Cinegraph.Repo.all(\n  from j in Oban.Job,\n  where: j.worker == \"\"Cinegraph.Workers.VeniceFestivalWorker\"\",\n  order_by: [desc: j.inserted_at],\n  limit: 5,\n  select: %{id: j.id, state: j.state, args: j.args, errors: j.errors}\n)\n\nIO.puts(\"\"\\n2. Current Venice Worker Jobs:\"\")\nEnum.each(jobs, fn job ->\n  IO.puts(\"\"   Job #{job.id}: #{job.state} - #{inspect(job.args)}\"\")\n  if job.errors && length(job.errors) > 0 do\n    IO.puts(\"\"     Errors: #{inspect(job.errors)}\"\")\n  end\nend)\n\n# 3. Test what happens when we try a Venice import\nIO.puts(\"\"\\n3. Testing Venice import process...\"\")\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres ZYTE_API_KEY=9e754bb61e684aad88a98eceada363ba mix run -e '\n# Test the updated Festival Awards Import UI functionality\nIO.puts(\"\"=== Testing Updated Festival Awards Import UI ===\"\")\n\n# 1. Test that venice_years function works\nIO.puts(\"\"\\n1. Testing Venice Years Dropdown Generation...\"\")\ntry do\n  # This simulates what the LiveView does in mount/3\n  venice_years = [\n    # Simulate the generate_venice_years function\n    %{value: \"\"all\"\", label: \"\"All Available Years (2020-2025)\"\"} |\n    Enum.map(2025..2020//-1, fn year ->\n      %{value: to_string(year), label: \"\"#{year} Venice Film Festival\"\"}\n    end)\n  ]\n  \n  IO.puts(\"\"âœ… Venice Years Dropdown Options:\"\")\n  Enum.each(venice_years, fn option ->\n    marker = if option.value == \"\"all\"\", do: \"\" â­ NEW\"\", else: \"\"\"\"\n    IO.puts(\"\"   #{option.value}: #{option.label}#{marker}\"\")\n  end)\n  \nrescue\n  error ->\n    IO.puts(\"\"âŒ Error generating Venice years: #{inspect(error)}\"\")\nend\n\n# 2. Test the updated event handler logic\nIO.puts(\"\"\\n2. Testing Import Event Handler Updates...\"\")\n\ntest_cases = [\n  {%{\"\"festival\"\" => \"\"venice\"\", \"\"year_range\"\" => \"\"2025\"\"}, \"\"Single Year Import\"\"},\n  {%{\"\"festival\"\" => \"\"venice\"\", \"\"year_range\"\" => \"\"all\"\"}, \"\"All Years Import\"\"},\n]\n\nEnum.each(test_cases, fn {params, description} ->\n  IO.puts(\"\"  Testing #{description}: #{inspect(params)}\"\")\n  case params do\n    %{\"\"festival\"\" => \"\"venice\"\", \"\"year_range\"\" => \"\"all\"\"} ->\n      IO.puts(\"\"    âœ… Would call: Cultural.import_venice_years(2020..2025)\"\")\n      \n    %{\"\"festival\"\" => \"\"venice\"\", \"\"year_range\"\" => year_str} ->\n      case Integer.parse(year_str) do\n        {year, \"\"\"\"} when year > 1900 and year <= 2030 ->\n          IO.puts(\"\"    âœ… Would call: Cultural.import_venice_year(#{year})\"\")\n        _ ->\n          IO.puts(\"\"    âŒ Invalid year format\"\")\n      end\n      \n    _ ->\n      IO.puts(\"\"    âŒ Unsupported festival\"\")\n  end\nend)\n\nIO.puts(\"\"\\n3. âœ… UI Improvements Summary:\"\")\nIO.puts(\"\"   âœ… Year input changed to dropdown\"\")\nIO.puts(\"\"   âœ… Added \\\"\"All Years\\\"\" option for complete import\"\")\nIO.puts(\"\"   âœ… Venice years dynamically generated (2020-2025)\"\")\nIO.puts(\"\"   âœ… Updated event handler to support year_range parameter\"\")\nIO.puts(\"\"   âœ… Better UX with descriptive labels\"\")\n\nIO.puts(\"\"\\nðŸŽ‰ Festival Awards Import UI Successfully Updated!\"\")\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres mix run -e '\n# Clear stuck Venice jobs to test the new UI cleanly\nIO.puts(\"\"=== Clearing Stuck Venice Jobs ===\"\")\n\nimport Ecto.Query\nalias Cinegraph.Repo\n\n# Find stuck Venice jobs\nstuck_jobs = Repo.all(\n  from j in Oban.Job,\n  where: j.worker == \"\"Cinegraph.Workers.VeniceFestivalWorker\"\" and j.state == \"\"available\"\",\n  select: %{id: j.id, args: j.args, inserted_at: j.inserted_at}\n)\n\nIO.puts(\"\"Found #{length(stuck_jobs)} stuck Venice jobs:\"\")\nEnum.each(stuck_jobs, fn job ->\n  IO.puts(\"\"  Job #{job.id}: #{inspect(job.args)} (#{job.inserted_at})\"\")\nend)\n\n# Cancel the stuck jobs\nif length(stuck_jobs) > 0 do\n  job_ids = Enum.map(stuck_jobs, & &1.id)\n  \n  {cancelled_count, _} = Repo.update_all(\n    from(j in Oban.Job, where: j.id in ^job_ids),\n    set: [state: \"\"cancelled\"\", cancelled_at: DateTime.utc_now()]\n  )\n  \n  IO.puts(\"\"âœ… Cancelled #{cancelled_count} stuck Venice jobs\"\")\nelse\n  IO.puts(\"\"âœ… No stuck jobs to cancel\"\")\nend\n\n# Check final Venice job status\nfinal_status = from(j in Oban.Job, \n  where: j.worker == \"\"Cinegraph.Workers.VeniceFestivalWorker\"\",\n  group_by: j.state,\n  select: {j.state, count(j.id)}\n) |> Repo.all() |> Enum.into(%{})\n\nIO.puts(\"\"\\nðŸ“Š Final Venice Job Status:\"\")\nIO.puts(\"\"  Available: #{Map.get(final_status, \"\"available\"\", 0)}\"\")\nIO.puts(\"\"  Executing: #{Map.get(final_status, \"\"executing\"\", 0)}\"\")\nIO.puts(\"\"  Completed: #{Map.get(final_status, \"\"completed\"\", 0)}\"\")\nIO.puts(\"\"  Cancelled: #{Map.get(final_status, \"\"cancelled\"\", 0)}\"\")\n\nIO.puts(\"\"\\nðŸŽ‰ Venice Jobs Cleared - Ready to test new UI!\"\")\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=3ba3f8f9 ZYTE_API_KEY=9e754bb61e684aad88a98eceada363ba mix run -e 'IO.puts(\"\"Testing Venice import with fixed Oban configuration...\"\"); result = Cinegraph.Cultural.import_venice_year(2025); IO.inspect(result, label: \"\"Venice Import Result\"\"); Process.sleep(5000); status = Cinegraph.Cultural.get_venice_import_status(); IO.inspect(status, label: \"\"Venice Job Status\"\")')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres mix run -e '\n# Check Festival Awards Import functionality\nIO.puts(\"\"=== Testing Festival Awards Import UI Integration ===\"\")\n\n# 1. Check Venice import status (what UI would show)\nstatus = Cinegraph.Cultural.get_venice_import_status()\nIO.puts(\"\"\\n1. âœ… Venice Import Status (UI display):\"\")\nIO.puts(\"\"   Running jobs: #{status.running_jobs}\"\")\nIO.puts(\"\"   Queued jobs: #{status.queued_jobs}\"\")\nIO.puts(\"\"   Completed jobs: #{status.completed_jobs}\"\")\nIO.puts(\"\"   Failed jobs: #{status.failed_jobs}\"\")\n\n# 2. Check database statistics (what UI shows)\nimport Ecto.Query\nvenice_org = Cinegraph.Festivals.get_organization_by_abbreviation(\"\"VIFF\"\")\nvenice_count = if venice_org do\n  Cinegraph.Repo.one(\n    from n in Cinegraph.Festivals.FestivalNomination,\n    join: c in Cinegraph.Festivals.FestivalCeremony, on: n.ceremony_id == c.id,\n    where: c.organization_id == ^venice_org.id,\n    select: count(n.movie_id, :distinct)\n  ) || 0\nelse\n  0\nend\n\nIO.puts(\"\"\\n2. âœ… Database Statistics (UI Venice Movies count): #{venice_count}\"\")\n\n# 3. Test dropdown functionality\nvenice_years = [\n  %{value: \"\"all\"\", label: \"\"All Available Years (2020-2025)\"\"} |\n  Enum.map(2025..2020//-1, fn year ->\n    %{value: to_string(year), label: \"\"#{year} Venice Film Festival\"\"}\n  end)\n]\n\nIO.puts(\"\"\\n3. âœ… Venice Years Dropdown Options:\"\")\nEnum.each(venice_years, fn option ->\n  marker = if option.value == \"\"all\"\", do: \"\" â­\"\", else: \"\"\"\"\n  IO.puts(\"\"   #{option.value}: #{option.label}#{marker}\"\")\nend)\n\nIO.puts(\"\"\\nðŸŽ‰ Festival Awards Import UI Successfully Working!\"\")\nIO.puts(\"\"   âœ… Venice jobs now process instead of getting stuck\"\")\nIO.puts(\"\"   âœ… UI displays real-time job status\"\")  \nIO.puts(\"\"   âœ… Dropdown interface with year options\"\")\nIO.puts(\"\"   âœ… All Years option for bulk import\"\")\nIO.puts(\"\"   âœ… Statistics tracking and display\"\")\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres mix run -e '\nimport Ecto.Query\nalias Cinegraph.Repo\n\n# Check all Venice jobs\nvenice_jobs = Repo.all(\n  from j in Oban.Job,\n  where: j.worker == \"\"Cinegraph.Workers.VeniceFestivalWorker\"\",\n  order_by: [desc: j.id],\n  select: %{\n    id: j.id, \n    state: j.state, \n    args: j.args, \n    inserted_at: j.inserted_at,\n    scheduled_at: j.scheduled_at,\n    attempted_at: j.attempted_at,\n    attempt: j.attempt,\n    errors: j.errors\n  }\n)\n\nIO.puts(\"\"=== All Venice Jobs ===\"\")\nEnum.each(venice_jobs, fn job ->\n  IO.puts(\"\"\\nJob #{job.id}:\"\")\n  IO.puts(\"\"  State: #{job.state}\"\")\n  IO.puts(\"\"  Args: #{inspect(job.args)}\"\")\n  IO.puts(\"\"  Attempt: #{job.attempt}\"\")\n  IO.puts(\"\"  Inserted: #{job.inserted_at}\"\")\n  if job.errors && length(job.errors) > 0 do\n    IO.puts(\"\"  Errors: #{inspect(job.errors)}\"\")\n  end\nend)\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres ZYTE_API_KEY=9e754bb61e684aad88a98eceada363ba mix run -e '\n# Test the Venice scraper directly to see if it works\nalias Cinegraph.Scrapers.VeniceFilmFestivalScraper\n\nIO.puts(\"\"Testing Venice scraper directly for 2025...\"\")\n\n# Try with timeout to prevent hanging\ntask = Task.async(fn ->\n  VeniceFilmFestivalScraper.fetch_festival_data(2025)\nend)\n\ncase Task.yield(task, 10_000) || Task.shutdown(task) do\n  {:ok, result} ->\n    IO.inspect(result, label: \"\"Scraper Result\"\")\n  nil ->\n    IO.puts(\"\"Scraper timed out after 10 seconds\"\")\n  {:exit, reason} ->\n    IO.puts(\"\"Scraper crashed: #{inspect(reason)}\"\")\nend\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres mix run -e '\nimport Ecto.Query\nalias Cinegraph.Repo\n\n# Cancel stuck executing jobs\n{cancelled_count, _} = Repo.update_all(\n  from(j in Oban.Job, \n    where: j.worker == \"\"Cinegraph.Workers.VeniceFestivalWorker\"\" and j.state == \"\"executing\"\"\n  ),\n  set: [state: \"\"cancelled\"\", cancelled_at: DateTime.utc_now()]\n)\n\nIO.puts(\"\"Cancelled #{cancelled_count} stuck Venice jobs\"\")\n\n# Check remaining jobs\nremaining = Repo.one(\n  from j in Oban.Job,\n  where: j.worker == \"\"Cinegraph.Workers.VeniceFestivalWorker\"\" and j.state != \"\"cancelled\"\",\n  select: count(j.id)\n)\n\nIO.puts(\"\"Remaining non-cancelled Venice jobs: #{remaining}\"\")\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres mix run -e '\nimport Ecto.Query\nalias Cinegraph.Repo\n\n# Cancel stuck executing jobs\n{cancelled_count, _} = Repo.update_all(\n  from(j in Oban.Job, \n    where: j.worker == \"\"Cinegraph.Workers.VeniceFestivalWorker\"\" and j.state == \"\"executing\"\"\n  ),\n  set: [state: \"\"cancelled\"\", cancelled_at: DateTime.utc_now()]\n)\n\nIO.puts(\"\"Cancelled #{cancelled_count} stuck Venice jobs\"\")\n\n# Check remaining jobs\nremaining = Repo.one(\n  from j in Oban.Job,\n  where: j.worker == \"\"Cinegraph.Workers.VeniceFestivalWorker\"\" and j.state not in [\"\"cancelled\"\", \"\"completed\"\", \"\"discarded\"\"],\n  select: count(j.id)\n)\n\nIO.puts(\"\"Remaining active Venice jobs: #{remaining}\"\")\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres ZYTE_API_KEY=9e754bb61e684aad88a98eceada363ba mix run -e '\n# Test Zyte API directly with a simpler request\nurl = \"\"https://www.imdb.com/event/ev0000681/2025/1/\"\"\napi_key = Application.get_env(:cinegraph, :zyte_api_key)\n\nIO.puts(\"\"Testing Zyte API with Venice 2025 URL: #{url}\"\")\nIO.puts(\"\"API Key present: #{api_key != nil && api_key != \\\"\"\\\"\"}\"\")\n\nheaders = [\n  {\"\"Authorization\"\", \"\"Basic #{Base.encode64(api_key <> \"\":\"\")}\"\"},\n  {\"\"Content-Type\"\", \"\"application/json\"\"}\n]\n\nbody = Jason.encode!(%{\n  url: url,\n  browserHtml: true,\n  javascript: true,\n  viewport: %{\n    width: 1920,\n    height: 1080\n  }\n})\n\noptions = [\n  timeout: 30_000,\n  recv_timeout: 30_000,\n  hackney: [pool: :default]\n]\n\nIO.puts(\"\"\\nMaking request to Zyte API...\"\")\ncase HTTPoison.post(\"\"https://api.zyte.com/v1/extract\"\", body, headers, options) do\n  {:ok, %{status_code: 200, body: response}} ->\n    IO.puts(\"\"âœ… Success! Got response\"\")\n    case Jason.decode(response) do\n      {:ok, %{\"\"browserHtml\"\" => html}} ->\n        IO.puts(\"\"HTML length: #{String.length(html)} characters\"\")\n        # Check if __NEXT_DATA__ exists\n        if String.contains?(html, \"\"__NEXT_DATA__\"\") do\n          IO.puts(\"\"âœ… Found __NEXT_DATA__ in response\"\")\n        else\n          IO.puts(\"\"âŒ No __NEXT_DATA__ found in response\"\")\n        end\n      {:ok, data} ->\n        IO.puts(\"\"Response structure: #{inspect(Map.keys(data))}\"\")\n      {:error, reason} ->\n        IO.puts(\"\"Failed to parse JSON: #{inspect(reason)}\"\")\n    end\n    \n  {:ok, %{status_code: status, body: body}} ->\n    IO.puts(\"\"âŒ Zyte API error (#{status}): #{String.slice(body, 0, 200)}\"\")\n    \n  {:error, %HTTPoison.Error{reason: reason}} ->\n    IO.puts(\"\"âŒ HTTP error: #{inspect(reason)}\"\")\nend\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres ZYTE_API_KEY=9e754bb61e684aad88a98eceada363ba mix run -e '\n# Test Zyte API directly with a simpler request\nurl = \"\"https://www.imdb.com/event/ev0000681/2025/1/\"\"\napi_key = Application.get_env(:cinegraph, :zyte_api_key)\n\nIO.puts(\"\"Testing Zyte API with Venice 2025 URL: #{url}\"\")\nIO.puts(\"\"API Key present: #{not is_nil(api_key) and api_key != \"\"\"\"}\"\")\n\nheaders = [\n  {\"\"Authorization\"\", \"\"Basic #{Base.encode64(api_key <> \"\":\"\")}\"\"},\n  {\"\"Content-Type\"\", \"\"application/json\"\"}\n]\n\nbody = Jason.encode!(%{\n  url: url,\n  browserHtml: true,\n  javascript: true,\n  viewport: %{\n    width: 1920,\n    height: 1080\n  }\n})\n\noptions = [\n  timeout: 30_000,\n  recv_timeout: 30_000,\n  hackney: [pool: :default]\n]\n\nIO.puts(\"\"\\nMaking request to Zyte API...\"\")\ncase HTTPoison.post(\"\"https://api.zyte.com/v1/extract\"\", body, headers, options) do\n  {:ok, %{status_code: 200, body: response}} ->\n    IO.puts(\"\"âœ… Success! Got response\"\")\n    case Jason.decode(response) do\n      {:ok, %{\"\"browserHtml\"\" => html}} ->\n        IO.puts(\"\"HTML length: #{String.length(html)} characters\"\")\n        # Check if __NEXT_DATA__ exists\n        if String.contains?(html, \"\"__NEXT_DATA__\"\") do\n          IO.puts(\"\"âœ… Found __NEXT_DATA__ in response\"\")\n        else\n          IO.puts(\"\"âŒ No __NEXT_DATA__ found in response\"\")\n        end\n      {:ok, data} ->\n        IO.puts(\"\"Response structure: #{inspect(Map.keys(data))}\"\")\n      {:error, reason} ->\n        IO.puts(\"\"Failed to parse JSON: #{inspect(reason)}\"\")\n    end\n    \n  {:ok, %{status_code: status, body: body}} ->\n    IO.puts(\"\"âŒ Zyte API error (#{status}): #{String.slice(body, 0, 200)}\"\")\n    \n  {:error, %HTTPoison.Error{reason: reason}} ->\n    IO.puts(\"\"âŒ HTTP error: #{inspect(reason)}\"\")\nend\n')",
      "Bash(ZYTE_API_KEY=9e754bb61e684aad88a98eceada363ba mix run -e '\n# Test fetching raw HTML to see what we actually get\nurl = \"\"https://www.imdb.com/event/ev0000681/2025/1/\"\"\napi_key = Application.get_env(:cinegraph, :zyte_api_key)\n\nheaders = [\n  {\"\"Authorization\"\", \"\"Basic #{Base.encode64(api_key <> \"\":\"\")}\"\"},\n  {\"\"Content-Type\"\", \"\"application/json\"\"}\n]\n\nbody = Jason.encode!(%{\n  url: url,\n  browserHtml: true,\n  javascript: true,\n  viewport: %{width: 1920, height: 1080}\n})\n\ncase HTTPoison.post(\"\"https://api.zyte.com/v1/extract\"\", body, headers, timeout: 30_000, recv_timeout: 30_000) do\n  {:ok, %{status_code: 200, body: response}} ->\n    case Jason.decode(response) do\n      {:ok, %{\"\"browserHtml\"\" => html}} ->\n        # Save HTML for inspection\n        File.write!(\"\"venice_2025.html\"\", html)\n        IO.puts(\"\"HTML saved to venice_2025.html\"\")\n        \n        # Check for various possible data structures\n        has_next_data = String.contains?(html, \"\"__NEXT_DATA__\"\")\n        has_awards_section = String.contains?(html, \"\"event-awards\"\")\n        has_nominees = String.contains?(html, \"\"nominee\"\")\n        has_winner = String.contains?(html, \"\"winner\"\")\n        \n        IO.puts(\"\"\\n=== HTML Structure Analysis ===\"\")\n        IO.puts(\"\"Has __NEXT_DATA__: #{has_next_data}\"\")\n        IO.puts(\"\"Has awards section: #{has_awards_section}\"\")\n        IO.puts(\"\"Has nominees: #{has_nominees}\"\")\n        IO.puts(\"\"Has winner: #{has_winner}\"\")\n        \n        # Try to find the actual award data structure\n        if String.contains?(html, \"\"Golden Lion\"\") do\n          IO.puts(\"\"\\nâœ… Found Golden Lion award mention\"\")\n        end\n        \n        if String.contains?(html, \"\"Silver Lion\"\") do\n          IO.puts(\"\"âœ… Found Silver Lion award mention\"\")\n        end\n        \n        # Check for React/Next.js app structure\n        if String.contains?(html, \"\"data-testid\"\") do\n          IO.puts(\"\"\\nðŸ“Š Found data-testid attributes (likely React app)\"\")\n        end\n        \n      {:ok, other} ->\n        IO.puts(\"\"Unexpected response structure: #{inspect(Map.keys(other))}\"\")\n    end\n    \n  {:ok, %{status_code: status}} ->\n    IO.puts(\"\"HTTP #{status} response\"\")\n    \n  {:error, reason} ->\n    IO.puts(\"\"Error: #{inspect(reason)}\"\")\nend\n')",
      "Bash(ZYTE_API_KEY=9e754bb61e684aad88a98eceada363ba mix run -e '\n# Test fetching raw HTML to see what we actually get\nurl = \"\"https://www.imdb.com/event/ev0000681/2025/1/\"\"\napi_key = Application.get_env(:cinegraph, :zyte_api_key)\n\nheaders = [\n  {\"\"Authorization\"\", \"\"Basic #{Base.encode64(api_key <> \"\":\"\")}\"\"},\n  {\"\"Content-Type\"\", \"\"application/json\"\"}\n]\n\nbody = Jason.encode!(%{\n  url: url,\n  browserHtml: true,\n  javascript: true,\n  viewport: %{width: 1920, height: 1080}\n})\n\ncase HTTPoison.post(\"\"https://api.zyte.com/v1/extract\"\", body, headers, timeout: 30_000, recv_timeout: 30_000) do\n  {:ok, %{status_code: 200, body: response}} ->\n    case Jason.decode(response) do\n      {:ok, %{\"\"browserHtml\"\" => html}} ->\n        # Save HTML for inspection\n        File.write!(\"\"venice_2025.html\"\", html)\n        IO.puts(\"\"HTML saved to venice_2025.html\"\")\n        \n        # Check for various possible data structures\n        has_next_data = String.contains?(html, \"\"__NEXT_DATA__\"\")\n        has_awards_section = String.contains?(html, \"\"event-awards\"\")\n        has_nominees = String.contains?(html, \"\"nominee\"\")\n        has_winner = String.contains?(html, \"\"winner\"\")\n        \n        IO.puts(\"\"\\n=== HTML Structure Analysis ===\"\")\n        IO.puts(\"\"Has __NEXT_DATA__: #{has_next_data}\"\")\n        IO.puts(\"\"Has awards section: #{has_awards_section}\"\")\n        IO.puts(\"\"Has nominees: #{has_nominees}\"\")\n        IO.puts(\"\"Has winner: #{has_winner}\"\")\n        \n        # Try to find the actual award data structure\n        if String.contains?(html, \"\"Golden Lion\"\") do\n          IO.puts(\"\"\\nâœ… Found Golden Lion award mention\"\")\n        end\n        \n        if String.contains?(html, \"\"Silver Lion\"\") do\n          IO.puts(\"\"âœ… Found Silver Lion award mention\"\")\n        end\n        \n        # Check for React/Next.js app structure\n        if String.contains?(html, \"\"data-testid\"\") do\n          IO.puts(\"\"\\nðŸ“Š Found data-testid attributes (likely React app)\"\")\n        end\n        \n      {:ok, other} ->\n        IO.puts(\"\"Unexpected response structure: #{inspect(Map.keys(other))}\"\")\n    end\n    \n  {:ok, %{status_code: status}} ->\n    IO.puts(\"\"HTTP #{status} response\"\")\n    \n  {:error, reason} ->\n    IO.puts(\"\"Error: #{inspect(reason)}\"\")\nend\n')",
      "Bash(ZYTE_API_KEY=9e754bb61e684aad88a98eceada363ba mix run test_venice_html.exs)",
      "Bash(ZYTE_API_KEY=9e754bb61e684aad88a98eceada363ba mix run -e '\n# Test Venice import with updated scraper\nresult = Cinegraph.Cultural.import_venice_year(2025)\nIO.inspect(result, label: \"\"Venice Import Result\"\")\n\n# Wait a bit for the job to start\nProcess.sleep(5000)\n\n# Check job status\nimport Ecto.Query\njob = Cinegraph.Repo.one(\n  from j in Oban.Job,\n  where: j.worker == \"\"Cinegraph.Workers.VeniceFestivalWorker\"\",\n  order_by: [desc: j.id],\n  limit: 1\n)\n\nif job do\n  IO.puts(\"\"\\nJob status: #{job.state}\"\")\n  if job.errors && length(job.errors) > 0 do\n    IO.puts(\"\"Errors: #{inspect(job.errors)}\"\")\n  end\nend\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres mix run -e '\n# Test Venice import with updated scraper that uses direct HTTP\nIO.puts(\"\"=== Testing Venice Import with Direct HTTP ===\"\")\n\n# Clear any stuck jobs first\nimport Ecto.Query\nalias Cinegraph.Repo\n\n{cancelled_count, _} = Repo.update_all(\n  from(j in Oban.Job, \n    where: j.worker == \"\"Cinegraph.Workers.VeniceFestivalWorker\"\" and j.state in [\"\"executing\"\", \"\"available\"\"]\n  ),\n  set: [state: \"\"cancelled\"\", cancelled_at: DateTime.utc_now()]\n)\n\nif cancelled_count > 0 do\n  IO.puts(\"\"Cancelled #{cancelled_count} stuck Venice jobs\"\")\nend\n\n# Try importing Venice 2025 again\nIO.puts(\"\"\\nImporting Venice 2025...\"\")\nresult = Cinegraph.Cultural.import_venice_year(2025)\nIO.inspect(result, label: \"\"Import Result\"\")\n\n# Wait for job to process\nProcess.sleep(10000)\n\n# Check job status\njob = Repo.one(\n  from j in Oban.Job,\n  where: j.worker == \"\"Cinegraph.Workers.VeniceFestivalWorker\"\",\n  order_by: [desc: j.id],\n  limit: 1\n)\n\nif job do\n  IO.puts(\"\"\\nðŸ“Š Latest Job Status: #{job.state}\"\")\n  \n  if job.state == \"\"completed\"\" do\n    IO.puts(\"\"âœ… SUCCESS! Venice import completed\"\")\n    \n    # Check if ceremony was created\n    venice_org = Cinegraph.Festivals.get_organization_by_abbreviation(\"\"VIFF\"\")\n    if venice_org do\n      ceremony = Cinegraph.Festivals.get_ceremony_by_year(venice_org.id, 2025)\n      if ceremony do\n        IO.puts(\"\"\\nðŸŽ¬ Venice 2025 Ceremony Created!\"\")\n        awards = ceremony.data[\"\"awards\"\"] || %{}\n        IO.puts(\"\"Found #{map_size(awards)} award categories\"\")\n        \n        # Check for nominations\n        nomination_count = Repo.one(\n          from n in Cinegraph.Festivals.FestivalNomination,\n          where: n.ceremony_id == ^ceremony.id,\n          select: count(n.id)\n        )\n        IO.puts(\"\"Created #{nomination_count} nominations\"\")\n      end\n    end\n  elsif job.state == \"\"failed\"\" || job.state == \"\"discarded\"\" do\n    IO.puts(\"\"âŒ Job failed\"\")\n    if job.errors && length(job.errors) > 0 do\n      IO.puts(\"\"Errors: #{inspect(job.errors)}\"\")\n    end\n  else\n    IO.puts(\"\"â³ Job still in state: #{job.state}\"\")\n  end\nend\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres mix run -e '\n# Test Venice import with updated scraper that uses direct HTTP\nIO.puts(\"\"=== Testing Venice Import with Direct HTTP ===\"\")\n\n# Clear any stuck jobs first\nimport Ecto.Query\nalias Cinegraph.Repo\n\n{cancelled_count, _} = Repo.update_all(\n  from(j in Oban.Job, \n    where: j.worker == \"\"Cinegraph.Workers.VeniceFestivalWorker\"\" and j.state in [\"\"executing\"\", \"\"available\"\"]\n  ),\n  set: [state: \"\"cancelled\"\", cancelled_at: DateTime.utc_now()]\n)\n\nif cancelled_count > 0 do\n  IO.puts(\"\"Cancelled #{cancelled_count} stuck Venice jobs\"\")\nend\n\n# Try importing Venice 2025 again\nIO.puts(\"\"\\nImporting Venice 2025...\"\")\nresult = Cinegraph.Cultural.import_venice_year(2025)\nIO.inspect(result, label: \"\"Import Result\"\")\n\n# Wait for job to process\nProcess.sleep(10000)\n\n# Check job status\njob = Repo.one(\n  from j in Oban.Job,\n  where: j.worker == \"\"Cinegraph.Workers.VeniceFestivalWorker\"\",\n  order_by: [desc: j.id],\n  limit: 1\n)\n\nif job do\n  IO.puts(\"\"\\nðŸ“Š Latest Job Status: #{job.state}\"\")\n  \n  if job.state == \"\"completed\"\" do\n    IO.puts(\"\"âœ… SUCCESS! Venice import completed\"\")\n    \n    # Check if ceremony was created\n    venice_org = Cinegraph.Festivals.get_organization_by_abbreviation(\"\"VIFF\"\")\n    if venice_org do\n      ceremony = Cinegraph.Festivals.get_ceremony_by_year(venice_org.id, 2025)\n      if ceremony do\n        IO.puts(\"\"\\nðŸŽ¬ Venice 2025 Ceremony Created!\"\")\n        awards = ceremony.data[\"\"awards\"\"] || %{}\n        IO.puts(\"\"Found #{map_size(awards)} award categories\"\")\n        \n        # Check for nominations\n        nomination_count = Repo.one(\n          from n in Cinegraph.Festivals.FestivalNomination,\n          where: n.ceremony_id == ^ceremony.id,\n          select: count(n.id)\n        )\n        IO.puts(\"\"Created #{nomination_count} nominations\"\")\n      end\n    end\n  elsif job.state == \"\"failed\"\" || job.state == \"\"discarded\"\" do\n    IO.puts(\"\"âŒ Job failed\"\")\n    if job.errors && length(job.errors) > 0 do\n      IO.puts(\"\"Errors: #{inspect(job.errors)}\"\")\n    end\n  else\n    IO.puts(\"\"â³ Job still in state: #{job.state}\"\")\n  end\nend\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres mix run -e '\n# Test 1: Direct HTTP request (no Zyte)\nurl = \"\"https://www.imdb.com/event/ev0000681/2024/1/\"\"\nIO.puts(\"\"=== Test 1: Direct HTTP (no Zyte) ===\"\")\nIO.puts(\"\"URL: #{url}\"\")\n\nheaders = [\n  {\"\"User-Agent\"\", \"\"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36\"\"},\n  {\"\"Accept\"\", \"\"text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\"\"}\n]\n\ncase HTTPoison.get(url, headers, timeout: 10_000, recv_timeout: 10_000) do\n  {:ok, %{status_code: 200, body: body}} ->\n    IO.puts(\"\"âœ… SUCCESS! Got HTML (#{byte_size(body)} bytes)\"\")\n    # Check for Venice content\n    if String.contains?(body, \"\"Venice\"\") do\n      IO.puts(\"\"âœ… Contains Venice content\"\")\n    end\n    if String.contains?(body, \"\"Golden Lion\"\") do\n      IO.puts(\"\"âœ… Contains Golden Lion\"\")\n    end\n    \n  {:ok, %{status_code: status}} ->\n    IO.puts(\"\"âŒ HTTP #{status} response\"\")\n    \n  {:error, reason} ->\n    IO.puts(\"\"âŒ Error: #{inspect(reason)}\"\")\nend\n')",
      "Bash(ZYTE_API_KEY=9e754bb61e684aad88a98eceada363ba mix run -e '\n# Test 2: Zyte API\nurl = \"\"https://www.imdb.com/event/ev0000681/2024/1/\"\"\napi_key = Application.get_env(:cinegraph, :zyte_api_key)\n\nIO.puts(\"\"=== Test 2: Zyte API ===\"\")\nIO.puts(\"\"URL: #{url}\"\")\nIO.puts(\"\"API Key present: #{api_key != nil && api_key != \\\"\"\\\"\"}\"\")\n\nheaders = [\n  {\"\"Authorization\"\", \"\"Basic #{Base.encode64(api_key <> \"\":\"\")}\"\"},\n  {\"\"Content-Type\"\", \"\"application/json\"\"}\n]\n\nbody = Jason.encode!(%{\n  url: url,\n  browserHtml: true,\n  javascript: true,\n  viewport: %{width: 1920, height: 1080}\n})\n\ncase HTTPoison.post(\"\"https://api.zyte.com/v1/extract\"\", body, headers, timeout: 30_000, recv_timeout: 30_000) do\n  {:ok, %{status_code: 200, body: response}} ->\n    case Jason.decode(response) do\n      {:ok, %{\"\"browserHtml\"\" => html}} ->\n        IO.puts(\"\"âœ… SUCCESS with Zyte! Got HTML (#{byte_size(html)} bytes)\"\")\n        if String.contains?(html, \"\"Venice\"\") do\n          IO.puts(\"\"âœ… Contains Venice content\"\")\n        end\n        if String.contains?(html, \"\"Golden Lion\"\") do\n          IO.puts(\"\"âœ… Contains Golden Lion\"\")\n        end\n      {:ok, _} ->\n        IO.puts(\"\"âŒ Unexpected Zyte response structure\"\")\n    end\n    \n  {:ok, %{status_code: status}} ->\n    IO.puts(\"\"âŒ Zyte API returned HTTP #{status}\"\")\n    \n  {:error, reason} ->\n    IO.puts(\"\"âŒ Error calling Zyte: #{inspect(reason)}\"\")\nend\n')",
      "Bash(ZYTE_API_KEY=9e754bb61e684aad88a98eceada363ba mix run -e '\n# Test 2: Zyte API\nurl = \"\"https://www.imdb.com/event/ev0000681/2024/1/\"\"\napi_key = Application.get_env(:cinegraph, :zyte_api_key)\n\nIO.puts(\"\"=== Test 2: Zyte API ===\"\")\nIO.puts(\"\"URL: #{url}\"\")\nIO.puts(\"\"API Key present: #{not is_nil(api_key)}\"\")\n\nheaders = [\n  {\"\"Authorization\"\", \"\"Basic #{Base.encode64(api_key <> \"\":\"\")}\"\"},\n  {\"\"Content-Type\"\", \"\"application/json\"\"}\n]\n\nbody = Jason.encode!(%{\n  url: url,\n  browserHtml: true,\n  javascript: true,\n  viewport: %{width: 1920, height: 1080}\n})\n\ncase HTTPoison.post(\"\"https://api.zyte.com/v1/extract\"\", body, headers, timeout: 30_000, recv_timeout: 30_000) do\n  {:ok, %{status_code: 200, body: response}} ->\n    case Jason.decode(response) do\n      {:ok, %{\"\"browserHtml\"\" => html}} ->\n        IO.puts(\"\"âœ… SUCCESS with Zyte! Got HTML (#{byte_size(html)} bytes)\"\")\n        if String.contains?(html, \"\"Venice\"\") do\n          IO.puts(\"\"âœ… Contains Venice content\"\")\n        end\n        if String.contains?(html, \"\"Golden Lion\"\") do\n          IO.puts(\"\"âœ… Contains Golden Lion\"\")\n        end\n      {:ok, _} ->\n        IO.puts(\"\"âŒ Unexpected Zyte response structure\"\")\n    end\n    \n  {:ok, %{status_code: status}} ->\n    IO.puts(\"\"âŒ Zyte API returned HTTP #{status}\"\")\n    \n  {:error, reason} ->\n    IO.puts(\"\"âŒ Error calling Zyte: #{inspect(reason)}\"\")\nend\n')",
      "Bash(ZYTE_API_KEY=9e754bb61e684aad88a98eceada363ba mix run test_venice_fetch.exs)",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres mix run -e '\n# Test Venice import again\nIO.puts(\"\"Testing Venice import with association fix...\"\")\n\nresult = Cinegraph.Cultural.import_venice_year(2024)\nIO.inspect(result, label: \"\"Venice Import Result\"\")\n\n# Wait for job to process\nProcess.sleep(10000)\n\n# Check job status\nimport Ecto.Query\njob = Cinegraph.Repo.one(\n  from j in Oban.Job,\n  where: j.worker == \"\"Cinegraph.Workers.VeniceFestivalWorker\"\",\n  order_by: [desc: j.id],\n  limit: 1\n)\n\nif job do\n  IO.puts(\"\"\\nðŸ“Š Latest Job Status: #{job.state}\"\")\n  \n  if job.state == \"\"completed\"\" do\n    IO.puts(\"\"âœ… SUCCESS! Venice import completed\"\")\n    \n    # Check for ceremony and nominations\n    venice_org = Cinegraph.Festivals.get_organization_by_abbreviation(\"\"VIFF\"\")\n    if venice_org do\n      ceremony = Cinegraph.Festivals.get_ceremony_by_year(venice_org.id, 2024)\n      if ceremony do\n        IO.puts(\"\"\\nðŸŽ¬ Venice 2024 Ceremony Found!\"\")\n        awards = ceremony.data[\"\"awards\"\"] || %{}\n        IO.puts(\"\"Award categories: #{map_size(awards)}\"\")\n        \n        # Check for nominations created\n        nomination_count = Cinegraph.Repo.one(\n          from n in Cinegraph.Festivals.FestivalNomination,\n          where: n.ceremony_id == ^ceremony.id,\n          select: count(n.id)\n        )\n        IO.puts(\"\"Nominations created: #{nomination_count}\"\")\n      end\n    end\n  elsif job.state == \"\"failed\"\" || job.state == \"\"discarded\"\" do\n    IO.puts(\"\"âŒ Job failed\"\")\n    if job.errors && length(job.errors) > 0 do\n      IO.puts(\"\"Errors: #{inspect(job.errors)}\"\")\n    end\n  else\n    IO.puts(\"\"â³ Job still in state: #{job.state}\"\")\n  end\nend\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres mix run -e '\n# Test Venice import again\nIO.puts(\"\"Testing Venice import with association fix...\"\")\n\nresult = Cinegraph.Cultural.import_venice_year(2024)\nIO.inspect(result, label: \"\"Venice Import Result\"\")\n\n# Wait for job to process\nProcess.sleep(10000)\n\n# Check job status\nimport Ecto.Query\njob = Cinegraph.Repo.one(\n  from(j in Oban.Job,\n    where: j.worker == \"\"Cinegraph.Workers.VeniceFestivalWorker\"\",\n    order_by: [desc: j.id],\n    limit: 1\n  )\n)\n\nif job do\n  IO.puts(\"\"\\nðŸ“Š Latest Job Status: #{job.state}\"\")\n  \n  if job.state == \"\"completed\"\" do\n    IO.puts(\"\"âœ… SUCCESS! Venice import completed\"\")\n    \n    # Check for ceremony and nominations\n    venice_org = Cinegraph.Festivals.get_organization_by_abbreviation(\"\"VIFF\"\")\n    if venice_org do\n      ceremony = Cinegraph.Festivals.get_ceremony_by_year(venice_org.id, 2024)\n      if ceremony do\n        IO.puts(\"\"\\nðŸŽ¬ Venice 2024 Ceremony Found!\"\")\n        awards = ceremony.data[\"\"awards\"\"] || %{}\n        IO.puts(\"\"Award categories: #{map_size(awards)}\"\")\n        \n        # Check for nominations created\n        nomination_count = Cinegraph.Repo.one(\n          from(n in Cinegraph.Festivals.FestivalNomination,\n            where: n.ceremony_id == ^ceremony.id,\n            select: count(n.id)\n          )\n        )\n        IO.puts(\"\"Nominations created: #{nomination_count}\"\")\n      end\n    end\n  elsif job.state == \"\"failed\"\" || job.state == \"\"discarded\"\" do\n    IO.puts(\"\"âŒ Job failed\"\")\n    if job.errors && length(job.errors) > 0 do\n      IO.puts(\"\"Errors: #{inspect(job.errors)}\"\")\n    end\n  else\n    IO.puts(\"\"â³ Job still in state: #{job.state}\"\")\n  end\nend\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres mix run test_venice_worker_fix.exs)",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres mix run -e '\n# Check Venice import final status\nimport Ecto.Query\n\n# Check if ceremony was created\nvenice_org = Cinegraph.Festivals.get_organization_by_abbreviation(\"\"VIFF\"\")\nif venice_org do\n  ceremony = Cinegraph.Festivals.get_ceremony_by_year(venice_org.id, 2024)\n  if ceremony do\n    IO.puts(\"\"âœ… Venice 2024 Ceremony Created!\"\")\n    awards = ceremony.data[\"\"awards\"\"] || %{}\n    IO.puts(\"\"Award categories: #{map_size(awards)}\"\")\n    \n    # Count nominations\n    nomination_count = Cinegraph.Repo.one(\n      from(n in Cinegraph.Festivals.FestivalNomination,\n        where: n.ceremony_id == ^ceremony.id,\n        select: count(n.id)\n      )\n    )\n    IO.puts(\"\"Nominations created: #{nomination_count}\"\")\n    \n    # Count by category\n    categories = Cinegraph.Repo.all(\n      from(n in Cinegraph.Festivals.FestivalNomination,\n        join: c in Cinegraph.Festivals.FestivalCategory, on: n.category_id == c.id,\n        where: n.ceremony_id == ^ceremony.id,\n        group_by: c.name,\n        select: {c.name, count(n.id)}\n      )\n    )\n    \n    IO.puts(\"\"\\n=== Nominations by Category ===\"\")\n    Enum.each(categories, fn {name, count} ->\n      IO.puts(\"\"  #{name}: #{count}\"\")\n    end)\n    \n    # Check for movies queued\n    queued_jobs = Cinegraph.Repo.one(\n      from(j in Oban.Job,\n        where: j.worker == \"\"Cinegraph.Workers.TMDbDetailsWorker\"\" and j.state in [\"\"available\"\", \"\"executing\"\"],\n        select: count(j.id)\n      )\n    )\n    IO.puts(\"\"\\nTMDb jobs still processing: #{queued_jobs}\"\")\n  end\nend\n')",
      "Bash(TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 mix run -e '\n# Test a few of the stuck IMDb IDs\nstuck_ids = [\"\"tt30810792\"\", \"\"tt28231777\"\", \"\"tt26341960\"\"]\n\nEnum.each(stuck_ids, fn imdb_id ->\n  result = Cinegraph.Services.TMDb.find_by_imdb_id(imdb_id)\n  case result do\n    {:ok, %{\"\"movie_results\"\" => []}} ->\n      IO.puts(\"\"#{imdb_id}: NOT FOUND in TMDb\"\")\n    {:ok, %{\"\"movie_results\"\" => [movie | _]}} ->\n      IO.puts(\"\"#{imdb_id}: Found - #{movie[\"\"title\"\"]} (#{movie[\"\"original_title\"\"]})\"\")\n    {:error, reason} ->\n      IO.puts(\"\"#{imdb_id}: ERROR - #{inspect(reason)}\"\")\n  end\nend)\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT id, worker, queue, state, attempt, max_attempts, errors FROM oban_jobs WHERE worker = ''Cinegraph.Workers.UnifiedFestivalWorker'' ORDER BY id DESC LIMIT 10;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT DISTINCT queue, COUNT(*) as job_count FROM oban_jobs GROUP BY queue ORDER BY queue;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT id, worker, queue, state, attempt, max_attempts FROM oban_jobs WHERE worker = ''Cinegraph.Workers.UnifiedFestivalWorker'' ORDER BY id DESC LIMIT 10;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT name, abbreviation FROM festival_organizations ORDER BY name;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT fc.year, fo.name, fc.name as ceremony_name FROM festival_ceremonies fc JOIN festival_organizations fo ON fc.organization_id = fo.id WHERE fc.year = 2024 ORDER BY fo.name;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT fo.name, COUNT(fn.id) as nominations_count FROM festival_organizations fo LEFT JOIN festival_ceremonies fc ON fo.id = fc.organization_id AND fc.year = 2024 LEFT JOIN festival_nominations fn ON fc.id = fn.ceremony_id GROUP BY fo.id, fo.name ORDER BY nominations_count DESC;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\n-- Check festival ceremonies \nSELECT \n  fo.name as festival,\n  COUNT(fc.id) as ceremonies,\n  STRING_AGG(DISTINCT fc.year::text, '', '' ORDER BY fc.year::text) as years\nFROM festival_organizations fo\nLEFT JOIN festival_ceremonies fc ON fo.id = fc.organization_id\nGROUP BY fo.id, fo.name\nORDER BY fo.name;\n\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\n-- Check festival nominations\nSELECT \n  fo.name as festival,\n  fc.year,\n  COUNT(fn.id) as total_nominations,\n  COUNT(CASE WHEN fn.won = true THEN 1 END) as total_wins,\n  COUNT(DISTINCT fcat.id) as categories\nFROM festival_organizations fo\nLEFT JOIN festival_ceremonies fc ON fo.id = fc.organization_id\nLEFT JOIN festival_nominations fn ON fc.id = fn.ceremony_id\nLEFT JOIN festival_categories fcat ON fn.category_id = fcat.id\nGROUP BY fo.id, fo.name, fc.year\nHAVING COUNT(fc.id) > 0\nORDER BY fo.name, fc.year;\n\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\n-- Check the specific nomination details\nSELECT \n  fo.name as festival,\n  fc.year,\n  fcat.name as category,\n  fn.won,\n  fn.prize_name,\n  m.title as movie_title,\n  m.imdb_id,\n  fn.details\nFROM festival_organizations fo\nJOIN festival_ceremonies fc ON fo.id = fc.organization_id\nJOIN festival_nominations fn ON fc.id = fn.ceremony_id\nJOIN festival_categories fcat ON fn.category_id = fcat.id\nLEFT JOIN movies m ON fn.movie_id = m.id\nWHERE fo.abbreviation = ''VIFF'' AND fc.year = 2024;\n\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\n-- Check all festival organizations and their ceremony status\nSELECT \n  fo.name as festival,\n  fo.abbreviation,\n  COUNT(fc.id) as ceremonies_count,\n  COUNT(fn.id) as nominations_count,\n  STRING_AGG(DISTINCT fc.year::text, '', '' ORDER BY fc.year::text) as ceremony_years\nFROM festival_organizations fo\nLEFT JOIN festival_ceremonies fc ON fo.id = fc.organization_id\nLEFT JOIN festival_nominations fn ON fc.id = fn.ceremony_id\nGROUP BY fo.id, fo.name, fo.abbreviation\nORDER BY fo.name;\n\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\n-- Check all festival ceremonies, including those without nominations\nSELECT \n  fo.name as festival,\n  fo.abbreviation,\n  fc.year,\n  fc.name as ceremony_name,\n  jsonb_array_length(COALESCE(fc.data -> ''awards'', ''{}''::jsonb)) as awards_in_data,\n  COUNT(fn.id) as nominations_count\nFROM festival_organizations fo\nLEFT JOIN festival_ceremonies fc ON fo.id = fc.organization_id\nLEFT JOIN festival_nominations fn ON fc.id = fn.ceremony_id\nGROUP BY fo.id, fo.name, fo.abbreviation, fc.id, fc.year, fc.name, fc.data\nORDER BY fo.name, fc.year;\n\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT jsonb_pretty(data) FROM festival_ceremonies WHERE year = 2024 AND organization_id = (SELECT id FROM festival_organizations WHERE abbreviation = ''VIFF'') LIMIT 1;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT id, worker, queue, state, args FROM oban_jobs WHERE worker = ''Cinegraph.Workers.FestivalDiscoveryWorker'' ORDER BY id DESC LIMIT 10;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT COUNT(*) as nominations FROM festival_nominations WHERE ceremony_id = 104;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=3ba3f8f9 mix run -e '\n# Queue a FestivalDiscoveryWorker job for Venice 2024 ceremony\nalias Cinegraph.Workers.FestivalDiscoveryWorker\n\njob_args = %{\n  \"\"ceremony_id\"\" => 104,\n  \"\"source\"\" => \"\"manual_test\"\"\n}\n\ncase FestivalDiscoveryWorker.new(job_args) |> Oban.insert() do\n  {:ok, job} ->\n    IO.puts(\"\"âœ… Successfully queued FestivalDiscoveryWorker job #{job.id} for Venice 2024 ceremony\"\")\n    \n    # Wait for job to process\n    IO.puts(\"\"Waiting for job to process...\"\")\n    Process.sleep(15000)\n    \n    # Check updated nomination count\n    import Ecto.Query\n    count = Cinegraph.Repo.one(\n      from n in Cinegraph.Festivals.FestivalNomination,\n      where: n.ceremony_id == 104,\n      select: count(n.id)\n    )\n    \n    IO.puts(\"\"Updated nomination count: #{count}\"\")\n    \n  {:error, reason} ->\n    IO.puts(\"\"âŒ Failed to queue job: #{inspect(reason)}\"\")\nend\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT jsonb_pretty(data->''''awards'''') FROM festival_ceremonies WHERE id = 104 LIMIT 1;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=3ba3f8f9 mix run -e '\n# Clear existing Venice nominations first\nIO.puts(\"\"Clearing existing Venice 2024 nominations...\"\")\nimport Ecto.Query\nCinegraph.Repo.delete_all(\n  from n in Cinegraph.Festivals.FestivalNomination,\n  where: n.ceremony_id == 104\n)\n\n# Queue a FestivalDiscoveryWorker job for Venice 2024 ceremony with fixed worker\nalias Cinegraph.Workers.FestivalDiscoveryWorker\n\njob_args = %{\n  \"\"ceremony_id\"\" => 104,\n  \"\"source\"\" => \"\"fixed_worker_test\"\"\n}\n\ncase FestivalDiscoveryWorker.new(job_args) |> Oban.insert() do\n  {:ok, job} ->\n    IO.puts(\"\"âœ… Successfully queued FestivalDiscoveryWorker job #{job.id} for Venice 2024 ceremony\"\")\n    \n    # Wait for job to process\n    IO.puts(\"\"Waiting for job to process...\"\")\n    Process.sleep(20000)\n    \n    # Check updated nomination count\n    count = Cinegraph.Repo.one(\n      from n in Cinegraph.Festivals.FestivalNomination,\n      where: n.ceremony_id == 104,\n      select: count(n.id)\n    )\n    \n    IO.puts(\"\"Updated nomination count: #{count}\"\")\n    \n    # Show sample nominations\n    sample_nominations = Cinegraph.Repo.all(\n      from n in Cinegraph.Festivals.FestivalNomination,\n      join: c in Cinegraph.Festivals.FestivalCategory, on: n.category_id == c.id,\n      join: m in Cinegraph.Movies.Movie, on: n.movie_id == m.id,\n      where: n.ceremony_id == 104,\n      limit: 5,\n      select: %{\n        category: c.name,\n        movie_title: m.title,\n        won: n.won,\n        imdb_id: m.imdb_id\n      }\n    )\n    \n    IO.puts(\"\"\\\\nSample nominations:\"\")\n    Enum.each(sample_nominations, fn nom ->\n      winner_text = if nom.won, do: \"\" (WINNER)\"\", else: \"\"\"\"\n      IO.puts(\"\"  #{nom.category}: #{nom.movie_title} (#{nom.imdb_id})#{winner_text}\"\")\n    end)\n    \n  {:error, reason} ->\n    IO.puts(\"\"âŒ Failed to queue job: #{inspect(reason)}\"\")\nend\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT id, state, errors FROM oban_jobs WHERE id = 42540;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT jsonb_pretty(meta) FROM oban_jobs WHERE id = 42540;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 mix run -e '\n# Test the data format detection for Venice ceremony\nceremony = Cinegraph.Repo.get(Cinegraph.Festivals.FestivalCeremony, 104) |> Cinegraph.Repo.preload(:organization)\n\nif ceremony do\n  IO.puts(\"\"Ceremony: #{ceremony.organization.abbreviation} #{ceremony.year}\"\")\n  \n  # Test extract_categories function\n  defmodule TestExtractor do\n    def extract_categories(data) do\n      cond do\n        # Oscar format: data[\"\"categories\"\"] with nominees inside\n        data[\"\"categories\"\"] || data[:categories] ->\n          categories = data[\"\"categories\"\"] || data[:categories] || []\n          {categories, :oscar_format}\n        \n        # Venice/Festival format: data[\"\"awards\"\"] with categories as keys\n        data[\"\"awards\"\"] || data[:awards] ->\n          awards = data[\"\"awards\"\"] || data[:awards] || %{}\n          # Convert to list of {category_name, nominees} tuples  \n          categories = Enum.map(awards, fn {category_name, nominees} ->\n            {category_name, nominees}\n          end)\n          {categories, :awards_format}\n        \n        true ->\n          {[], :unknown_format}\n      end\n    end\n  end\n  \n  {categories, format} = TestExtractor.extract_categories(ceremony.data)\n  \n  IO.puts(\"\"Format detected: #{format}\"\")\n  IO.puts(\"\"Categories found: #{length(categories)}\"\")\n  \n  if length(categories) > 0 do\n    IO.puts(\"\"\\\\nFirst category:\"\")\n    first_category = List.first(categories)\n    \n    case format do\n      :awards_format ->\n        {category_name, nominees} = first_category\n        IO.puts(\"\"  Name: #{category_name}\"\")\n        IO.puts(\"\"  Nominees: #{length(nominees)}\"\")\n        if length(nominees) > 0 do\n          first_nominee = List.first(nominees)\n          IO.puts(\"\"  First nominee keys: #{inspect(Map.keys(first_nominee))}\"\")\n          IO.puts(\"\"  First nominee: #{inspect(first_nominee, limit: :infinity)}\"\")\n        end\n      :oscar_format ->\n        IO.puts(\"\"  Category data: #{inspect(first_category, limit: :infinity)}\"\")\n    end\n  end\nelse\n  IO.puts(\"\"Ceremony not found\"\")\nend\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT jsonb_object_keys(data) FROM festival_ceremonies WHERE id = 104;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT jsonb_pretty(data->''''categories'''') FROM festival_ceremonies WHERE id = 104 LIMIT 1;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=3ba3f8f9 mix run -e '\n# Queue another FestivalDiscoveryWorker job for Venice 2024 ceremony with the fix\nalias Cinegraph.Workers.FestivalDiscoveryWorker\n\njob_args = %{\n  \"\"ceremony_id\"\" => 104,\n  \"\"source\"\" => \"\"format_detection_fix_test\"\"\n}\n\ncase FestivalDiscoveryWorker.new(job_args) |> Oban.insert() do\n  {:ok, job} ->\n    IO.puts(\"\"âœ… Successfully queued FestivalDiscoveryWorker job #{job.id} for Venice 2024 ceremony\"\")\n    \n    # Wait for job to process\n    IO.puts(\"\"Waiting for job to process...\"\")\n    Process.sleep(15000)\n    \n    # Check updated nomination count\n    import Ecto.Query\n    count = Cinegraph.Repo.one(\n      from n in Cinegraph.Festivals.FestivalNomination,\n      where: n.ceremony_id == 104,\n      select: count(n.id)\n    )\n    \n    IO.puts(\"\"Updated nomination count: #{count}\"\")\n    \n    # Check what categories were created\n    categories = Cinegraph.Repo.all(\n      from c in Cinegraph.Festivals.FestivalCategory,\n      where: c.organization_id == 71,\n      select: %{id: c.id, name: c.name}\n    )\n    \n    IO.puts(\"\"Categories created: #{length(categories)}\"\")\n    Enum.each(categories, fn cat ->\n      IO.puts(\"\"  - #{cat.name} (ID: #{cat.id})\"\")\n    end)\n    \n  {:error, reason} ->\n    IO.puts(\"\"âŒ Failed to queue job: #{inspect(reason)}\"\")\nend\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\nSELECT \n    fo.name as festival,\n    fo.abbreviation,\n    COUNT(fc.id) as ceremonies,\n    COUNT(fn.id) as total_nominations,\n    COUNT(CASE WHEN fn.won = true THEN 1 END) as total_wins,\n    COUNT(DISTINCT fcat.id) as categories\nFROM festival_organizations fo\nLEFT JOIN festival_ceremonies fc ON fo.id = fc.organization_id\nLEFT JOIN festival_nominations fn ON fc.id = fn.ceremony_id\nLEFT JOIN festival_categories fcat ON fn.category_id = fcat.id\nGROUP BY fo.id, fo.name, fo.abbreviation\nORDER BY fo.name;\n\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT \n  ''Ceremonies'' as table_name, COUNT(*) as count \nFROM festival_ceremonies \nUNION ALL \nSELECT \n  ''Categories'' as table_name, COUNT(*) as count \nFROM festival_categories\nUNION ALL\nSELECT \n  ''Nominations'' as table_name, COUNT(*) as count \nFROM festival_nominations\nORDER BY table_name;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT \n  c.id, c.year, c.name, o.name as organization_name, o.abbreviation\nFROM festival_ceremonies c \nJOIN festival_organizations o ON c.organization_id = o.id;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT version FROM schema_migrations ORDER BY version DESC LIMIT 10;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\\d festival_nominations\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT COUNT(*) FROM festival_events;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT source_key, name, active, source_config FROM festival_events ORDER BY source_key;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=3ba3f8f9 mix run -e \"\n# Test if we can find Venice festival\ncase Cinegraph.Events.get_active_by_source_key(\"\"venice\"\") do\n  nil -> \n    IO.puts(\"\"âŒ Venice festival not found in database\"\")\n  festival_event ->\n    IO.puts(\"\"âœ… Found Venice festival: #{festival_event.name}\"\")\n    \n    # Test scraper configuration conversion\n    scraper_config = Cinegraph.Events.FestivalEvent.to_scraper_config(festival_event)\n    IO.puts(\"\"Scraper config: #{inspect(scraper_config, pretty: true)}\"\")\n    \n    # Test fetching festival data\n    IO.puts(\"\"\\nTesting festival data fetch for 2024...\"\")\n    case Cinegraph.Scrapers.UnifiedFestivalScraper.fetch_festival_data(\"\"venice\"\", 2024) do\n      {:ok, data} ->\n        IO.puts(\"\"âœ… Successfully fetched festival data\"\")\n        IO.puts(\"\"Awards found: #{map_size(data.awards || %{})}\"\")\n        \n        # Show first few award categories\n        if map_size(data.awards || %{}) > 0 do\n          IO.puts(\"\"\\nFirst few categories:\"\")\n          data.awards\n          |> Enum.take(3)\n          |> Enum.each(fn {category, nominations} ->\n            IO.puts(\"\"  - #{category}: #{length(nominations)} nominations\"\")\n          end)\n        end\n        \n      {:error, reason} ->\n        IO.puts(\"\"âŒ Failed to fetch festival data: #{inspect(reason)}\"\")\n    end\nend\n\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=3ba3f8f9 mix run -e \"\n# Test Venice import to restore nominations\nIO.puts(\"\"ðŸŽ¬ Testing Venice Festival Import for 2024\"\")\n\n# Use the VeniceFestivalWorker directly\ncase Cinegraph.Workers.VeniceFestivalWorker.queue_year(2024) do\n  {:ok, job} ->\n    IO.puts(\"\"âœ… Successfully queued Venice 2024 import job: #{job.id}\"\")\n    IO.puts(\"\"Job will be processed by Oban worker. Check the dashboard for progress.\"\")\n    \n  {:error, reason} ->\n    IO.puts(\"\"âŒ Failed to queue Venice import: #{inspect(reason)}\"\")\nend\n\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT \n  ''Ceremonies'' as table_name, COUNT(*) as count \nFROM festival_ceremonies \nUNION ALL \nSELECT \n  ''Categories'' as table_name, COUNT(*) as count \nFROM festival_categories\nUNION ALL\nSELECT \n  ''Nominations'' as table_name, COUNT(*) as count \nFROM festival_nominations\nORDER BY table_name;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT COUNT(*) as total_wins FROM festival_nominations WHERE won = true;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT COUNT(*) FROM festival_nominations WHERE ceremony_id = (SELECT id FROM festival_ceremonies WHERE year = 2024 AND organization_id = (SELECT id FROM festival_organizations WHERE abbreviation = ''VIFF''));\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=3ba3f8f9 mix run -e '\n# Queue a FestivalDiscoveryWorker job for Venice 2024 ceremony with the bug fix\nalias Cinegraph.Workers.FestivalDiscoveryWorker\n\njob_args = %{\n  \"\"ceremony_id\"\" => 111,\n  \"\"source\"\" => \"\"manual_bug_fix_test\"\"\n}\n\ncase FestivalDiscoveryWorker.new(job_args) |> Oban.insert() do\n  {:ok, job} ->\n    IO.puts(\"\"âœ… Successfully queued FestivalDiscoveryWorker job #{job.id} for Venice 2024 ceremony (ID: 111)\"\")\n    \n    # Wait for job to process\n    IO.puts(\"\"Waiting for job to process...\"\")\n    Process.sleep(15000)\n    \n    # Check updated nomination count\n    import Ecto.Query\n    count = Cinegraph.Repo.one(\n      from n in Cinegraph.Festivals.FestivalNomination,\n      where: n.ceremony_id == 111,\n      select: count(n.id)\n    )\n    \n    IO.puts(\"\"Venice 2024 nomination count after fix: #{count}\"\")\n    \n  {:error, reason} ->\n    IO.puts(\"\"âŒ Failed to queue job: #{inspect(reason)}\"\")\nend')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT abbreviation, name FROM festival_organizations ORDER BY name;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\nSELECT \n    fo.abbreviation,\n    fo.name,\n    COUNT(DISTINCT fc.id) as ceremonies,\n    COUNT(fn.id) as nominations,\n    COUNT(CASE WHEN fn.won = true THEN 1 END) as wins\nFROM festival_organizations fo\nLEFT JOIN festival_ceremonies fc ON fo.id = fc.organization_id\nLEFT JOIN festival_nominations fn ON fc.id = fn.ceremony_id\nGROUP BY fo.id, fo.abbreviation, fo.name\nORDER BY fo.name;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres mix run:*)",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\n-- Check the raw Cannes 2024 ceremony data structure\nSELECT \n    fc.id,\n    fc.year,\n    fo.name as organization,\n    jsonb_pretty(fc.data) as ceremony_data\nFROM festival_ceremonies fc\nJOIN festival_organizations fo ON fc.organization_id = fo.id\nWHERE fo.abbreviation = ''''CFF'''' AND fc.year = 2024;\n\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\n-- Extract just the award winners from Cannes 2024 ceremony data\nSELECT \n    award_name,\n    jsonb_array_length(awards) as total_entries,\n    (SELECT COUNT(*) FROM jsonb_array_elements(awards) AS elem WHERE elem ->> ''winner'' = ''true'') as winners\nFROM (\n    SELECT \n        key as award_name,\n        value as awards\n    FROM festival_ceremonies fc\n    JOIN festival_organizations fo ON fc.organization_id = fo.id\n    CROSS JOIN jsonb_each(fc.data -> ''awards'') \n    WHERE fo.abbreviation = ''CFF'' AND fc.year = 2024\n) award_data;\n\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\n-- Check the most recent FestivalDiscoveryWorker jobs for Cannes ceremony\nSELECT \n    j.id,\n    j.state,\n    j.worker,\n    j.args ->> ''ceremony_id'' as ceremony_id,\n    j.inserted_at,\n    j.completed_at,\n    j.meta\nFROM oban_jobs j\nWHERE j.worker = ''Cinegraph.Workers.FestivalDiscoveryWorker''\n  AND j.args ->> ''ceremony_id'' = ''121''\nORDER BY j.id DESC\nLIMIT 5;\n\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\n-- Check if Cannes movies were actually created from TMDb jobs\nSELECT \n    COUNT(*) as cannes_movies_with_imdb,\n    COUNT(CASE WHEN m.tmdb_data IS NOT NULL THEN 1 END) as with_tmdb_data\nFROM movies m\nWHERE m.imdb_id IN (\n    -- Get all IMDb IDs from Cannes 2024 ceremony data\n    SELECT DISTINCT elem ->> ''imdb_id'' as imdb_id\n    FROM festival_ceremonies fc\n    JOIN festival_organizations fo ON fc.organization_id = fo.id\n    CROSS JOIN jsonb_each(fc.data -> ''awards'') AS awards(category, nominees)\n    CROSS JOIN jsonb_array_elements(nominees) AS nominee\n    CROSS JOIN jsonb_array_elements(nominee -> ''films'') AS elem\n    WHERE fo.abbreviation = ''CFF'' AND fc.year = 2024 \n      AND elem ->> ''imdb_id'' IS NOT NULL\n);\n\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=3ba3f8f9 mix run -e '\n# Debug the FestivalDiscoveryWorker processing for Cannes\nceremony = Cinegraph.Repo.get(Cinegraph.Festivals.FestivalCeremony, 121) |> Cinegraph.Repo.preload(:organization)\n\nIO.puts(\"\"=== Debugging Cannes 2024 Processing (Ceremony ID: #{ceremony.id}) ===\"\")\n\n# Test the format detection (should be awards_format)\n{categories, format} = ceremony.data\n|> case do\n  data ->\n    oscar_categories = data[\"\"categories\"\"] || data[:categories] || []\n    awards = data[\"\"awards\"\"] || data[:awards] || %{}\n    \n    cond do\n      length(oscar_categories) > 0 ->\n        {oscar_categories, :oscar_format}\n      map_size(awards) > 0 ->\n        categories = Enum.map(awards, fn {category_name, nominees} ->\n          {category_name, nominees}\n        end)\n        {categories, :awards_format}\n      true ->\n        {[], :unknown_format}\n    end\nend\n\nIO.puts(\"\"Format detected: #{format}\"\")\nIO.puts(\"\"Categories found: #{length(categories)}\"\")\n\n# Test processing the first category (palme_dor) with its nominees\nfirst_category = List.first(categories)\n{category_name, nominees} = first_category\n\nIO.puts(\"\"\\\\nFirst category: #{category_name} (#{length(nominees)} nominees)\"\")\n\n# Check the structure of the first nominee\nfirst_nominee = List.first(nominees)\nIO.puts(\"\"\\\\nFirst nominee structure:\"\")\nIO.inspect(first_nominee, pretty: true, limit: :infinity)\n\n# Test film extraction\nfilms = first_nominee[\"\"films\"\"] || []\nif length(films) > 0 do\n  film = List.first(films)\n  imdb_id = film[\"\"imdb_id\"\"] \n  title = film[\"\"title\"\"] \n  year = film[\"\"year\"\"]\n  IO.puts(\"\"\\\\nExtracted film info:\"\")\n  IO.puts(\"\"  IMDb ID: #{imdb_id}\"\")\n  IO.puts(\"\"  Title: #{title}\"\")\n  IO.puts(\"\"  Year: #{year}\"\")\n  \n  # Check if movie exists\n  movie = Cinegraph.Repo.get_by(Cinegraph.Movies.Movie, imdb_id: imdb_id)\n  IO.puts(\"\"  Movie in DB: #{if movie, do: \"\"YES (ID: #{movie.id})\"\", else: \"\"NO\"\"}\"\")\nend\n\n# Check winner status\nis_winner = first_nominee[\"\"winner\"\"] || false\nIO.puts(\"\"\\\\nWinner status: #{is_winner}\"\")\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\n-- Check if any of the Cannes nominations have movie_id populated\nSELECT \n    fn.id,\n    fn.movie_id,\n    fn.won,\n    fc.name as category_name,\n    fn.details,\n    CASE \n        WHEN fn.movie_id IS NOT NULL THEN m.title \n        ELSE ''NO MOVIE LINKED'' \n    END as movie_title\nFROM festival_nominations fn\nJOIN festival_ceremonies fcer ON fn.ceremony_id = fcer.id  \nJOIN festival_organizations fo ON fcer.organization_id = fo.id\nJOIN festival_categories fc ON fn.category_id = fc.id\nLEFT JOIN movies m ON fn.movie_id = m.id\nWHERE fo.abbreviation = ''CFF'' AND fcer.year = 2024\nORDER BY fn.id;\n\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\n-- Check if The Substance (tt17526714) should be marked as winner in ceremony data\nSELECT \n    award_category,\n    film_title,\n    film_imdb_id,\n    winner_status\nFROM (\n    SELECT \n        awards.key as award_category,\n        elem -> ''films'' -> 0 ->> ''title'' as film_title,\n        elem -> ''films'' -> 0 ->> ''imdb_id'' as film_imdb_id,\n        elem ->> ''winner'' as winner_status\n    FROM festival_ceremonies fc\n    CROSS JOIN jsonb_each(fc.data -> ''awards'') AS awards(key, value)\n    CROSS JOIN jsonb_array_elements(value) AS elem\n    WHERE fc.id = 121\n) winners\nWHERE film_imdb_id = ''tt17526714'';\n\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\n-- Look for recent Oban job logs that might show what was skipped\nSELECT \n    j.id,\n    j.errors\nFROM oban_jobs j\nWHERE j.id = 45027\n  AND j.errors IS NOT NULL;\n\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\n-- First, let''s clear the existing broken Cannes nominations\nDELETE FROM festival_nominations \nWHERE ceremony_id = 121;\n\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=3ba3f8f9 mix run -e '\n# Re-run FestivalDiscoveryWorker for Cannes ceremony 121\nalias Cinegraph.Workers.FestivalDiscoveryWorker\n\njob_args = %{\n  \"\"ceremony_id\"\" => 121,\n  \"\"source\"\" => \"\"manual_rerun_after_debug\"\"\n}\n\nIO.puts(\"\"=== Re-running FestivalDiscoveryWorker for Cannes 2024 ===\"\")\n\ncase FestivalDiscoveryWorker.new(job_args) |> Oban.insert() do\n  {:ok, job} ->\n    IO.puts(\"\"âœ… Queued FestivalDiscoveryWorker job #{job.id} for Cannes ceremony 121\"\")\n    \n    # Wait for job to complete\n    IO.puts(\"\"Waiting for job to process...\"\")\n    Process.sleep(30000)\n    \n    # Check results\n    import Ecto.Query\n    \n    # Count nominations created\n    nomination_count = Cinegraph.Repo.one(\n      from n in Cinegraph.Festivals.FestivalNomination,\n      where: n.ceremony_id == 121,\n      select: count(n.id)\n    )\n    \n    # Count winners\n    winner_count = Cinegraph.Repo.one(\n      from n in Cinegraph.Festivals.FestivalNomination,\n      where: n.ceremony_id == 121 and n.won == true,\n      select: count(n.id)\n    )\n    \n    IO.puts(\"\"\\\\n=== Results After Re-run ===\"\")\n    IO.puts(\"\"Nominations created: #{nomination_count}\"\")\n    IO.puts(\"\"Winners found: #{winner_count}\"\")\n    \n    if nomination_count > 7 do\n      IO.puts(\"\"âœ… SUCCESS: More nominations created than before!\"\")\n    else\n      IO.puts(\"\"âŒ STILL BROKEN: Same issue persists\"\")\n    end\n    \n  {:error, reason} ->\n    IO.puts(\"\"âŒ Failed to queue job: #{inspect(reason)}\"\")\nend\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\n-- Verify the Cannes 2024 data is now correct\nSELECT \n    fo.abbreviation,\n    fo.name,\n    COUNT(DISTINCT fc.id) as ceremonies,\n    COUNT(fn.id) as nominations,\n    COUNT(CASE WHEN fn.won = true THEN 1 END) as wins\nFROM festival_organizations fo\nLEFT JOIN festival_ceremonies fc ON fo.id = fc.organization_id\nLEFT JOIN festival_nominations fn ON fc.id = fn.ceremony_id\nWHERE fo.abbreviation = ''CFF''\nGROUP BY fo.id, fo.abbreviation, fo.name;\n\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\n-- Check sample Cannes winners to verify data quality\nSELECT \n    fcat.name as category,\n    m.title as movie_title,\n    m.imdb_id,\n    fn.won,\n    fn.details ->> ''nominee_names'' as person_names\nFROM festival_nominations fn\nJOIN festival_ceremonies fc ON fn.ceremony_id = fc.id\nJOIN festival_organizations fo ON fc.organization_id = fo.id\nJOIN festival_categories fcat ON fn.category_id = fcat.id\nJOIN movies m ON fn.movie_id = m.id\nWHERE fo.abbreviation = ''CFF'' AND fc.year = 2024 AND fn.won = true\nORDER BY fcat.name\nLIMIT 10;\n\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT ''Events'' as system, source_key, name FROM festival_events UNION ALL SELECT ''Organizations'' as system, abbreviation, name FROM festival_organizations ORDER BY system, name;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT source_key FROM festival_events WHERE source_key != ''oscars'' ORDER BY source_key;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT source_key FROM festival_events WHERE source_key <> ''oscars'' ORDER BY source_key;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\n-- Check if Academy Awards organization exists in festival_organizations table\nSELECT \n  ''AMPAS in festival_organizations'' as check_type,\n  CASE \n    WHEN COUNT(*) > 0 THEN ''EXISTS'' \n    ELSE ''MISSING'' \n  END as status,\n  COUNT(*) as count\nFROM festival_organizations \nWHERE abbreviation = ''AMPAS''\n\nUNION ALL\n\n-- Check if oscars event exists in festival_events table  \nSELECT \n  ''oscars in festival_events'' as check_type,\n  CASE \n    WHEN COUNT(*) > 0 THEN ''EXISTS'' \n    ELSE ''MISSING'' \n  END as status,\n  COUNT(*) as count\nFROM festival_events \nWHERE source_key = ''oscars''\n\nUNION ALL\n\n-- Check all festival organizations\nSELECT \n  ''Total festival_organizations'' as check_type,\n  ''INFO'' as status,\n  COUNT(*) as count\nFROM festival_organizations\n\nUNION ALL\n\n-- Check all festival events\nSELECT \n  ''Total festival_events'' as check_type,\n  ''INFO'' as status,\n  COUNT(*) as count\nFROM festival_events\n\nORDER BY check_type;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\n-- Check Oscar festival event details\nSELECT \n  source_key,\n  name,\n  abbreviation,\n  active,\n  primary_source,\n  tracks_nominations,\n  tracks_winners_only,\n  min_available_year,\n  max_available_year\nFROM festival_events \nWHERE source_key = ''oscars'';\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=3ba3f8f9 mix run -e '\n# Test what UnifiedFestivalScraper returns for \"\"oscars\"\"\ncase Cinegraph.Scrapers.UnifiedFestivalScraper.get_festival_config(\"\"oscars\"\") do\n  nil -> \n    IO.puts(\"\"âŒ UnifiedFestivalScraper.get_festival_config(\\\"\"oscars\\\"\") returns nil\"\")\n    \n    # Test the underlying Events call\n    case Cinegraph.Events.get_active_by_source_key(\"\"oscars\"\") do\n      nil -> IO.puts(\"\"âŒ Events.get_active_by_source_key(\\\"\"oscars\\\"\") returns nil\"\")\n      event -> IO.puts(\"\"âœ… Events.get_active_by_source_key(\\\"\"oscars\\\"\") found: #{event.name}\"\")\n    end\n    \n  config -> \n    IO.puts(\"\"âœ… UnifiedFestivalScraper.get_festival_config(\\\"\"oscars\\\"\") found config:\"\")\n    IO.inspect(config, pretty: true)\nend\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\n-- Check recent UnifiedFestivalWorker jobs for oscars\nSELECT \n  id,\n  worker,\n  args ->> ''festival'' as festival,\n  args ->> ''year'' as year,\n  state,\n  attempt,\n  max_attempts,\n  inserted_at,\n  completed_at,\n  errors\nFROM oban_jobs \nWHERE worker = ''Cinegraph.Workers.UnifiedFestivalWorker'' \n  AND args ->> ''festival'' = ''oscars''\nORDER BY id DESC \nLIMIT 10;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\n-- Check recent FestivalDiscoveryWorker job failures\nSELECT \n  id,\n  worker,\n  args ->> ''ceremony_id'' as ceremony_id,\n  state,\n  attempt,\n  max_attempts,\n  inserted_at,\n  completed_at,\n  CASE \n    WHEN errors IS NOT NULL THEN substring(errors::text, 1, 200) || ''...''\n    ELSE ''No errors''\n  END as error_summary\nFROM oban_jobs \nWHERE worker = ''Cinegraph.Workers.FestivalDiscoveryWorker'' \n  AND state IN (''failed'', ''retryable'', ''discarded'')\nORDER BY id DESC \nLIMIT 15;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\n-- Check all possible job states\nSELECT DISTINCT state, COUNT(*) \nFROM oban_jobs \nWHERE worker = ''Cinegraph.Workers.FestivalDiscoveryWorker''\nGROUP BY state\nORDER BY state;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\n-- Check UnifiedFestivalWorker job states\nSELECT \n  worker,\n  state,\n  COUNT(*) as job_count,\n  MIN(inserted_at) as earliest,\n  MAX(completed_at) as latest_completed\nFROM oban_jobs \nWHERE worker IN (''Cinegraph.Workers.UnifiedFestivalWorker'', ''Cinegraph.Workers.FestivalDiscoveryWorker'')\nGROUP BY worker, state\nORDER BY worker, state;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\n-- Check job timing and potential overlaps\nSELECT \n  id,\n  worker,\n  args ->> ''festival'' as festival,\n  args ->> ''year'' as year,\n  args ->> ''ceremony_id'' as ceremony_id,\n  state,\n  inserted_at,\n  completed_at,\n  EXTRACT(EPOCH FROM (completed_at - inserted_at)) as duration_seconds\nFROM oban_jobs \nWHERE worker IN (''Cinegraph.Workers.UnifiedFestivalWorker'', ''Cinegraph.Workers.FestivalDiscoveryWorker'')\nORDER BY inserted_at DESC \nLIMIT 20;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\n-- Check constraints and indexes on festival_nominations table\n\\d festival_nominations\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\nSELECT\n  conname as constraint_name,\n  contype as constraint_type,\n  conkey as column_positions,\n  pg_get_constraintdef(oid) as definition\nFROM pg_constraint \nWHERE conrelid = ''festival_nominations''::regclass;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\n-- Check for duplicate nominations\nSELECT \n  ceremony_id,\n  category_id,\n  movie_id,\n  person_id,\n  COUNT(*) as duplicate_count\nFROM festival_nominations\nGROUP BY ceremony_id, category_id, movie_id, person_id\nHAVING COUNT(*) > 1\nORDER BY duplicate_count DESC\nLIMIT 10;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\n-- Check nominations with NULL movie_id (waiting for TMDb jobs to complete)\nSELECT \n  fo.name as festival,\n  fc.year,\n  fcat.name as category,\n  COUNT(*) as nominations_without_movie\nFROM festival_nominations fn\nJOIN festival_ceremonies fc ON fn.ceremony_id = fc.id\nJOIN festival_organizations fo ON fc.organization_id = fo.id\nJOIN festival_categories fcat ON fn.category_id = fcat.id\nWHERE fn.movie_id IS NULL\nGROUP BY fo.name, fc.year, fcat.name\nORDER BY nominations_without_movie DESC\nLIMIT 10;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\n-- Check if ceremony data was processed multiple times\nSELECT \n  fc.id as ceremony_id,\n  fo.name as festival,\n  fc.year,\n  COUNT(fn.id) as total_nominations,\n  MAX(fn.inserted_at) as latest_nomination_created,\n  MIN(fn.inserted_at) as earliest_nomination_created,\n  COUNT(DISTINCT DATE_TRUNC(''minute'', fn.inserted_at)) as processing_sessions\nFROM festival_ceremonies fc\nJOIN festival_organizations fo ON fc.organization_id = fo.id\nLEFT JOIN festival_nominations fn ON fn.ceremony_id = fc.id\nWHERE fc.year = 2024\nGROUP BY fc.id, fo.name, fc.year\nORDER BY fo.name;\")",
      "Bash(git reset:*)",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT source_key, name, country, founded_year, primary_source FROM festival_events ORDER BY import_priority DESC, typical_start_month;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT fe.source_key, fe.name, fd.year, fd.start_date, fd.end_date, fd.status FROM festival_events fe LEFT JOIN festival_dates fd ON fe.id = fd.festival_event_id ORDER BY fe.source_key, fd.year;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT source_key, name, active, tracks_awards FROM movie_lists ORDER BY source_key;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT source_key, name, active, import_priority FROM festival_events ORDER BY import_priority DESC, name;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT source_key, COUNT(DISTINCT fc.year) AS ceremonies, COUNT(fn.id) AS total_nominations, COUNT(CASE WHEN fn.won = true THEN 1 END) AS total_wins FROM festival_events fe LEFT JOIN festival_ceremonies fc ON fe.id = fc.organization_id LEFT JOIN festival_nominations fn ON fc.id = fn.ceremony_id GROUP BY fe.source_key, fe.name ORDER BY fe.import_priority DESC;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT fo.abbreviation, COUNT(DISTINCT fc.year) AS ceremonies, COUNT(fn.id) AS total_nominations, COUNT(CASE WHEN fn.won = true THEN 1 END) AS total_wins FROM festival_organizations fo LEFT JOIN festival_ceremonies fc ON fo.id = fc.organization_id LEFT JOIN festival_nominations fn ON fc.id = fn.ceremony_id GROUP BY fo.id, fo.abbreviation ORDER BY total_nominations DESC;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\\dt\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT COUNT(*) FROM festival_ceremonies;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT COUNT(*) FROM festival_nominations;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT source_key, name, source_config FROM festival_events WHERE source_key IN (''venice'', ''cannes'', ''berlin'') ORDER BY source_key;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=3ba3f8f9 mix run -e \"\n# Test the restored database-driven festival scraper\nIO.puts(\"\"Testing database-driven festival scraper...\"\")\n\n# Test fetching Venice 2024 data  \ncase Cinegraph.Scrapers.UnifiedFestivalScraper.fetch_festival_data(\"\"venice\"\", 2024) do\n  {:ok, data} ->\n    IO.puts(\"\"âœ… Successfully fetched Venice 2024 data\"\")\n    IO.puts(\"\"Festival: #{data.festival}\"\")\n    IO.puts(\"\"Awards count: #{map_size(data.awards || %{})}\"\")\n    \n    # Show first few award categories\n    if map_size(data.awards || %{}) > 0 do\n      IO.puts(\"\"\\nFirst few categories:\"\")\n      data.awards\n      |> Enum.take(3)\n      |> Enum.each(fn {category, nominations} ->\n        IO.puts(\"\"  - #{category}: #{length(nominations)} nominations\"\")\n      end)\n    end\n    \n  {:error, reason} ->\n    IO.puts(\"\"âŒ Failed to fetch Venice data: #{inspect(reason)}\"\")\nend\n\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=3ba3f8f9 mix run -e \"\n# Test Venice festival import using the worker\nIO.puts(\"\"Testing Venice 2024 import...\"\")\n\ncase Cinegraph.Workers.VeniceFestivalWorker.queue_year(2024) do\n  {:ok, job} ->\n    IO.puts(\"\"âœ… Successfully queued Venice 2024 import job: #{job.id}\"\")\n    IO.puts(\"\"Job state: #{job.state}\"\")\n    \n  {:error, reason} ->\n    IO.puts(\"\"âŒ Failed to queue Venice import: #{inspect(reason)}\"\")\nend\n\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT COUNT(*) FROM festival_nominations;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT fn.id, fn.won, fc.year, fcat.name as category, m.title as movie FROM festival_nominations fn JOIN festival_ceremonies fc ON fn.ceremony_id = fc.id JOIN festival_categories fcat ON fn.category_id = fcat.id LEFT JOIN movies m ON fn.movie_id = m.id ORDER BY fn.id;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT fe.source_key, fe.name, COUNT(fc.id) as ceremonies, COUNT(fn.id) as nominations FROM festival_events fe LEFT JOIN festival_organizations fo ON fe.source_key = fo.abbreviation LEFT JOIN festival_ceremonies fc ON fo.id = fc.organization_id LEFT JOIN festival_nominations fn ON fc.id = fn.ceremony_id GROUP BY fe.source_key, fe.name ORDER BY nominations DESC, fe.source_key;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT fo.name, fo.abbreviation, COUNT(fc.id) as ceremonies, COUNT(fn.id) as nominations FROM festival_organizations fo LEFT JOIN festival_ceremonies fc ON fo.id = fc.organization_id LEFT JOIN festival_nominations fn ON fc.id = fn.ceremony_id GROUP BY fo.name, fo.abbreviation ORDER BY nominations DESC;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\\d festival_events\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT source_key, name, abbreviation, active, source_config->>''event_id'' as event_id FROM festival_events WHERE active = true ORDER BY source_key;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\n-- Comprehensive audit of festival data\nSELECT \n    ''Oscar Ceremonies'' as data_type,\n    COUNT(*) as count\nFROM oscar_ceremonies\n\nUNION ALL\n\nSELECT \n    ''Oscar Nominations'' as data_type,\n    COUNT(*) as count\nFROM oscar_nominations\n\nUNION ALL\n\nSELECT \n    ''Oscar Categories'' as data_type,\n    COUNT(*) as count\nFROM oscar_categories\n\nUNION ALL\n\nSELECT \n    ''Festival Organizations'' as data_type,\n    COUNT(*) as count\nFROM festival_organizations\n\nUNION ALL\n\nSELECT \n    ''Festival Ceremonies'' as data_type,\n    COUNT(*) as count\nFROM festival_ceremonies\n\nUNION ALL\n\nSELECT \n    ''Festival Nominations'' as data_type,\n    COUNT(*) as count\nFROM festival_nominations\n\nUNION ALL\n\nSELECT \n    ''Festival Categories'' as data_type,\n    COUNT(*) as count\nFROM festival_categories\n\nORDER BY data_type;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT fo.abbreviation, fc.year, fc.name, fc.scraped_at, COUNT(fn.id) as nominations FROM festival_organizations fo JOIN festival_ceremonies fc ON fo.id = fc.organization_id LEFT JOIN festival_nominations fn ON fc.id = fn.ceremony_id WHERE fc.scraped_at > NOW() - INTERVAL ''30 days'' GROUP BY fo.abbreviation, fc.year, fc.name, fc.scraped_at ORDER BY fc.scraped_at DESC LIMIT 10;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT source_key, source_config FROM festival_events WHERE source_key IN (''oscars'', ''cannes'', ''venice'') ORDER BY source_key;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"UPDATE festival_events SET source_config = ''{\"\"base_url\"\": \"\"https://www.oscars.org\"\", \"\"scraping_method\"\": \"\"html_parser\"\", \"\"ceremony_path_template\"\": \"\"/ceremonies/{year}\"\"}'' WHERE source_key = ''oscars'';\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT fo.abbreviation, fc.year, fc.data_source, fc.source_url, COUNT(fn.id) as nominations FROM festival_organizations fo JOIN festival_ceremonies fc ON fo.id = fc.organization_id LEFT JOIN festival_nominations fn ON fc.id = fn.ceremony_id WHERE fo.abbreviation = ''AMPAS'' GROUP BY fo.abbreviation, fc.year, fc.data_source, fc.source_url ORDER BY fc.year DESC LIMIT 5;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT source_key, source_config FROM festival_events WHERE source_key != ''oscars'' AND active = true ORDER BY source_key LIMIT 3;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT source_key, source_config FROM festival_events WHERE source_key <> ''oscars'' AND active = true ORDER BY source_key LIMIT 3;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\n-- Comprehensive audit of current awards data state\nSELECT ''Oscar data in structured tables'' as category, COUNT(DISTINCT nom.id) as count\nFROM oscar_nominations nom\n\nUNION ALL\n\nSELECT ''Oscar data in movies.awards JSONB'' as category, COUNT(*) as count\nFROM movies \nWHERE awards IS NOT NULL \nAND awards ? ''oscar_nominations''\n\nUNION ALL\n\nSELECT ''Cannes data in canonical_sources'' as category, COUNT(*) as count\nFROM movies \nWHERE canonical_sources ? ''cannes_winners''\n\nUNION ALL\n\nSELECT ''Venice data in canonical_sources'' as category, COUNT(*) as count\nFROM movies \nWHERE canonical_sources ? ''venice_golden_lion''\n\nUNION ALL\n\nSELECT ''Berlin data in canonical_sources'' as category, COUNT(*) as count\nFROM movies \nWHERE canonical_sources ? ''berlin_golden_bear''\n\nUNION ALL\n\nSELECT ''Cannes with extracted_awards'' as category, COUNT(*) as count\nFROM movies \nWHERE canonical_sources -> ''cannes_winners'' -> ''extracted_awards'' IS NOT NULL\n\nUNION ALL\n\nSELECT ''Venice with extracted_awards'' as category, COUNT(*) as count\nFROM movies \nWHERE canonical_sources -> ''venice_golden_lion'' -> ''extracted_awards'' IS NOT NULL\n\nUNION ALL\n\nSELECT ''Berlin with extracted_awards'' as category, COUNT(*) as count\nFROM movies \nWHERE canonical_sources -> ''berlin_golden_bear'' -> ''extracted_awards'' IS NOT NULL\n\nORDER BY category;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=3ba3f8f9 mix run -e '\n# Queue a FestivalDiscoveryWorker job for New Horizons 2024 ceremony\nalias Cinegraph.Workers.FestivalDiscoveryWorker\n\njob_args = %{\n  \"\"ceremony_id\"\" => 206,\n  \"\"source\"\" => \"\"test_fix\"\"\n}\n\ncase FestivalDiscoveryWorker.new(job_args) |> Oban.insert() do\n  {:ok, job} ->\n    IO.puts(\"\"âœ… Queued FestivalDiscoveryWorker job #{job.id} for New Horizons 2024\"\")\n    \n    # Wait for job to process\n    IO.puts(\"\"Waiting for job to process...\"\")\n    Process.sleep(15000)\n    \n    # Check nomination count\n    import Ecto.Query\n    \n    # Total nominations created\n    total_count = Cinegraph.Repo.one(\n      from n in Cinegraph.Festivals.FestivalNomination,\n      where: n.ceremony_id == 206,\n      select: count(n.id)\n    )\n    \n    # Nominations with movie_id (movie exists)\n    with_movie = Cinegraph.Repo.one(\n      from n in Cinegraph.Festivals.FestivalNomination,\n      where: n.ceremony_id == 206 and not is_nil(n.movie_id),\n      select: count(n.id)\n    )\n    \n    # Pending nominations (movie_imdb_id only)\n    pending = Cinegraph.Repo.one(\n      from n in Cinegraph.Festivals.FestivalNomination,\n      where: n.ceremony_id == 206 and is_nil(n.movie_id) and not is_nil(n.movie_imdb_id),\n      select: count(n.id)\n    )\n    \n    IO.puts(\"\"\\n=== Results After First Import ===\"\"\n    IO.puts(\"\"Total nominations created: #{total_count}\"\")\n    IO.puts(\"\"Nominations with existing movies: #{with_movie}\"\")\n    IO.puts(\"\"Pending nominations (movie not yet created): #{pending}\"\")\n    \n    # Check if we have 9 nominations like before\n    if total_count >= 9 do\n      IO.puts(\"\"\\nâœ… SUCCESS! All #{total_count} nominations were created on first run!\"\")\n      IO.puts(\"\"The fix is working - nominations are no longer lost when movies dont exist yet.\"\")\n    else\n      IO.puts(\"\"\\nâš ï¸  Only #{total_count} nominations created, expected at least 9\"\")\n    end\n    \n    # Check TMDb jobs queued\n    tmdb_jobs = Cinegraph.Repo.one(\n      from j in Oban.Job,\n      where: j.worker == \"\"Cinegraph.Workers.TMDbDetailsWorker\"\" and j.state in [\"\"available\"\", \"\"executing\"\"],\n      select: count(j.id)\n    )\n    \n    IO.puts(\"\"\\nTMDb jobs queued/running: #{tmdb_jobs}\"\")\n    \n  {:error, reason} ->\n    IO.puts(\"\"âŒ Failed to queue job: #{inspect(reason)}\"\")\nend\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=3ba3f8f9 mix run -e '\n# Queue a FestivalDiscoveryWorker job for New Horizons 2024 ceremony\nalias Cinegraph.Workers.FestivalDiscoveryWorker\n\njob_args = %{\n  \"\"ceremony_id\"\" => 206,\n  \"\"source\"\" => \"\"test_fix\"\"\n}\n\ncase FestivalDiscoveryWorker.new(job_args) |> Oban.insert() do\n  {:ok, job} ->\n    IO.puts(\"\"âœ… Queued FestivalDiscoveryWorker job #{job.id} for New Horizons 2024\"\")\n    \n    # Wait for job to process\n    IO.puts(\"\"Waiting for job to process...\"\")\n    Process.sleep(15000)\n    \n    # Check nomination count\n    import Ecto.Query\n    \n    # Total nominations created\n    total_count = Cinegraph.Repo.one(\n      from n in Cinegraph.Festivals.FestivalNomination,\n      where: n.ceremony_id == 206,\n      select: count(n.id)\n    )\n    \n    # Nominations with movie_id (movie exists)\n    with_movie = Cinegraph.Repo.one(\n      from n in Cinegraph.Festivals.FestivalNomination,\n      where: n.ceremony_id == 206 and not is_nil(n.movie_id),\n      select: count(n.id)\n    )\n    \n    # Pending nominations (movie_imdb_id only)\n    pending = Cinegraph.Repo.one(\n      from n in Cinegraph.Festivals.FestivalNomination,\n      where: n.ceremony_id == 206 and is_nil(n.movie_id) and not is_nil(n.movie_imdb_id),\n      select: count(n.id)\n    )\n    \n    IO.puts(\"\"\\\\n=== Results After First Import ===\"\")\n    IO.puts(\"\"Total nominations created: #{total_count}\"\")\n    IO.puts(\"\"Nominations with existing movies: #{with_movie}\"\")\n    IO.puts(\"\"Pending nominations (movie not yet created): #{pending}\"\")\n    \n    # Check if we have 9 nominations like before\n    if total_count >= 9 do\n      IO.puts(\"\"\\\\nâœ… SUCCESS! All #{total_count} nominations were created on first run!\"\")\n      IO.puts(\"\"The fix is working - nominations are no longer lost when movies dont exist yet.\"\")\n    else\n      IO.puts(\"\"\\\\nâš ï¸  Only #{total_count} nominations created, expected at least 9\"\")\n    end\n    \n    # Check TMDb jobs queued\n    tmdb_jobs = Cinegraph.Repo.one(\n      from j in Oban.Job,\n      where: j.worker == \"\"Cinegraph.Workers.TMDbDetailsWorker\"\" and j.state in [\"\"available\"\", \"\"executing\"\"],\n      select: count(j.id)\n    )\n    \n    IO.puts(\"\"\\\\nTMDb jobs queued/running: #{tmdb_jobs}\"\")\n    \n  {:error, reason} ->\n    IO.puts(\"\"âŒ Failed to queue job: #{inspect(reason)}\"\")\nend\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=3ba3f8f9 mix run -e '\n# Retry the failed job\nimport Ecto.Query\n\n# Get the failed job\njob = Cinegraph.Repo.get(Oban.Job, 60119)\n\nif job do\n  # Update state to available to retry\n  job\n  |> Ecto.Changeset.change(%{state: \"\"available\"\", attempt: 0, errors: nil})\n  |> Cinegraph.Repo.update()\n  \n  IO.puts(\"\"Job 60119 reset for retry\"\")\n  \n  # Wait for it to process\n  Process.sleep(15000)\n  \n  # Check results\n  total_count = Cinegraph.Repo.one(\n    from n in Cinegraph.Festivals.FestivalNomination,\n    where: n.ceremony_id == 206,\n    select: count(n.id)\n  )\n  \n  with_movie = Cinegraph.Repo.one(\n    from n in Cinegraph.Festivals.FestivalNomination,\n    where: n.ceremony_id == 206 and not is_nil(n.movie_id),\n    select: count(n.id)\n  )\n  \n  pending = Cinegraph.Repo.one(\n    from n in Cinegraph.Festivals.FestivalNomination,\n    where: n.ceremony_id == 206 and is_nil(n.movie_id) and not is_nil(n.movie_imdb_id),\n    select: count(n.id)\n  )\n  \n  IO.puts(\"\"\\\\n=== Results After Fix ===\"\")\n  IO.puts(\"\"Total nominations: #{total_count}\"\")\n  IO.puts(\"\"With existing movies: #{with_movie}\"\")\n  IO.puts(\"\"Pending (waiting for movie creation): #{pending}\"\")\n  \n  if total_count >= 9 do\n    IO.puts(\"\"\\\\nâœ… SUCCESS! All nominations captured on first run!\"\")\n  end\nelse\n  IO.puts(\"\"Job not found\"\")\nend\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=3ba3f8f9 mix run -e '\n# Clear the nominations and re-run fresh\nimport Ecto.Query\n\n# Clear existing nominations for ceremony 206\nCinegraph.Repo.delete_all(\n  from n in Cinegraph.Festivals.FestivalNomination,\n  where: n.ceremony_id == 206\n)\n\nIO.puts(\"\"Cleared existing nominations for ceremony 206\"\")\n\n# Queue a new job\nalias Cinegraph.Workers.FestivalDiscoveryWorker\n\njob_args = %{\n  \"\"ceremony_id\"\" => 206,\n  \"\"source\"\" => \"\"test_fix_v2\"\"\n}\n\ncase FestivalDiscoveryWorker.new(job_args) |> Oban.insert() do\n  {:ok, job} ->\n    IO.puts(\"\"âœ… Queued new FestivalDiscoveryWorker job #{job.id}\"\")\n    \n    # Wait for processing\n    Process.sleep(15000)\n    \n    # Check results\n    total_count = Cinegraph.Repo.one(\n      from n in Cinegraph.Festivals.FestivalNomination,\n      where: n.ceremony_id == 206,\n      select: count(n.id)\n    )\n    \n    with_movie = Cinegraph.Repo.one(\n      from n in Cinegraph.Festivals.FestivalNomination,\n      where: n.ceremony_id == 206 and not is_nil(n.movie_id),\n      select: count(n.id)\n    )\n    \n    pending = Cinegraph.Repo.one(\n      from n in Cinegraph.Festivals.FestivalNomination,\n      where: n.ceremony_id == 206 and is_nil(n.movie_id) and not is_nil(n.movie_imdb_id),\n      select: count(n.id)\n    )\n    \n    IO.puts(\"\"\\\\n=== Final Results After Fix ===\"\")\n    IO.puts(\"\"Total nominations: #{total_count}\"\")\n    IO.puts(\"\"With existing movies: #{with_movie}\"\")\n    IO.puts(\"\"Pending (waiting for movie creation): #{pending}\"\")\n    \n    if total_count >= 9 do\n      IO.puts(\"\"\\\\nâœ… SUCCESS! All #{total_count} nominations captured on first run!\"\")\n      IO.puts(\"\"The fix is working - nominations are created even when movies dont exist yet.\"\")\n    else\n      IO.puts(\"\"\\\\nâš ï¸  Only #{total_count} nominations created, expected at least 9\"\")\n    end\n    \n  {:error, reason} ->\n    IO.puts(\"\"âŒ Failed to queue job: #{inspect(reason)}\"\")\nend\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\n-- Check current state of festival nominations with person data\nSELECT \n    ''Total Person Nominations'' as metric,\n    COUNT(*) as count\nFROM festival_nominations fn\nJOIN festival_categories fc ON fn.category_id = fc.id\nWHERE fc.tracks_person = true\n\nUNION ALL\n\nSELECT \n    ''With person_id linked'' as metric,\n    COUNT(*) as count\nFROM festival_nominations fn\nJOIN festival_categories fc ON fn.category_id = fc.id\nWHERE fc.tracks_person = true AND fn.person_id IS NOT NULL\n\nUNION ALL\n\nSELECT \n    ''With person_imdb_ids (pending)'' as metric,\n    COUNT(*) as count\nFROM festival_nominations fn\nJOIN festival_categories fc ON fn.category_id = fc.id\nWHERE fc.tracks_person = true AND array_length(fn.person_imdb_ids, 1) > 0\n\nUNION ALL\n\nSELECT \n    ''With person_name stored'' as metric,\n    COUNT(*) as count\nFROM festival_nominations fn\nJOIN festival_categories fc ON fn.category_id = fc.id\nWHERE fc.tracks_person = true AND fn.person_name IS NOT NULL\n\nORDER BY metric;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\n-- Clear existing Oscar nominations for a clean test\nDELETE FROM festival_nominations \nWHERE ceremony_id IN (\n  SELECT fc.id \n  FROM festival_ceremonies fc\n  JOIN festival_organizations fo ON fc.organization_id = fo.id\n  WHERE fo.abbreviation = ''AMPAS''\n);\n\n-- Check the count after deletion\nSELECT COUNT(*) as deleted_count FROM festival_nominations \nWHERE ceremony_id IN (\n  SELECT fc.id \n  FROM festival_ceremonies fc\n  JOIN festival_organizations fo ON fc.organization_id = fo.id\n  WHERE fo.abbreviation = ''AMPAS''\n);\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=3ba3f8f9 mix run -e 'result = Cinegraph.Cultural.import_oscar_years(2024..2024); IO.inspect(result, label: \"\"Oscar Import Result\"\")')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=3ba3f8f9 mix run -e 'result = Cinegraph.Cultural.import_oscar_years(2024..2024); IO.inspect(result, label: \"\"First Oscar Import Result\"\")')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\n-- Check People Nominations count after first import\nSELECT \n    ''Total Nominations'' as metric,\n    COUNT(*) as count\nFROM festival_nominations fn\nJOIN festival_ceremonies fc ON fn.ceremony_id = fc.id\nJOIN festival_organizations fo ON fc.organization_id = fo.id\nWHERE fo.abbreviation = ''AMPAS'' AND fc.year = 2024\n\nUNION ALL\n\nSELECT \n    ''People Nominations'' as metric,\n    COUNT(*) as count\nFROM festival_nominations fn\nJOIN festival_categories fcat ON fn.category_id = fcat.id\nJOIN festival_ceremonies fc ON fn.ceremony_id = fc.id\nJOIN festival_organizations fo ON fc.organization_id = fo.id\nWHERE fo.abbreviation = ''AMPAS'' AND fc.year = 2024 AND fcat.tracks_person = true\n\nUNION ALL\n\nSELECT \n    ''Film Nominations'' as metric,\n    COUNT(*) as count\nFROM festival_nominations fn\nJOIN festival_categories fcat ON fn.category_id = fcat.id\nJOIN festival_ceremonies fc ON fn.ceremony_id = fc.id\nJOIN festival_organizations fo ON fc.organization_id = fo.id\nWHERE fo.abbreviation = ''AMPAS'' AND fc.year = 2024 AND fcat.tracks_person = false\n\nORDER BY metric;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\nSELECT \n    worker,\n    state,\n    COUNT(*) as count\nFROM oban_jobs \nWHERE worker IN (''Cinegraph.Workers.UnifiedFestivalWorker'', ''Cinegraph.Workers.FestivalDiscoveryWorker'')\nAND state IN (''available'', ''executing'', ''retryable'')\nGROUP BY worker, state\nORDER BY worker, state;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\nSELECT \n    fc.id,\n    fc.year,\n    fo.abbreviation,\n    fc.data IS NOT NULL as has_data\nFROM festival_ceremonies fc\nJOIN festival_organizations fo ON fc.organization_id = fo.id\nWHERE fo.abbreviation = ''AMPAS'' AND fc.year = 2024;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=3ba3f8f9 mix run -e '\n# Manually trigger FestivalDiscoveryWorker for Oscar 2024 ceremony\nalias Cinegraph.Workers.FestivalDiscoveryWorker\n\njob_args = %{\n  \"\"ceremony_id\"\" => 236,\n  \"\"source\"\" => \"\"test_duplicate_fix\"\"\n}\n\ncase FestivalDiscoveryWorker.new(job_args) |> Oban.insert() do\n  {:ok, job} ->\n    IO.puts(\"\"âœ… Queued FestivalDiscoveryWorker job #{job.id} for Oscar 2024 ceremony\"\")\n    \n    # Wait for processing\n    Process.sleep(10000)\n    \n    # Check nomination counts\n    import Ecto.Query\n    \n    total_count = Cinegraph.Repo.one(\n      from n in Cinegraph.Festivals.FestivalNomination,\n      where: n.ceremony_id == 236,\n      select: count(n.id)\n    )\n    \n    people_count = Cinegraph.Repo.one(\n      from n in Cinegraph.Festivals.FestivalNomination,\n      join: c in Cinegraph.Festivals.FestivalCategory, on: n.category_id == c.id,\n      where: n.ceremony_id == 236 and c.tracks_person == true,\n      select: count(n.id)\n    )\n    \n    film_count = Cinegraph.Repo.one(\n      from n in Cinegraph.Festivals.FestivalNomination,\n      join: c in Cinegraph.Festivals.FestivalCategory, on: n.category_id == c.id,\n      where: n.ceremony_id == 236 and c.tracks_person == false,\n      select: count(n.id)\n    )\n    \n    IO.puts(\"\"\\n=== First Import Results ===\"\")\n    IO.puts(\"\"Total nominations: #{total_count}\"\")\n    IO.puts(\"\"People nominations: #{people_count}\"\")\n    IO.puts(\"\"Film nominations: #{film_count}\"\")\n    \n  {:error, reason} ->\n    IO.puts(\"\"âŒ Failed to queue job: #{inspect(reason)}\"\")\nend')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\nSELECT \n    id,\n    state,\n    attempt,\n    errors\nFROM oban_jobs \nWHERE id = 64999;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=3ba3f8f9 mix run -e '\n# Manually trigger FestivalDiscoveryWorker for Oscar 2024 ceremony - first run\nalias Cinegraph.Workers.FestivalDiscoveryWorker\n\njob_args = %{\n  \"\"ceremony_id\"\" => 236,\n  \"\"source\"\" => \"\"test_duplicate_fix_v2\"\"\n}\n\ncase FestivalDiscoveryWorker.new(job_args) |> Oban.insert() do\n  {:ok, job} ->\n    IO.puts(\"\"âœ… Queued FestivalDiscoveryWorker job #{job.id} for Oscar 2024 ceremony (first run)\"\")\n    \n    # Wait for processing\n    Process.sleep(15000)\n    \n    # Check nomination counts\n    import Ecto.Query\n    \n    total_count = Cinegraph.Repo.one(\n      from n in Cinegraph.Festivals.FestivalNomination,\n      where: n.ceremony_id == 236,\n      select: count(n.id)\n    )\n    \n    people_count = Cinegraph.Repo.one(\n      from n in Cinegraph.Festivals.FestivalNomination,\n      join: c in Cinegraph.Festivals.FestivalCategory, on: n.category_id == c.id,\n      where: n.ceremony_id == 236 and c.tracks_person == true,\n      select: count(n.id)\n    )\n    \n    film_count = Cinegraph.Repo.one(\n      from n in Cinegraph.Festivals.FestivalNomination,\n      join: c in Cinegraph.Festivals.FestivalCategory, on: n.category_id == c.id,\n      where: n.ceremony_id == 236 and c.tracks_person == false,\n      select: count(n.id)\n    )\n    \n    IO.puts(\"\"\\n=== First Import Results ===\"\")\n    IO.puts(\"\"Total nominations: #{total_count}\"\")\n    IO.puts(\"\"People nominations: #{people_count}\"\")\n    IO.puts(\"\"Film nominations: #{film_count}\"\")\n    \n  {:error, reason} ->\n    IO.puts(\"\"âŒ Failed to queue job: #{inspect(reason)}\"\")\nend')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=3ba3f8f9 mix run -e '\n# Manually trigger FestivalDiscoveryWorker for Oscar 2024 ceremony - second run\nalias Cinegraph.Workers.FestivalDiscoveryWorker\n\njob_args = %{\n  \"\"ceremony_id\"\" => 236,\n  \"\"source\"\" => \"\"test_duplicate_fix_second_run\"\"\n}\n\ncase FestivalDiscoveryWorker.new(job_args) |> Oban.insert() do\n  {:ok, job} ->\n    IO.puts(\"\"âœ… Queued FestivalDiscoveryWorker job #{job.id} for Oscar 2024 ceremony (SECOND RUN)\"\")\n    \n    # Wait for processing\n    Process.sleep(15000)\n    \n    # Check nomination counts\n    import Ecto.Query\n    \n    total_count = Cinegraph.Repo.one(\n      from n in Cinegraph.Festivals.FestivalNomination,\n      where: n.ceremony_id == 236,\n      select: count(n.id)\n    )\n    \n    people_count = Cinegraph.Repo.one(\n      from n in Cinegraph.Festivals.FestivalNomination,\n      join: c in Cinegraph.Festivals.FestivalCategory, on: n.category_id == c.id,\n      where: n.ceremony_id == 236 and c.tracks_person == true,\n      select: count(n.id)\n    )\n    \n    film_count = Cinegraph.Repo.one(\n      from n in Cinegraph.Festivals.FestivalNomination,\n      join: c in Cinegraph.Festivals.FestivalCategory, on: n.category_id == c.id,\n      where: n.ceremony_id == 236 and c.tracks_person == false,\n      select: count(n.id)\n    )\n    \n    IO.puts(\"\"\\n=== SECOND Import Results ===\"\")\n    IO.puts(\"\"Total nominations: #{total_count}\"\")\n    IO.puts(\"\"People nominations: #{people_count}\"\")\n    IO.puts(\"\"Film nominations: #{film_count}\"\")\n    \n    if people_count == 44 do\n      IO.puts(\"\"\\nâœ… SUCCESS! People nominations count remained at 44 - duplicate bug is FIXED!\"\")\n    else\n      IO.puts(\"\"\\nâš ï¸ WARNING: People nominations changed from 44 to #{people_count}\"\")\n    end\n    \n  {:error, reason} ->\n    IO.puts(\"\"âŒ Failed to queue job: #{inspect(reason)}\"\")\nend')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\n-- Final verification of the fix\nSELECT \n    ''Total Oscar 2024 Nominations'' as metric,\n    COUNT(*) as count\nFROM festival_nominations fn\nJOIN festival_ceremonies fc ON fn.ceremony_id = fc.id\nJOIN festival_organizations fo ON fc.organization_id = fo.id\nWHERE fo.abbreviation = ''AMPAS'' AND fc.year = 2024\n\nUNION ALL\n\nSELECT \n    ''People Nominations (Fixed!)'' as metric,\n    COUNT(*) as count\nFROM festival_nominations fn\nJOIN festival_categories fcat ON fn.category_id = fcat.id\nJOIN festival_ceremonies fc ON fn.ceremony_id = fc.id\nJOIN festival_organizations fo ON fc.organization_id = fo.id\nWHERE fo.abbreviation = ''AMPAS'' AND fc.year = 2024 AND fcat.tracks_person = true\n\nUNION ALL\n\nSELECT \n    ''Film Nominations'' as metric,\n    COUNT(*) as count\nFROM festival_nominations fn\nJOIN festival_categories fcat ON fn.category_id = fcat.id\nJOIN festival_ceremonies fc ON fn.ceremony_id = fc.id\nJOIN festival_organizations fo ON fc.organization_id = fo.id\nWHERE fo.abbreviation = ''AMPAS'' AND fc.year = 2024 AND fcat.tracks_person = false\n\nORDER BY metric DESC;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\n-- Check current Oscar 2024 nomination counts\nSELECT \n    ''Total Nominations'' as metric,\n    COUNT(*) as count\nFROM festival_nominations fn\nJOIN festival_ceremonies fc ON fn.ceremony_id = fc.id\nJOIN festival_organizations fo ON fc.organization_id = fo.id\nWHERE fo.abbreviation = ''AMPAS'' AND fc.year = 2024\n\nUNION ALL\n\nSELECT \n    ''People Nominations'' as metric,\n    COUNT(*) as count\nFROM festival_nominations fn\nJOIN festival_categories fcat ON fn.category_id = fcat.id\nJOIN festival_ceremonies fc ON fn.ceremony_id = fc.id\nJOIN festival_organizations fo ON fc.organization_id = fo.id\nWHERE fo.abbreviation = ''AMPAS'' AND fc.year = 2024 AND fcat.tracks_person = true\n\nUNION ALL\n\nSELECT \n    ''Film Nominations'' as metric,\n    COUNT(*) as count\nFROM festival_nominations fn\nJOIN festival_categories fcat ON fn.category_id = fcat.id\nJOIN festival_ceremonies fc ON fn.ceremony_id = fc.id\nJOIN festival_organizations fo ON fc.organization_id = fo.id\nWHERE fo.abbreviation = ''AMPAS'' AND fc.year = 2024 AND fcat.tracks_person = false\n\nUNION ALL\n\nSELECT \n    ''Categories Used'' as metric,\n    COUNT(DISTINCT fcat.id) as count\nFROM festival_nominations fn\nJOIN festival_categories fcat ON fn.category_id = fcat.id\nJOIN festival_ceremonies fc ON fn.ceremony_id = fc.id\nJOIN festival_organizations fo ON fc.organization_id = fo.id\nWHERE fo.abbreviation = ''AMPAS'' AND fc.year = 2024\n\nORDER BY metric;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\n-- Get current counts before test\nSELECT \n    ''Total Nominations'' as metric,\n    COUNT(*) as count\nFROM festival_nominations fn\nJOIN festival_ceremonies fc ON fn.ceremony_id = fc.id\nJOIN festival_organizations fo ON fc.organization_id = fo.id\nWHERE fo.abbreviation = ''AMPAS'' AND fc.year = 2024\n\nUNION ALL\n\nSELECT \n    ''People Nominations'' as metric,\n    COUNT(*) as count\nFROM festival_nominations fn\nJOIN festival_categories fcat ON fn.category_id = fcat.id\nJOIN festival_ceremonies fc ON fn.ceremony_id = fc.id\nJOIN festival_organizations fo ON fc.organization_id = fo.id\nWHERE fo.abbreviation = ''AMPAS'' AND fc.year = 2024 AND fcat.tracks_person = true\n\nORDER BY metric;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=3ba3f8f9 mix run -e '\n# Manually trigger FestivalDiscoveryWorker for Oscar 2024 ceremony\nalias Cinegraph.Workers.FestivalDiscoveryWorker\n\n# Get the ceremony ID\nimport Ecto.Query\nceremony = Cinegraph.Repo.one(\n  from fc in Cinegraph.Festivals.FestivalCeremony,\n  join: fo in Cinegraph.Festivals.FestivalOrganization, on: fc.organization_id == fo.id,\n  where: fo.abbreviation == \"\"AMPAS\"\" and fc.year == 2024,\n  select: fc\n)\n\nif ceremony do\n  job_args = %{\n    \"\"ceremony_id\"\" => ceremony.id,\n    \"\"source\"\" => \"\"test_duplicate_fix_v3\"\"\n  }\n\n  case FestivalDiscoveryWorker.new(job_args) |> Oban.insert() do\n    {:ok, job} ->\n      IO.puts(\"\"âœ… Queued FestivalDiscoveryWorker job #{job.id} for Oscar 2024 ceremony (testing duplicate fix)\"\")\n      \n      # Wait for processing\n      Process.sleep(15000)\n      \n      # Check nomination counts\n      total_count = Cinegraph.Repo.one(\n        from n in Cinegraph.Festivals.FestivalNomination,\n        where: n.ceremony_id == ^ceremony.id,\n        select: count(n.id)\n      )\n      \n      people_count = Cinegraph.Repo.one(\n        from n in Cinegraph.Festivals.FestivalNomination,\n        join: c in Cinegraph.Festivals.FestivalCategory, on: n.category_id == c.id,\n        where: n.ceremony_id == ^ceremony.id and c.tracks_person == true,\n        select: count(n.id)\n      )\n      \n      film_count = Cinegraph.Repo.one(\n        from n in Cinegraph.Festivals.FestivalNomination,\n        join: c in Cinegraph.Festivals.FestivalCategory, on: n.category_id == c.id,\n        where: n.ceremony_id == ^ceremony.id and c.tracks_person == false,\n        select: count(n.id)\n      )\n      \n      IO.puts(\"\"\\n=== After Re-import Results ===\"\")\n      IO.puts(\"\"Total nominations: #{total_count}\"\")\n      IO.puts(\"\"People nominations: #{people_count}\"\")\n      IO.puts(\"\"Film nominations: #{film_count}\"\")\n      \n      if people_count == 44 do\n        IO.puts(\"\"\\nâœ… SUCCESS! People nominations count remained at 44 - duplicate bug is FIXED!\"\")\n      else\n        IO.puts(\"\"\\nâš ï¸ WARNING: People nominations changed from 44 to #{people_count}\"\")\n      end\n      \n    {:error, reason} ->\n      IO.puts(\"\"âŒ Failed to queue job: #{inspect(reason)}\"\")\n  end\nelse\n  IO.puts(\"\"Oscar 2024 ceremony not found\"\")\nend\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=3ba3f8f9 mix run -e '\n# Run it again to triple-check\nalias Cinegraph.Workers.FestivalDiscoveryWorker\n\nimport Ecto.Query\nceremony = Cinegraph.Repo.one(\n  from fc in Cinegraph.Festivals.FestivalCeremony,\n  join: fo in Cinegraph.Festivals.FestivalOrganization, on: fc.organization_id == fo.id,\n  where: fo.abbreviation == \"\"AMPAS\"\" and fc.year == 2024,\n  select: fc\n)\n\nif ceremony do\n  job_args = %{\n    \"\"ceremony_id\"\" => ceremony.id,\n    \"\"source\"\" => \"\"test_duplicate_fix_third_run\"\"\n  }\n\n  case FestivalDiscoveryWorker.new(job_args) |> Oban.insert() do\n    {:ok, job} ->\n      IO.puts(\"\"âœ… Queued FestivalDiscoveryWorker job #{job.id} for third test run\"\")\n      \n      # Wait for processing\n      Process.sleep(15000)\n      \n      # Check nomination counts\n      people_count = Cinegraph.Repo.one(\n        from n in Cinegraph.Festivals.FestivalNomination,\n        join: c in Cinegraph.Festivals.FestivalCategory, on: n.category_id == c.id,\n        where: n.ceremony_id == ^ceremony.id and c.tracks_person == true,\n        select: count(n.id)\n      )\n      \n      IO.puts(\"\"\\n=== Third Run Results ===\"\")\n      IO.puts(\"\"People nominations: #{people_count}\"\")\n      \n      if people_count == 44 do\n        IO.puts(\"\"âœ… CONFIRMED: Duplicate bug is completely FIXED!\"\")\n      else\n        IO.puts(\"\"âš ï¸ Issue still present: #{people_count}\"\")\n      end\n      \n    {:error, reason} ->\n      IO.puts(\"\"âŒ Failed to queue job: #{inspect(reason)}\"\")\n  end\nend\n')",
      "WebFetch(domain:en.wikipedia.org)",
      "Bash(--title \"2024 Academy Awards Baseline Data Analysis - Expected Database Metrics\" )",
      "Bash(--body-file OSCARS_2024_BASELINE_ANALYSIS.md )",
      "Bash(--label \"documentation,analysis,awards-data\" )",
      "Bash(--assignee @me)",
      "Bash(--title \"2024 Academy Awards Baseline Data Analysis - Expected Database Metrics\" )",
      "Bash(--body-file OSCARS_2024_BASELINE_ANALYSIS.md )",
      "Bash(--label \"documentation\" )",
      "Bash(git pull:*)",
      "Bash(git restore:*)",
      "Bash(./check_video_constraints.exs)",
      "WebFetch(domain:www.jsdelivr.com)"
    ],
    "deny": []
  }
}