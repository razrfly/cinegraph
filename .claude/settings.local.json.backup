{
  "permissions": {
    "allow": [
      "Bash(gh issue create:*)",
      "Bash(find:*)",
      "Bash(mkdir:*)",
      "Bash(gh issue:*)",
      "Bash(gh repo view:*)",
      "Bash(ls:*)",
      "Bash(env)",
      "WebFetch(domain:docs.anthropic.com)",
      "Bash(elixir:*)",
      "Bash(mix:*)",
      "Bash(npx:*)",
      "Bash(node:*)",
      "Bash(npm:*)",
      "Bash(/doctor)",
      "Bash(rm:*)",
      "Bash(source .env)",
      "Bash(echo:*)",
      "Bash(TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 mix run -e \"Cinegraph.Services.TMDb.test_connection()\")",
      "Bash(TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 mix run -e \"Cinegraph.Services.TMDb.explore_movie(550)\")",
      "Bash(TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 mix run -e \"\n{:ok, results} = Cinegraph.Services.TMDb.search_movies(\"\"Inception\"\")\nIO.puts(\"\"\\n🔍 Search Results for ''Inception'':\"\")\nIO.puts(\"\"Total results: #{results[\"\"total_results\"\"]}\"\")\nIO.puts(\"\"\\nFirst 3 movies:\"\")\nresults[\"\"results\"\"] |> Enum.take(3) |> Enum.each(fn movie ->\n  IO.puts(\"\"- #{movie[\"\"title\"\"]} (#{movie[\"\"release_date\"\"]}) - ID: #{movie[\"\"id\"\"]}\"\")\nend)\n\")",
      "Bash(TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 mix run -e \"\n# Fetch different types of movies to understand data variations\nmovie_ids = [550, 27205, 238, 278, 680]  # Fight Club, Inception, Godfather, Shawshank, Pulp Fiction\n\nIO.puts(\"\"\\n📊 Analyzing TMDb Data Patterns\"\")\nIO.puts(\"\"=\"\" <> String.duplicate(\"\"=\"\", 50))\n\nEnum.each(movie_ids, fn id ->\n  case Cinegraph.Services.TMDb.get_movie(id) do\n    {:ok, movie} ->\n      IO.puts(\"\"\\n#{movie[\"\"title\"\"]} (#{movie[\"\"release_date\"\"]})\"\")\n      IO.puts(\"\"  Genres: #{movie[\"\"genres\"\"] |> Enum.map(&(&1[\"\"name\"\"])) |> Enum.join(\"\", \"\")}\"\")\n      IO.puts(\"\"  Vote: #{movie[\"\"vote_average\"\"]}/10 (#{movie[\"\"vote_count\"\"]} votes)\"\")\n      IO.puts(\"\"  Budget: $#movie[\"\"budget\"\"] |> Number.Delimit.number_to_delimited()}\"\")\n      IO.puts(\"\"  Revenue: $#movie[\"\"revenue\"\"] |> Number.Delimit.number_to_delimited()}\"\")\n      \n    {:error, _} ->\n      IO.puts(\"\"Error fetching movie #{id}\"\")\n  end\nend)\n\")",
      "Bash(TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 mix run -e \"\n# Fetch different types of movies to understand data variations\nmovie_ids = [550, 27205, 238, 278, 680]  # Fight Club, Inception, Godfather, Shawshank, Pulp Fiction\n\nIO.puts(\"\"\\n📊 Analyzing TMDb Data Patterns\"\")\nIO.puts(\"\"=\"\" <> String.duplicate(\"\"=\"\", 50))\n\nEnum.each(movie_ids, fn id ->\n  case Cinegraph.Services.TMDb.get_movie(id) do\n    {:ok, movie} ->\n      IO.puts(\"\"\\n#{movie[\"\"title\"\"]} (#{movie[\"\"release_date\"\"]})\"\")\n      IO.puts(\"\"  Genres: #{movie[\"\"genres\"\"] |> Enum.map(&(&1[\"\"name\"\"])) |> Enum.join(\"\", \"\")}\"\")\n      IO.puts(\"\"  Vote: #{movie[\"\"vote_average\"\"]}/10 (#{movie[\"\"vote_count\"\"]} votes)\"\")\n      IO.puts(\"\"  Budget: #{movie[\"\"budget\"\"]}\"\")\n      IO.puts(\"\"  Revenue: #{movie[\"\"revenue\"\"]}\"\")\n      IO.puts(\"\"  Runtime: #{movie[\"\"runtime\"\"]} minutes\"\")\n      IO.puts(\"\"  Production Countries: #{movie[\"\"production_countries\"\"] |> Enum.map(&(&1[\"\"name\"\"])) |> Enum.join(\"\", \"\")}\"\")\n      \n    {:error, _} ->\n      IO.puts(\"\"Error fetching movie #{id}\"\")\n  end\nend)\n\")",
      "WebFetch(domain:developer.themoviedb.org)",
      "WebFetch(domain:github.com)",
      "Bash(export TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8)",
      "Bash(grep:*)",
      "Bash(export TMDB_API_KEY)",
      "Bash(export SUPABASE_DATABASE_URL)",
      "Bash(psql:*)",
      "Bash(git rm:*)",
      "mcp__context7__resolve-library-id",
      "mcp__context7__get-library-docs",
      "Bash(git add:*)",
      "Bash(git commit:*)",
      "mcp__playwright__browser_navigate",
      "Bash(pkill:*)",
      "mcp__playwright__browser_take_screenshot",
      "mcp__playwright__browser_click",
      "mcp__playwright__browser_snapshot",
      "mcp__playwright__browser_close",
      "mcp__playwright__browser_evaluate",
      "Bash(test:*)",
      "Bash(true)",
      "Bash(MIX_ENV=dev mix run populate_real_movies.exs)",
      "mcp__playwright__browser_navigate_back",
      "Bash(MIX_ENV=dev mix run -e \"IO.inspect Cinegraph.Cultural.list_authorities(), label: ''Authorities''\")",
      "Bash(MIX_ENV=dev mix run -e \"Cinegraph.Cultural.seed_authorities()\")",
      "Bash(MIX_ENV=dev mix run fetch_sample_awards.exs)",
      "Bash(MIX_ENV=dev mix compile)",
      "Bash(MIX_ENV=dev mix run test_award_fetch.exs)",
      "Bash(MIX_ENV=dev mix run audit_tmdb_data.exs)",
      "Bash(MIX_ENV=dev mix run test_ultra_fetch.exs)",
      "Bash(MIX_ENV=dev mix run test_data_output.exs)",
      "Bash(MIX_ENV=dev mix run examine_reviews_and_lists.exs)",
      "Bash(MIX_ENV=dev mix run test_aggregate_metrics.exs)",
      "Bash(MIX_ENV=dev mix run -e 'IO.inspect Cinegraph.ExternalSources.get_movie_ratings(23), label: \"\"Ratings\"\", pretty: true')",
      "WebFetch(domain:www.omdbapi.com)",
      "WebFetch(domain:omdbpy.readthedocs.io)",
      "Bash(export OMDB_API_KEY=e291bc36)",
      "Bash(iex:*)",
      "mcp__playwright__browser_navigate",
      "mcp__playwright__browser_close",
      "Bash(pkill:*)",
      "Bash(curl:*)",
      "mcp__playwright__browser_take_screenshot",
      "mcp__playwright__browser_evaluate",
      "Bash(OMDB_API_KEY=e291bc36 mix import_movies --enrich)",
      "Bash(Single entry point for all movie imports.)",
      "Bash(Fetches from TMDb and enriches with OMDb data.)",
      "Bash(\"\"\"\n  \n  def import_movies(count: 100) do\n    # 1. Fetch from TMDb (paginated)\n    # 2. For each movie:\n    #    a. Create/update movie record\n    #    b. Store credits\n    #    c. Store keywords (WITH junction table)\n    #    d. Store videos\n    #    e. Store release dates\n    #    f. Store production companies (WITH junction table)\n    #    g. Extract IMDb ID\n    #    h. If IMDb ID exists, fetch OMDb data\n    #    i. Store all ratings\n    #    j. Store enhanced metadata\n    # 3. Return import stats\n  end\n  \n  def import_trending do\n    # Daily job to fetch trending movies\n  end\n  \n  def import_upcoming do\n    # Weekly job to fetch upcoming releases\n  end\nend\n```\n\n## Benefits of Cleanup\n\n1. **Simpler Schema**: Remove 6 unused tables (~26% reduction)\n2. **Better Data Utilization**: Store 100% of fetched data\n3. **Clearer Purpose**: Each table has a clear role\n4. **Future-Ready**: Keep tables needed for planned features (CRI, curated lists)\n5. **Performance**: Less complexity = faster queries\n\n## Action Items\n\n- [ ] Create migration to drop unused tables\n- [ ] Fix junction table population in importers\n- [ ] Update comprehensive importer to extract all fetched data\n- [ ] Add trending/upcoming movie importers\n- [ ] Document which tables are for future features\n- [ ] Update README with current schema documentation\n\n## Questions to Resolve\n\n1. Should we keep alternative_titles and translations tables, or just store in movie JSON?\n2. Do we want to track temporal data (movie_data_changes) in the future?\n3. Should we implement the cultural authority system, or simplify to just awards?\n\n/cc @razrfly\nEOF\n)\")",
      "mcp__context7__resolve-library-id",
      "mcp__context7__get-library-docs",
      "Bash(TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=e291bc36 mix import_movies --pages 2)",
      "Bash(TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=e291bc36 mix ecto.drop)",
      "Bash(TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=e291bc36 mix ecto.create)",
      "Bash(TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=e291bc36 mix ecto.migrate)",
      "Bash(TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=e291bc36 psql $SUPABASE_DATABASE_URL -c \"\\dt\")",
      "Bash(TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=e291bc36 mix run -e \"IO.inspect(Cinegraph.Repo.config())\")",
      "Bash(TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=e291bc36 mix run check_tables.exs)",
      "Bash(TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=e291bc36 mix import_movies --pages 1)",
      "Bash(supabase status:*)",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=e291bc36 mix ecto.migrate)",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=e291bc36 mix import_movies --pages 1)",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=e291bc36 mix import_movies --pages 5)",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres mix run check_import_status.exs)",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres mix run -e '\nimport Ecto.Query\nmovie = Cinegraph.Repo.one(from m in Cinegraph.Movies.Movie, limit: 1)\nIO.inspect(movie, label: \"\"Sample Movie\"\")\nIO.puts(\"\"\\nTMDb data keys:\"\")\nif movie.tmdb_data, do: IO.inspect(Map.keys(movie.tmdb_data))\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres mix run -e '\nimport Ecto.Query\n# Check for movies with runtime (indicates detailed data was fetched)\nwith_runtime = Cinegraph.Repo.one(from m in Cinegraph.Movies.Movie, where: not is_nil(m.runtime), select: count(m.id))\nIO.puts(\"\"Movies with runtime: #{with_runtime}\"\")\n\n# Check a movie with more details\nmovie = Cinegraph.Repo.one(from m in Cinegraph.Movies.Movie, where: m.tmdb_id == 1087192, preload: [:genres, :keywords, :production_companies])\nIO.puts(\"\"\\nMovie: #{movie.title}\"\")\nIO.puts(\"\"Runtime: #{movie.runtime || \"\"nil\"\"}\"\")\nIO.puts(\"\"Budget: #{movie.budget || \"\"nil\"\"}\"\")\nIO.puts(\"\"Revenue: #{movie.revenue || \"\"nil\"\"}\"\")\nIO.puts(\"\"Status: #{movie.status || \"\"nil\"\"}\"\")\nIO.puts(\"\"Homepage: #{movie.homepage || \"\"nil\"\"}\"\")\nIO.puts(\"\"Tagline: #{movie.tagline || \"\"nil\"\"}\"\")\nIO.puts(\"\"Genres: #{length(movie.genres)}\"\")\nIO.puts(\"\"Keywords: #{length(movie.keywords)}\"\")\nIO.puts(\"\"Production Companies: #{length(movie.production_companies)}\"\")\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=e291bc36 mix import_movies --pages 2)",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres mix run -e '\nimport Ecto.Query\n\n# Get final counts\nmovies_count = Cinegraph.Repo.aggregate(Cinegraph.Movies.Movie, :count)\nwith_imdb = Cinegraph.Repo.one(from m in Cinegraph.Movies.Movie, where: not is_nil(m.imdb_id), select: count(m.id))\nwith_runtime = Cinegraph.Repo.one(from m in Cinegraph.Movies.Movie, where: not is_nil(m.runtime), select: count(m.id))\nratings_count = Cinegraph.Repo.aggregate(Cinegraph.ExternalSources.Rating, :count)\ngenres_count = Cinegraph.Repo.aggregate(Cinegraph.Movies.Genre, :count)\nkeywords_count = Cinegraph.Repo.aggregate(Cinegraph.Movies.Keyword, :count)\ncredits_count = Cinegraph.Repo.aggregate(Cinegraph.Movies.Credit, :count)\n\nIO.puts(\"\"\\\\n=== Final Import Summary ===\"\")\nIO.puts(\"\"Total movies: #{movies_count}\"\")\nIO.puts(\"\"Movies with IMDb IDs: #{with_imdb}\"\")\nIO.puts(\"\"Movies with runtime (detailed data): #{with_runtime}\"\")\nIO.puts(\"\"Total external ratings: #{ratings_count}\"\")\nIO.puts(\"\"Total genres: #{genres_count}\"\")\nIO.puts(\"\"Total keywords: #{keywords_count}\"\")\nIO.puts(\"\"Total credits: #{credits_count}\"\")\n\n# Sample rating data\nsample_ratings = Cinegraph.Repo.all(\n  from r in Cinegraph.ExternalSources.Rating,\n  join: m in Cinegraph.Movies.Movie, on: m.id == r.movie_id,\n  limit: 5,\n  select: {m.title, r.rating_type, r.value, r.metadata}\n)\n\nIO.puts(\"\"\\\\n=== Sample External Ratings ===\"\")\nEnum.each(sample_ratings, fn {title, type, value, metadata} ->\n  source = metadata[\"\"source_name\"\"] || \"\"OMDb\"\"\n  IO.puts(\"\"#{title}: #{type} - #{value} (#{source})\"\")\nend)\n')",
      "Bash(cat:*)",
      "Bash(chmod:*)",
      "Bash(git ls-tree:*)",
      "mcp__playwright__browser_snapshot",
      "mcp__playwright__browser_click",
      "Bash(kill:*)",
      "Bash(PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT COUNT(*) AS movie_count FROM movies;\")",
      "Bash(PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\nSELECT \n    ''movie_keywords'' AS table_name, COUNT(*) AS row_count FROM movie_keywords\nUNION ALL\nSELECT \n    ''movie_videos'' AS table_name, COUNT(*) AS row_count FROM movie_videos\nUNION ALL\nSELECT \n    ''movie_credits'' AS table_name, COUNT(*) AS row_count FROM movie_credits\nUNION ALL\nSELECT \n    ''movie_release_dates'' AS table_name, COUNT(*) AS row_count FROM movie_release_dates\nUNION ALL\nSELECT \n    ''external_ratings'' AS table_name, COUNT(*) AS row_count FROM external_ratings\nORDER BY table_name;\")",
      "Bash(PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT * FROM movies WHERE id = 2 \\gx\")",
      "Bash(PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -x -c \"SELECT * FROM movies WHERE id = 2;\")",
      "Bash(PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -x -c \"SELECT * FROM external_ratings WHERE movie_id = 2 LIMIT 1;\")",
      "Bash(MIX_ENV=dev mix do ecto.drop, ecto.create, ecto.migrate)",
      "Bash(TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=3ba3f8f9 mix import_movies --fresh --pages 1 --verbose)",
      "Bash(TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=3ba3f8f9 mix import_movies --fresh --pages 10)",
      "Bash(./scripts/enrich_with_omdb.sh:*)",
      "Bash(./scripts/import_with_env.sh:*)",
      "Bash(touch:*)",
      "Bash(MIX_ENV=dev mix ecto.reset)",
      "Bash(PGPASSWORD=postgres psql -U postgres -d postgres -h 127.0.0.1 -p 54332 -c \"\\dt\")",
      "Bash(PGPASSWORD=postgres psql -U postgres -d postgres -h 127.0.0.1 -p 54332 -c \"\\d movies\")",
      "Bash(PGPASSWORD=postgres psql -U postgres -d postgres -h 127.0.0.1 -p 54332 -c \"SELECT COUNT(*) FROM movies WHERE tmdb_data IS NOT NULL AND omdb_data IS NOT NULL;\")",
      "Bash(PGPASSWORD=postgres psql -U postgres -d postgres -h 127.0.0.1 -p 54332 -c \"SELECT COUNT(DISTINCT movie_id) FROM movie_genres;\")",
      "Bash(PGPASSWORD=postgres psql -U postgres -d postgres -h 127.0.0.1 -p 54332 -c \"SELECT m.id, m.title, g.name FROM movies m JOIN movie_genres mg ON m.id = mg.movie_id JOIN genres g ON mg.genre_id = g.id WHERE m.id = 1;\")",
      "Bash(mv:*)",
      "Bash(export OMDB_API_KEY=$OMDB_API_KEY)",
      "Bash(export TMDB_API_KEY=$TMDB_API_KEY)",
      "Bash(PGPASSWORD=postgres psql -U postgres -d postgres -h 127.0.0.1 -p 54332 -c \"SELECT COUNT(*) FROM movies WHERE omdb_data IS NOT NULL;\")",
      "Bash(MIX_ENV=dev mix ecto.create)",
      "Bash(MIX_ENV=dev mix ecto.migrate)",
      "Bash(cp:*)",
      "Bash(gh label:*)",
      "Bash(gh api:*)",
      "Bash(awk:*)",
      "WebFetch(domain:hexdocs.pm)",
      "WebFetch(domain:elixirforum.com)",
      "Bash(git checkout:*)",
      "Bash(MIX_ENV=test mix compile --force)",
      "Bash(./cleanup_project.sh:*)",
      "Bash(MIX_ENV=dev mix run -e 'IO.puts(\"\"Environment: #{Mix.env()}\"\")')",
      "Bash(PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT COUNT(*) FILTER (WHERE tmdb_data IS NOT NULL) as with_tmdb, COUNT(*) FILTER (WHERE omdb_data IS NOT NULL) as with_omdb, COUNT(*) FILTER (WHERE imdb_id IS NOT NULL) as with_imdb_id FROM movies;\")",
      "Bash(PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT COUNT(*) FROM movie_genres mg JOIN genres g ON mg.genre_id = g.id;\")",
      "Bash(PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT COUNT(*) FROM movie_keywords mk JOIN keywords k ON mk.keyword_id = k.id;\")",
      "Bash(PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT COUNT(*) FROM movie_credits;\")",
      "Bash(PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT COUNT(*) FROM external_ratings;\")",
      "Bash(PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT import_type, status, movies_found, movies_imported, current_page, total_pages FROM import_progress ORDER BY id DESC LIMIT 5;\")",
      "Bash(PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT worker, state, COUNT(*) FROM oban_jobs GROUP BY worker, state ORDER BY worker, state;\")",
      "Bash(PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT COUNT(DISTINCT m.id) FROM movies m WHERE EXISTS (SELECT 1 FROM movie_videos mv WHERE mv.movie_id = m.id);\")",
      "Bash(PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT COUNT(*) FROM people;\")",
      "Bash(MIX_ENV=dev mix ecto.rollback)",
      "Bash(PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"DROP TABLE IF EXISTS import_progress CASCADE;\")",
      "Bash(PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT * FROM schema_migrations ORDER BY version DESC LIMIT 5;\")",
      "Bash(PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\\di movies*\")",
      "Bash(MIX_ENV=dev mix compile --force)",
      "Bash(git fetch:*)",
      "Bash(git merge:*)",
      "Bash(PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -c \"TRUNCATE TABLE movies, people, movie_credits, collaborations, collaboration_details, movie_genres, movie_keywords, movie_videos, movie_release_dates, movie_production_companies, external_ratings, skipped_imports CASCADE;\")",
      "Bash(PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -c \"DELETE FROM collaboration_details; DELETE FROM collaborations; DELETE FROM movie_credits; DELETE FROM external_ratings; DELETE FROM movie_release_dates; DELETE FROM movie_videos; DELETE FROM movie_keywords; DELETE FROM movie_genres; DELETE FROM movie_production_companies; DELETE FROM people; DELETE FROM movies; DELETE FROM skipped_imports;\")",
      "Bash(MIX_ENV=dev mix test_concurrent_import popular 2)",
      "Bash(PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\\dt\")",
      "Bash(PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT COUNT(*) as total_movies, COUNT(CASE WHEN import_status = ''full'' THEN 1 END) as full_imports, COUNT(CASE WHEN import_status = ''soft'' THEN 1 END) as soft_imports FROM movies;\")",
      "Bash(PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT COUNT(DISTINCT person_a_id), COUNT(DISTINCT person_b_id), COUNT(*) as total_collabs, AVG(collaboration_count)::numeric(10,2) as avg_collabs FROM collaborations;\")",
      "Bash(PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT COUNT(*) as total_people, COUNT(CASE WHEN profile_path IS NOT NULL THEN 1 END) as with_profile, COUNT(CASE WHEN popularity > 0 THEN 1 END) as with_popularity FROM people;\")",
      "Bash(PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT department, COUNT(*) as count FROM movie_credits GROUP BY department ORDER BY count DESC LIMIT 10;\")",
      "Bash(PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT role, COUNT(*) as count FROM movie_credits GROUP BY role ORDER BY count DESC LIMIT 5;\")",
      "Bash(PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\\d movie_credits\")",
      "Bash(PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT credit_type, COUNT(*) as count FROM movie_credits GROUP BY credit_type ORDER BY count DESC;\")",
      "Bash(PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT COUNT(*) as keywords, COUNT(DISTINCT movie_id) as movies_with_keywords FROM movie_keywords;\")",
      "Bash(PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT COUNT(*) FROM skipped_imports;\")",
      "Bash(PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT reason, COUNT(*) FROM skipped_imports GROUP BY reason ORDER BY COUNT(*) DESC LIMIT 5;\")",
      "Bash(PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT title, vote_count, popularity, import_status FROM movies WHERE import_status = ''full'' ORDER BY popularity DESC LIMIT 10;\")",
      "Bash(PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT title, vote_count, popularity, import_status FROM movies WHERE import_status = ''soft'' ORDER BY popularity DESC LIMIT 10;\")",
      "Bash(PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT title, criteria_failed FROM skipped_imports LIMIT 10;\")",
      "Bash(MIX_ENV=dev mix ecto.drop)",
      "Bash(PGPASSWORD=postgres psql -h 127.0.0.1 -p 54322 -U postgres -c \"SELECT pg_terminate_backend(pid) FROM pg_stat_activity WHERE datname = ''postgres'' AND pid <> pg_backend_pid();\")",
      "Bash(PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT ''Movies'' as table_name, COUNT(*) as count FROM movies UNION ALL SELECT ''People'', COUNT(*) FROM people UNION ALL SELECT ''Credits'', COUNT(*) FROM movie_credits UNION ALL SELECT ''Oban Jobs'', COUNT(*) FROM oban_jobs;\")",
      "WebFetch(domain:www.oscars.org)",
      "WebFetch(domain:raw.githubusercontent.com)",
      "Bash(PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\\d movies\")",
      "Bash(MIX_ENV=dev iex -S mix)",
      "Bash(MIX_ENV=dev mix run -e '\n# Load environment variables\nDotenvy.source()\n\n# Get a ceremony\nceremony = Cinegraph.Cultural.list_oscar_ceremonies() |> List.first()\n\n# Import just that ceremony with verbose output\nIO.puts(\"\"Testing Oscar import for ceremony #{ceremony.year}...\"\")\n\n# Import the ceremony with full logging\nresult = Cinegraph.Cultural.OscarImporter.import_ceremony(ceremony, create_movies: true, create_partial: false)\n\nIO.inspect(result, label: \"\"Import Result\"\")\n')",
      "Bash(MIX_ENV=dev mix run -e '\n# Load environment variables\nDotenvy.source(\"\".env\"\", [])\n\n# Get a ceremony\nceremony = Cinegraph.Cultural.list_oscar_ceremonies() |> List.first()\n\n# Import just that ceremony with verbose output\nIO.puts(\"\"Testing Oscar import for ceremony #{ceremony.year}...\"\")\n\n# Import the ceremony with full logging\nresult = Cinegraph.Cultural.OscarImporter.import_ceremony(ceremony, create_movies: true, create_partial: false)\n\nIO.inspect(result, label: \"\"Import Result\"\")\n')",
      "Bash(MIX_ENV=dev mix run -e '\n# Load environment variables\nDotenvy.source(\"\".env\"\", [])\n\n# Get a ceremony\nceremony = Cinegraph.Cultural.list_oscar_ceremonies() |> List.first()\n\nIO.puts(\"\"Enhancing ceremony #{ceremony.year} with IMDb data...\"\")\n\n# Enhance with IMDb data\ncase Cinegraph.Scrapers.ImdbOscarScraper.enhance_ceremony_with_imdb(ceremony) do\n  {:ok, enhanced_data} ->\n    IO.puts(\"\"Successfully enhanced!\"\")\n    \n    # Count nominees with IMDb IDs\n    nominees_with_imdb = \n      enhanced_data[\"\"categories\"\"]\n      |> Enum.flat_map(fn cat -> cat[\"\"nominees\"\"] || [] end)\n      |> Enum.count(fn n -> n[\"\"film_imdb_id\"\"] != nil end)\n    \n    IO.puts(\"\"Nominees with IMDb IDs: #{nominees_with_imdb}\"\")\n    \n    # Update the ceremony\n    changeset = Ecto.Changeset.change(ceremony, data: enhanced_data)\n    {:ok, updated} = Cinegraph.Repo.update(changeset)\n    \n    IO.puts(\"\"Ceremony updated in database\"\")\n    \n  {:error, reason} ->\n    IO.puts(\"\"Failed to enhance: #{inspect(reason)}\"\")\nend\n')",
      "Bash(MIX_ENV=dev mix run -e '\n# Load environment variables\nDotenvy.source(\"\".env\"\", [])\n\n# Get a ceremony\nceremony = Cinegraph.Cultural.list_oscar_ceremonies() |> List.first()\n\nIO.puts(\"\"Enhancing ceremony #{ceremony.year} with IMDb data...\"\")\n\n# Enhance with IMDb data\ncase Cinegraph.Scrapers.ImdbOscarScraper.enhance_ceremony_with_imdb(ceremony) do\n  {:ok, enhanced_data} ->\n    IO.puts(\"\"Successfully enhanced!\"\")\n    \n    # Count nominees with IMDb IDs\n    nominees_with_imdb = \n      enhanced_data[\"\"categories\"\"]\n      |> Enum.flat_map(fn cat -> cat[\"\"nominees\"\"] || [] end)\n      |> Enum.count(fn n -> n[\"\"film_imdb_id\"\"] != nil end)\n    \n    IO.puts(\"\"Nominees with IMDb IDs: #{nominees_with_imdb}\"\")\n    \n    # Update the ceremony\n    changeset = Ecto.Changeset.change(ceremony, data: enhanced_data)\n    {:ok, updated} = Cinegraph.Repo.update(changeset)\n    \n    IO.puts(\"\"Ceremony updated in database\"\")\n    \n  {:error, reason} ->\n    IO.puts(\"\"Failed to enhance: #{inspect(reason)}\"\")\nend\n')",
      "Bash(MIX_ENV=dev mix run enhance_oscar_with_imdb.exs)",
      "Bash(PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"DELETE FROM movies WHERE tmdb_id IS NULL;\")",
      "Bash(ZYTE_API_KEY=9e754bb61e684aad88a98eceada363ba MIX_ENV=dev mix run enhance_oscar_with_imdb.exs)",
      "Bash(TMDB_API_KEY=$TMDB_API_KEY MIX_ENV=dev mix run -e '\n# Get a ceremony\nceremony = Cinegraph.Cultural.list_oscar_ceremonies() |> List.first()\n\n# Import just that ceremony with verbose output\nIO.puts(\"\"Testing Oscar import for ceremony #{ceremony.year}...\"\")\n\n# Import the ceremony with full logging\nresult = Cinegraph.Cultural.OscarImporter.import_ceremony(ceremony, create_movies: true, create_partial: false)\n\nIO.inspect(result, label: \"\"Import Result\"\")\n')",
      "Bash(PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT jsonb_pretty(data) FROM oscar_ceremonies WHERE year = 2024 LIMIT 1;\")",
      "Bash(MIX_ENV=dev mix run -e '\n# Fetch a test page to see the HTML structure\nurl = \"\"https://www.oscars.org/oscars/ceremonies/2024\"\"\ncase Cinegraph.Scrapers.OscarScraper.fetch_html(url) do\n  {:ok, html} ->\n    # Save to file for analysis\n    File.write!(\"\"oscar_2024_sample.html\"\", html)\n    IO.puts(\"\"HTML saved to oscar_2024_sample.html\"\")\n    IO.puts(\"\"File size: #{byte_size(html)} bytes\"\")\n  {:error, reason} ->\n    IO.puts(\"\"Error: #{inspect(reason)}\"\")\nend\n')",
      "Bash(MIX_ENV=dev mix run -e '\n# Fetch a test page to see the HTML structure\nurl = \"\"https://www.oscars.org/oscars/ceremonies/2024\"\"\ncase Cinegraph.Scrapers.OscarScraper.fetch_html(url) do\n  {:ok, html} ->\n    # Save to file for analysis\n    File.write(\"\"oscar_2024_sample.html\"\", html)\n    IO.puts(\"\"HTML saved to oscar_2024_sample.html\"\")\n    IO.puts(\"\"File size: #{byte_size(html)} bytes\"\")\n  {:error, reason} ->\n    IO.puts(\"\"Error: #{inspect(reason)}\"\")\nend\n')",
      "Bash(PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT * FROM oscar_categories WHERE tracks_person = true;\")",
      "Bash(PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT ceremony_id, category_id, movie_id, COUNT(*) as count FROM oscar_nominations GROUP BY ceremony_id, category_id, movie_id HAVING COUNT(*) > 1 ORDER BY count DESC LIMIT 10;\")",
      "Bash(PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT * FROM oscar_ceremonies WHERE id = 3;\")",
      "Bash(PGPASSWORD=postgres psql:*)",
      "Bash(MIX_ENV=dev mix run -e 'result = Cinegraph.Cultural.import_oscar_years(2015..2024); IO.inspect(result, label: \"\"Import Result\"\")')",
      "Bash(MIX_ENV=dev mix run -e 'status = Cinegraph.Cultural.get_oscar_import_status(); IO.inspect(status, label: \"\"Oscar Import Status\"\")')",
      "Bash(MIX_ENV=dev mix run -e '\n# Find and retry failed TMDbDetailsWorker jobs\nimport Ecto.Query\n\nfailed_jobs = from(j in Oban.Job, \n  where: j.worker == \"\"Cinegraph.Workers.TMDbDetailsWorker\"\" and\n         j.state in [\"\"retryable\"\", \"\"executing\"\"] and\n         j.attempt > 1\n) |> Cinegraph.Repo.all()\n\nIO.puts(\"\"Found #{length(failed_jobs)} failed TMDbDetailsWorker jobs\"\")\n\n# Cancel the broken jobs (they have nested args)\nEnum.each(failed_jobs, fn job ->\n  Oban.cancel_job(job)\n  IO.puts(\"\"Cancelled job #{job.id}\"\")\nend)\n')",
      "Bash(MIX_ENV=dev mix run:*)",
      "Bash(ZYTE_API_KEY=9e754bb61e684aad88a98eceada363ba mix run -e \"Cinegraph.Cultural.CanonicalImporter.import_1001_movies()\")",
      "Bash(MIX_ENV=dev mix import_canonical --help)",
      "Bash(MIX_ENV=dev mix import_canonical --list 1001_movies --dry-run)",
      "Bash(MIX_ENV=dev mix phx.server)",
      "Bash(./scripts/clear_database.sh:*)",
      "WebFetch(domain:www.imdb.com)",
      "WebFetch(domain:www.festival-cannes.com)",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres mix run -e 'IO.inspect(Cinegraph.CanonicalLists.all(), label: \"\"All Lists\"\"); {:ok, cannes} = Cinegraph.CanonicalLists.get(\"\"cannes_winners\"\"); IO.inspect(cannes, label: \"\"Cannes Config\"\")')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=3ba3f8f9 mix run -e '\ncase Cinegraph.Scrapers.ImdbCanonicalScraper.fetch_single_page(\"\"ls527026601\"\", 1) do\n  {:ok, movies} ->\n    IO.puts(\"\"\\\\n=== Cannes List Sample Data ===\"\")\n    IO.puts(\"\"Found #{length(movies)} movies on first page\"\")\n    \n    # Show first 3 movies with details\n    movies\n    |> Enum.take(3)\n    |> Enum.with_index(1)\n    |> Enum.each(fn {movie, idx} ->\n      IO.puts(\"\"\\\\n#{idx}. #{movie.title} (#{movie.year})\"\")\n      IO.puts(\"\"   IMDb ID: #{movie.imdb_id}\"\")\n      IO.puts(\"\"   Position: #{movie.position}\"\")\n    end)\n    \n  {:error, reason} ->\n    IO.puts(\"\"Error: #{inspect(reason)}\"\")\nend\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=3ba3f8f9 mix run -e '\n# Import just the first 3 movies from Cannes list to see JSON structure\nIO.puts(\"\"Testing Cannes import with first 3 movies...\"\")\n\ncase Cinegraph.Scrapers.ImdbCanonicalScraper.fetch_single_page(\"\"ls527026601\"\", 1) do\n  {:ok, movies} ->\n    # Process just first 3 movies\n    test_movies = Enum.take(movies, 3)\n    \n    list_config = %{\n      list_id: \"\"ls527026601\"\",\n      source_key: \"\"cannes_winners\"\",\n      name: \"\"Cannes Film Festival Award Winners: 2023-1939\"\",\n      metadata: %{\n        \"\"festival\"\" => \"\"Cannes Film Festival\"\",\n        \"\"test_run\"\" => true\n      }\n    }\n    \n    {:ok, results} = Cinegraph.Scrapers.ImdbCanonicalScraper.process_canonical_movies(test_movies, list_config)\n    \n    IO.puts(\"\"\\\\nProcessed #{results.summary.total} movies\"\")\n    IO.puts(\"\"- Created: #{results.summary.created}\"\")\n    IO.puts(\"\"- Updated: #{results.summary.updated}\"\")\n    IO.puts(\"\"- Queued: #{results.summary.queued}\"\")\n    \n    # Wait a moment for jobs to process\n    Process.sleep(5000)\n    \n    # Check what got stored in canonical_sources\n    IO.puts(\"\"\\\\n=== Checking canonical_sources JSON ===\"\")\n    \n    import Ecto.Query\n    movies_with_cannes = Cinegraph.Repo.all(\n      from m in Cinegraph.Movies.Movie,\n      where: fragment(\"\"? -> ? IS NOT NULL\"\", m.canonical_sources, \"\"cannes_winners\"\"),\n      limit: 3\n    )\n    \n    Enum.each(movies_with_cannes, fn movie ->\n      IO.puts(\"\"\\\\n#{movie.title} (#{movie.imdb_id})\"\")\n      cannes_data = movie.canonical_sources[\"\"cannes_winners\"\"]\n      IO.inspect(cannes_data, label: \"\"  Cannes JSON\"\")\n    end)\n    \n  {:error, reason} ->\n    IO.puts(\"\"Error: #{inspect(reason)}\"\")\nend\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=3ba3f8f9 mix run -e '\n# Import Cannes list using the public API, but limit to just first page for testing\nIO.puts(\"\"Testing Cannes list import (limited to first entries)...\"\")\n\n# Use the scrape_list_by_key function which should work\ncase Cinegraph.Scrapers.ImdbCanonicalScraper.scrape_list_by_key(\"\"cannes_winners\"\") do\n  {:ok, result} ->\n    IO.puts(\"\"Import completed!\"\")\n    IO.inspect(result.summary, label: \"\"Summary\"\")\n    \n    # Wait for jobs to process\n    Process.sleep(10000)\n    \n    # Check what got stored in canonical_sources\n    IO.puts(\"\"\\\\n=== Checking canonical_sources JSON ===\"\")\n    \n    import Ecto.Query\n    movies_with_cannes = Cinegraph.Repo.all(\n      from m in Cinegraph.Movies.Movie,\n      where: fragment(\"\"? -> ? IS NOT NULL\"\", m.canonical_sources, \"\"cannes_winners\"\"),\n      order_by: [asc: fragment(\"\"(? -> ? ->> ?)\"\", m.canonical_sources, \"\"cannes_winners\"\", \"\"list_position\"\")],\n      limit: 5\n    )\n    \n    IO.puts(\"\"Found #{length(movies_with_cannes)} movies with Cannes data\"\")\n    \n    Enum.each(movies_with_cannes, fn movie ->\n      IO.puts(\"\"\\\\n#{movie.title} (#{movie.imdb_id})\"\")\n      cannes_data = movie.canonical_sources[\"\"cannes_winners\"\"]\n      IO.inspect(cannes_data, label: \"\"  Cannes JSON\"\", pretty: true)\n    end)\n    \n  {:error, reason} ->\n    IO.puts(\"\"Error: #{inspect(reason)}\"\")\nend\n')",
      "Bash(git stash:*)",
      "Bash(MIX_ENV=dev mix run test_cannes_enhanced_extraction.exs)",
      "Bash(MIX_ENV=dev mix run test_cannes_direct.exs)",
      "Bash(MIX_ENV=dev mix run verify_cannes_implementation.exs)",
      "Bash(PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT COUNT(*) FROM movies WHERE canonical_sources -> ''cannes_winners'' IS NOT NULL;\")",
      "Bash(PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT title, canonical_sources -> ''cannes_winners'' AS cannes_data FROM movies WHERE canonical_sources -> ''cannes_winners'' IS NOT NULL ORDER BY (canonical_sources -> ''cannes_winners'' ->> ''list_position'')::int LIMIT 3;\" -t)",
      "Bash(PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT title, canonical_sources -> ''cannes_winners'' AS cannes_data FROM movies WHERE canonical_sources -> ''cannes_winners'' -> ''raw_description'' IS NOT NULL LIMIT 1;\" -t)",
      "Bash(PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT source_key, tracks_awards, award_types, last_import_at FROM movie_lists WHERE source_key = ''cannes_winners'';\" -x)",
      "Bash(MIX_ENV=dev mix ecto.gen.migration remove_unreliable_import_tracking_fields)",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=3ba3f8f9 mix run verify_enhanced_extraction_ready.exs)",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=3ba3f8f9 mix run test_actual_scraper_functions.exs)",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=3ba3f8f9 mix run test_scraper_data_flow.exs)",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=3ba3f8f9 mix run -e '\ncase Cinegraph.Scrapers.ImdbCanonicalScraper.get_expected_movie_count(\"\"ls527026601\"\") do\n  {:ok, count} -> IO.puts(\"\"Success: #{count}\"\")\n  nil -> IO.puts(\"\"Returned nil\"\")\n  {:error, reason} -> IO.puts(\"\"Error: #{inspect(reason)}\"\")\n  other -> IO.puts(\"\"Unexpected: #{inspect(other)}\"\")\nend\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=3ba3f8f9 mix run fetch_imdb_html.exs)",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=3ba3f8f9 mix run -e '\ncase Cinegraph.Scrapers.ImdbCanonicalScraper.get_expected_movie_count(\"\"ls527026601\"\") do\n  {:ok, count} -> IO.puts(\"\"Success: #{count}\"\")\n  nil -> IO.puts(\"\"Returned nil\"\")\n  {:error, reason} -> IO.puts(\"\"Error: #{inspect(reason)}\"\")\n  other -> IO.puts(\"\"Unexpected: #{inspect(other)}\"\")\nend\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=3ba3f8f9 mix run -e '\ncase Cinegraph.Scrapers.ImdbCanonicalScraper.get_expected_movie_count(\"\"ls527026601\"\") do\n  {:ok, count} -> IO.puts(\"\"Success: #{count}\"\")\n  nil -> IO.puts(\"\"Returned nil\"\")\n  {:error, reason} -> IO.puts(\"\"Error: #{inspect(reason)}\"\")\n  other -> IO.puts(\"\"Unexpected: #{inspect(other)}\"\")\nend\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=3ba3f8f9 mix run -e '\ncase Cinegraph.Scrapers.ImdbCanonicalScraper.get_expected_movie_count(\"\"ls527026601\"\") do\n  {:ok, count} -> IO.puts(\"\"Success: #{count}\"\")\n  nil -> IO.puts(\"\"Returned nil\"\")\n  {:error, reason} -> IO.puts(\"\"Error: #{inspect(reason)}\"\")\n  other -> IO.puts(\"\"Unexpected: #{inspect(other)}\"\")\nend\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=3ba3f8f9 mix run -e '\n# Test importing just 1 page of Cannes list to verify the fixes\nimport_job = %{\n  \"\"action\"\" => \"\"orchestrate_import\"\",\n  \"\"list_key\"\" => \"\"cannes_winners\"\"\n}\n\ncase Cinegraph.Workers.CanonicalImportOrchestrator.perform(%Oban.Job{args: import_job}) do\n  :ok -> \n    IO.puts(\"\"Import orchestration started successfully\"\")\n    \n    # Wait a moment and check the movie list metadata\n    Process.sleep(5000)\n    \n    case Cinegraph.Movies.MovieLists.get_by_source_key(\"\"cannes_winners\"\") do\n      nil -> IO.puts(\"\"Movie list not found\"\")\n      list -> \n        IO.puts(\"\"Movie list found:\"\")\n        IO.puts(\"\"  Last import: #{list.last_import_at}\"\")\n        IO.puts(\"\"  Last status: #{list.last_import_status}\"\")\n        IO.puts(\"\"  Expected count in metadata: #{list.metadata[\\\"\"expected_movie_count\\\"\"]}\"\")\n    end\n    \n  {:error, reason} -> \n    IO.puts(\"\"Import failed: #{inspect(reason)}\"\")\nend\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=3ba3f8f9 mix run test_import_flow.exs)",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres mix run -e '\ncase Cinegraph.Movies.MovieLists.get_config(\"\"cannes_winners\"\") do\n  {:ok, config} ->\n    IO.puts(\"\"=== Full Config Structure ===\"\")\n    IO.inspect(config, pretty: true)\n    \n    # Check specifically for tracks_awards\n    tracks_awards = get_in(config.metadata, [\"\"tracks_awards\"\"])\n    IO.puts(\"\"\\ntracks_awards value: #{inspect(tracks_awards)}\"\")\n    IO.puts(\"\"tracks_awards == true: #{tracks_awards == true}\"\")\n    \n  {:error, reason} ->\n    IO.puts(\"\"Error: #{reason}\"\")\nend\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=3ba3f8f9 mix run debug_scraper_execution.exs)",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres mix run test_real_scraper_path.exs)",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres mix run debug_enhanced_flow.exs)",
      "Bash(CANONICAL_IMPORT_AUDIT_ISSUE.md )",
      "Bash(FINAL_AUDIT_AND_ISSUE_UPDATE.md )",
      "Bash(IMPORT_STATS_FIX_V2_SUMMARY.md )",
      "Bash(audit_comment.md )",
      "Bash(debug_enhanced_flow.exs )",
      "Bash(debug_scraper_execution.exs )",
      "Bash(root_cause_analysis.md )",
      "Bash(verify_cannes_implementation.exs )",
      "Bash(verify_enhanced_extraction_ready.exs)",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres mix run -e '\n# Test the new parsing function with sample award text\naward_text = \"\"[2023]: Palme d&apos;Or winner (Best Film).\"\"\n\n# Call the parsing function directly - need to create a module to access private function\ndefmodule TestParser do\n  def test_parsing do\n    # Simulate the parsing logic\n    award_parts = String.split(\"\"[2023]: Palme d&apos;Or winner (Best Film).\"\", \"\" | \"\")\n    \n    award_parts\n    |> Enum.map(fn award_text ->\n      trimmed = String.trim(award_text)\n      \n      # Pattern 1: [YYYY]: Award Name (Category).\n      case Regex.run(~r/\\[(\\d{4})\\]:\\s*([^(]+?)(?:\\s*\\(([^)]+)\\))?\\s*\\.?$/i, trimmed) do\n        [_, year, award_name, category] ->\n          %{\n            award_name: String.trim(award_name),\n            award_category: if(category && category != \"\"\"\", do: String.trim(category), else: nil),\n            award_year: year,\n            raw_text: trimmed\n          }\n          \n        [_, year, award_name] ->\n          %{\n            award_name: String.trim(award_name),\n            award_category: nil,\n            award_year: year,\n            raw_text: trimmed\n          }\n          \n        _ ->\n          %{award_name: \"\"fallback\"\", raw_text: trimmed}\n      end\n    end)\n  end\nend\n\nresult = TestParser.test_parsing()\nIO.puts(\"\"\\n=== Award Parsing Test ===\"\")\nIO.inspect(result, label: \"\"Parsed Awards\"\", pretty: true)\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres mix run test_award_parsing.exs)",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=3ba3f8f9 mix run -e '\n# Test enhanced extraction with a single Cannes movie\nLogger.configure(level: :info)\n\n# Clear any existing data first\nPGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\"DELETE FROM movies WHERE canonical_sources -> \\\"\"cannes_winners\\\"\" IS NOT NULL;\"\"\n\nIO.puts(\"\"\\n=== Testing Enhanced Award Extraction ===\"\")\n\ncase Cinegraph.Scrapers.ImdbCanonicalScraper.fetch_single_page(\"\"ls527026601\"\", 1) do\n  {:ok, movies} ->\n    IO.puts(\"\"Fetched #{length(movies)} movies from Cannes list\"\")\n    \n    # Test just the first movie to see the enhanced data structure\n    if length(movies) > 0 do\n      first_movie = List.first(movies)\n      IO.puts(\"\"\\n=== First Movie Data Structure ===\"\")\n      IO.puts(\"\"Title: #{first_movie.title}\"\")\n      IO.puts(\"\"Year: #{first_movie.year}\"\")\n      IO.puts(\"\"IMDb ID: #{first_movie.imdb_id}\"\")\n      \n      # Check if enhanced data exists\n      if Map.has_key?(first_movie, :award_text) do\n        IO.puts(\"\"\\n=== Enhanced Award Data ===\"\")\n        IO.puts(\"\"Award Text: #{inspect(first_movie.award_text)}\"\")\n        IO.puts(\"\"Extracted Awards:\"\")\n        if first_movie.extracted_awards do\n          Enum.each(first_movie.extracted_awards, fn award ->\n            IO.puts(\"\"  - #{award.award_name}\"\")\n            if award.award_category, do: IO.puts(\"\"    Category: #{award.award_category}\"\")\n            if award.award_year, do: IO.puts(\"\"    Year: #{award.award_year}\"\")\n          end)\n        else\n          IO.puts(\"\"  (No structured awards extracted)\"\")\n        end\n      else\n        IO.puts(\"\"\\n⚠️  No enhanced award data found\"\")\n      end\n    end\n    \n  {:error, reason} ->\n    IO.puts(\"\"Error fetching Cannes data: #{inspect(reason)}\"\")\nend\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=3ba3f8f9 mix run test_enhanced_extraction.exs)",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres mix run -e '\n# Check the current Cannes configuration to see if tracks_awards is set\ncase Cinegraph.Movies.MovieLists.get_config(\"\"cannes_winners\"\") do\n  {:ok, config} ->\n    IO.puts(\"\"=== Current Cannes Config ===\"\")\n    IO.inspect(config, pretty: true)\n    \n    tracks_awards = get_in(config.metadata, [\"\"tracks_awards\"\"])\n    IO.puts(\"\"\\ntracks_awards setting: #{inspect(tracks_awards)}\"\")\n    \n  {:error, reason} ->\n    IO.puts(\"\"Error getting config: #{reason}\"\")  \nend\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=3ba3f8f9 mix run test_cannes_awards.exs)",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres mix run -e '\n# Test enhanced extraction logic directly\nsample_html = \"\"\"\"\"\"\n<div class=\"\"lister-item\"\">\n  <h3 class=\"\"titleColumn\"\">\n    <a href=\"\"/title/tt17009710/\"\">Anatomy of a Fall</a>\n    <span class=\"\"secondaryInfo\"\">(2023)</span>\n  </h3>\n  <p class=\"\"text-muted\"\">\n    A woman is suspected of murder after her husband&apos;s death...\n    <span class=\"\"text-small\"\">[2023]: Palme d&apos;Or winner (Best Film).</span>\n  </p>\n  <p class=\"\"text-muted\"\">\n    Director: Justine Triet | Stars: Sandra Hüller, Swann Arlaud\n  </p>\n</div>\n\"\"\"\"\"\"\n\n# Parse with Floki\ndocument = Floki.parse_document!(sample_html)\nitem = Floki.find(document, \"\".lister-item\"\") |> List.first()\n\n# Simulate what our parser does\nfull_text = Floki.text(item)\nIO.puts(\"\"=== Full Text Extracted ===\"\")\nIO.puts(full_text)\n\n# Test award text extraction patterns directly\naward_patterns = [\n  ~r/\\[20\\d{2}\\]:\\s*Palme d&apos;Or[^.]*\\./i,\n  ~r/\\[20\\d{2}\\]:\\s*Grand Prix[^.]*\\./i,\n  ~r/Palme d&apos;Or winner[^.]*\\./i\n]\n\nIO.puts(\"\"\\n=== Award Pattern Matching ===\"\")\naward_matches = award_patterns\n|> Enum.flat_map(fn pattern ->\n  matches = Regex.scan(pattern, full_text, capture: :all)\n  IO.puts(\"\"Pattern #{inspect(pattern)} found: #{inspect(matches)}\"\")\n  matches |> Enum.map(fn [match] -> String.trim(match) end)\nend)\n|> Enum.reject(&(&1 == \"\"\"\"))\n|> Enum.uniq()\n\nIO.puts(\"\"\\nExtracted award matches: #{inspect(award_matches)}\"\")\n\nif length(award_matches) > 0 do\n  IO.puts(\"\"\\n=== Testing Award Parsing ===\"\")\n  award_text = Enum.join(award_matches, \"\" | \"\")\n  IO.puts(\"\"Award text: #{award_text}\"\")\n  \n  # Test parsing (manually since the function is private)\n  case Regex.run(~r/\\[(\\d{4})\\]:\\s*([^(]+?)(?:\\s*\\(([^)]+)\\))?\\s*\\.?$/i, award_text) do\n    [_, year, award_name, category] ->\n      clean_award_name = String.trim(award_name) |> String.replace(~r/\\s+winner\\s*$/i, \"\"\"\")\n      parsed = %{\n        award_name: clean_award_name,\n        award_category: if(category && category != \"\"\"\", do: String.trim(category), else: nil),\n        award_year: year,\n        raw_text: award_text\n      }\n      IO.puts(\"\"Parsed award: #{inspect(parsed, pretty: true)}\"\")\n    _ ->\n      IO.puts(\"\"No structured parsing match\"\")\n  end\nend\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=3ba3f8f9 mix run -e '\n# Test fetching just the first page to see what these lists contain\nlist_ids = [\"\"ls020806626\"\", \"\"ls073833905\"\"]\n\nEnum.each(list_ids, fn list_id ->\n  IO.puts(\"\"\\n=== Testing List #{list_id} ===\"\")\n  case Cinegraph.Scrapers.ImdbCanonicalScraper.fetch_single_page(list_id, 1) do\n    {:ok, movies} when length(movies) > 0 ->\n      first_movie = List.first(movies)\n      IO.puts(\"\"Found #{length(movies)} movies on first page\"\")\n      IO.puts(\"\"First movie: #{first_movie.title} (#{first_movie.year})\"\")\n      IO.puts(\"\"Position: #{first_movie.position}\"\")\n      if first_movie.description && String.length(first_movie.description) > 0 do\n        IO.puts(\"\"Description sample: #{String.slice(first_movie.description, 0, 100)}...\"\")\n      end\n    {:ok, []} ->\n      IO.puts(\"\"List found but no movies returned\"\")\n    {:error, reason} ->\n      IO.puts(\"\"Error: #{inspect(reason)}\"\")\n  end\nend)\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=3ba3f8f9 mix run -e '\n# Test fetching just the first page to see what these lists contain\nlist_ids = [\"\"ls020806626\"\", \"\"ls073833905\"\"]\n\nEnum.each(list_ids, fn list_id ->\n  IO.puts(\"\"\\n=== Testing List #{list_id} ===\"\")\n  case Cinegraph.Scrapers.ImdbCanonicalScraper.fetch_single_page(list_id, 1) do\n    {:ok, movies} when movies != [] ->\n      first_movie = List.first(movies)\n      IO.puts(\"\"Found #{length(movies)} movies on first page\"\")\n      IO.puts(\"\"First movie: #{first_movie.title} (#{first_movie.year})\"\")\n      IO.puts(\"\"Position: #{first_movie.position}\"\")\n      IO.puts(\"\"IMDb ID: #{first_movie.imdb_id}\"\")\n    {:ok, []} ->\n      IO.puts(\"\"List found but no movies returned\"\")\n    {:error, reason} ->\n      IO.puts(\"\"Error: #{inspect(reason)}\"\")\n  end\nend)\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=3ba3f8f9 mix run -e '\n# Test fetching just the first page to see what these lists contain\nlist_ids = [\"\"ls020806626\"\", \"\"ls073833905\"\"]\n\nEnum.each(list_ids, fn list_id ->\n  IO.puts(\"\"\\n=== Testing List #{list_id} ===\"\")\n  case Cinegraph.Scrapers.ImdbCanonicalScraper.fetch_single_page(list_id, 1) do\n    {:ok, []} ->\n      IO.puts(\"\"List found but no movies returned\"\")\n    {:ok, movies} ->\n      first_movie = List.first(movies)\n      IO.puts(\"\"Found #{length(movies)} movies on first page\"\")\n      IO.puts(\"\"First movie: #{first_movie.title} (#{first_movie.year})\"\")\n      IO.puts(\"\"Position: #{first_movie.position}\"\")\n      IO.puts(\"\"IMDb ID: #{first_movie.imdb_id}\"\")\n    {:error, reason} ->\n      IO.puts(\"\"Error: #{inspect(reason)}\"\")\n  end\nend)\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=3ba3f8f9 mix run -e '\n# Test getting list titles by checking the count method which often includes metadata\nlist_ids = [\"\"ls020806626\"\", \"\"ls073833905\"\"]\n\nEnum.each(list_ids, fn list_id ->\n  IO.puts(\"\"\\n=== Testing List #{list_id} ===\"\")\n  case Cinegraph.Scrapers.ImdbCanonicalScraper.get_expected_movie_count(list_id) do\n    {:ok, count} ->\n      IO.puts(\"\"Expected movie count: #{count}\"\")\n    {:error, reason} ->\n      IO.puts(\"\"Error getting count: #{inspect(reason)}\"\")\n    nil ->\n      IO.puts(\"\"Count returned nil\"\")\n  end\nend)\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres mix ecto.rollback --step 3)",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres mix ecto.migrate)",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres mix run -e '\n# Create the Cannes list configuration without award_types\nalias Cinegraph.Movies.MovieLists\n\nattrs = %{\n  source_key: \"\"cannes_winners\"\",\n  name: \"\"Cannes Film Festival Award Winners: 2023-1939\"\",\n  description: \"\"Complete list of Cannes Film Festival award winners from 2023 back to 1939, including Palme dOr, Grand Prix, and other major awards.\"\",\n  source_type: \"\"imdb\"\",\n  source_url: \"\"https://www.imdb.com/list/ls527026601/\"\",\n  source_id: \"\"ls527026601\"\",\n  category: \"\"awards\"\",\n  active: true,\n  tracks_awards: true,\n  metadata: %{\n    \"\"festival\"\" => \"\"Cannes Film Festival\"\",\n    \"\"note\"\" => \"\"Winners only - no nominees. Award details mixed in descriptions.\"\",\n    \"\"expected_movie_count\"\" => 297,\n    \"\"source\"\" => \"\"IMDB User List\"\",\n    \"\"reliability\"\" => \"\"85%\"\",\n    \"\"data_extraction\"\" => \"\"Enhanced extraction with dynamic award discovery\"\",\n    \"\"tracks_awards\"\" => true\n  }\n}\n\ncase MovieLists.create_movie_list(attrs) do\n  {:ok, list} ->\n    IO.puts(\"\"✅ Created Cannes list configuration:\"\")\n    IO.puts(\"\"   Source Key: #{list.source_key}\"\")\n    IO.puts(\"\"   Name: #{list.name}\"\")\n    IO.puts(\"\"   Tracks Awards: #{list.tracks_awards}\"\")\n    IO.puts(\"\"   List ID: #{list.source_id}\"\")\n    \n  {:error, changeset} ->\n    IO.puts(\"\"❌ Error creating list:\"\")\n    IO.inspect(changeset.errors)\nend\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=3ba3f8f9 timeout 60 mix run test_dynamic_discovery.exs)",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=3ba3f8f9 mix run test_dynamic_discovery.exs)",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres mix run test_award_extraction.exs)",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres mix run test_manual_config.exs)",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres mix run -e '\n# Test the tracks_awards? function\nconfig = %{metadata: %{}}\n\nberlin_tracks = Cinegraph.Movies.MovieLists.send(:tracks_awards?, \"\"berlin_golden_bear\"\", config)\nvenice_tracks = Cinegraph.Movies.MovieLists.send(:tracks_awards?, \"\"venice_golden_lion\"\", config)\ncannes_tracks = Cinegraph.Movies.MovieLists.send(:tracks_awards?, \"\"cannes_winners\"\", config)\ncriterion_tracks = Cinegraph.Movies.MovieLists.send(:tracks_awards?, \"\"criterion\"\", config)\n\nIO.puts(\"\"🎬 Testing tracks_awards detection:\"\")\nIO.puts(\"\"  Berlin Golden Bear: #{berlin_tracks}\"\")\nIO.puts(\"\"  Venice Golden Lion: #{venice_tracks}\"\")  \nIO.puts(\"\"  Cannes Winners: #{cannes_tracks}\"\")\nIO.puts(\"\"  Criterion (should be false): #{criterion_tracks}\"\")\n\nif berlin_tracks && venice_tracks && cannes_tracks && !criterion_tracks do\n  IO.puts(\"\"✅ All festival awards correctly detected!\"\")\nelse\n  IO.puts(\"\"❌ Award detection not working correctly\"\")\nend\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres mix run -e '\n# Test the tracks_awards? function\nconfig = %{metadata: %{}}\n\nberlin_tracks = Cinegraph.Movies.MovieLists.send(:tracks_awards?, \"\"berlin_golden_bear\"\", config)\nvenice_tracks = Cinegraph.Movies.MovieLists.send(:tracks_awards?, \"\"venice_golden_lion\"\", config)\ncannes_tracks = Cinegraph.Movies.MovieLists.send(:tracks_awards?, \"\"cannes_winners\"\", config)\ncriterion_tracks = Cinegraph.Movies.MovieLists.send(:tracks_awards?, \"\"criterion\"\", config)\n\nIO.puts(\"\"🎬 Testing tracks_awards detection:\"\")\nIO.puts(\"\"  Berlin Golden Bear: #{berlin_tracks}\"\")\nIO.puts(\"\"  Venice Golden Lion: #{venice_tracks}\"\")  \nIO.puts(\"\"  Cannes Winners: #{cannes_tracks}\"\")\nIO.puts(\"\"  Criterion (should be false): #{criterion_tracks}\"\")\n\nif berlin_tracks && venice_tracks && cannes_tracks && (not criterion_tracks) do\n  IO.puts(\"\"✅ All festival awards correctly detected!\"\")\nelse\n  IO.puts(\"\"❌ Award detection not working correctly\"\")\nend\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres mix run -e '\n# Test that migrate_hardcoded_lists would correctly set tracks_awards for festivals\nresult = Cinegraph.Movies.MovieLists.migrate_hardcoded_lists()\n\nIO.puts(\"\"🎬 Migration Results:\"\")\nIO.puts(\"\"  Created: #{result.created}\"\")  \nIO.puts(\"\"  Already existed: #{result.existed}\"\")\nIO.puts(\"\"  Errors: #{length(result.errors)}\"\")\n\n# Check tracks_awards values after migration\nimport Ecto.Query\nawards_lists = Cinegraph.Repo.all(\n  from ml in Cinegraph.Movies.MovieList,\n  where: ml.tracks_awards == true,\n  select: {ml.source_key, ml.name}\n)  \n\nIO.puts(\"\"\\n🏆 Lists tracking awards:\"\")\nEnum.each(awards_lists, fn {key, name} ->\n  IO.puts(\"\"  ✓ #{key}: #{name}\"\")\nend)\n\nexpected_awards = [\"\"berlin_golden_bear\"\", \"\"cannes_winners\"\", \"\"venice_golden_lion\"\"]\nactual_awards = Enum.map(awards_lists, fn {key, _name} -> key end)\n\nif Enum.sort(expected_awards) == Enum.sort(actual_awards) do\n  IO.puts(\"\"\\n✅ SUCCESS: All three festival lists correctly track awards!\"\")\nelse\n  IO.puts(\"\"\\n❌ MISMATCH: Expected #{inspect(expected_awards)}, got #{inspect(actual_awards)}\"\")\nend\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres mix run -e '\n# Test the get_canonical_list_stats function behavior\n# This simulates what the UI shows in the \"\"List Statistics\"\" section\n\nimport Ecto.Query\nalias Cinegraph.{Repo, Movies.MovieLists}\n\n# Get all canonical lists from database and their counts (same logic as UI)\nlist_stats = MovieLists.all_as_config()\n|> Enum.map(fn {list_key, config} ->\n  # Use raw SQL to avoid Ecto escaping issues with the ? operator\n  {:ok, %{rows: [[count]]}} = Repo.query(\n    \"\"SELECT COUNT(*) FROM movies WHERE canonical_sources ? $1\"\",\n    [list_key]\n  )\n  \n  # Get expected count from database metadata if available\n  expected_count = case MovieLists.get_active_by_source_key(list_key) do\n    nil -> nil\n    list -> list.metadata[\"\"expected_movie_count\"\"]\n  end\n  \n  %{\n    key: list_key,\n    name: config.name,\n    count: count,\n    expected_count: expected_count\n  }\nend)\n|> Enum.sort_by(& &1.count, :desc)\n\nIO.puts(\"\"📊 List Statistics (same as UI shows):\"\")\nIO.puts(\"\"=\"\" <> String.duplicate(\"\"=\"\", 50))\n\nEnum.each(list_stats, fn stat ->\n  expected_text = if stat.expected_count, do: \"\" / #{stat.expected_count}\"\", else: \"\"\"\"\n  IO.puts(\"\"#{stat.name}\"\")\n  IO.puts(\"\"#{stat.count}#{expected_text} movies\"\")\n  IO.puts(\"\"\"\")\nend)\n\nIO.puts(\"\"🔍 Source Verification:\"\")\nIO.puts(\"\"Total lists shown: #{length(list_stats)}\"\")\n\n# Check if all these lists exist in database\ndb_lists = MovieLists.list_all_movie_lists()\nIO.puts(\"\"Database lists count: #{length(db_lists)}\"\")\n\nif length(list_stats) == length(db_lists) do\n  IO.puts(\"\"✅ SUCCESS: List statistics are based on database-managed lists\"\")\nelse\n  IO.puts(\"\"❌ MISMATCH: Statistics may still include hardcoded lists\"\")\nend\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres mix run -e '\n# Test the new dynamic system\nIO.puts(\"\"🧪 Testing Dynamic Movie Lists System\"\")\nIO.puts(\"\"=\"\" <> String.duplicate(\"\"=\"\", 50))\n\n# Test getting active source keys\nall_keys = Cinegraph.Movies.MovieLists.get_active_source_keys()\nIO.puts(\"\"\\n📋 All Active Source Keys:\"\")\nEnum.each(all_keys, fn key -> IO.puts(\"\"  - #{key}\"\") end)\n\n# Test filtering by category\nawards_keys = Cinegraph.Movies.MovieLists.get_active_source_keys(category: \"\"awards\"\")\nIO.puts(\"\"\\n🏆 Awards Category Source Keys:\"\")\nEnum.each(awards_keys, fn key -> IO.puts(\"\"  - #{key}\"\") end)\n\n# Test filtering by tracks_awards\ntracking_keys = Cinegraph.Movies.MovieLists.get_active_source_keys(tracks_awards: true)\nIO.puts(\"\"\\n🎯 Lists Tracking Awards:\"\")\nEnum.each(tracking_keys, fn key -> IO.puts(\"\"  - #{key}\"\") end)\n\n# Test individual lookups\nIO.puts(\"\"\\n🔍 Individual Lookups:\"\")\ntest_keys = [\"\"cannes_winners\"\", \"\"criterion\"\", \"\"berlin_golden_bear\"\"]\nEnum.each(test_keys, fn key ->\n  category = Cinegraph.Movies.MovieLists.get_category_for_source_key(key)\n  tracks_awards = Cinegraph.Movies.MovieLists.tracks_awards_for_source_key?(key)\n  IO.puts(\"\"  #{key}: category=#{category}, tracks_awards=#{tracks_awards}\"\")\nend)\n\nIO.puts(\"\"\\n✅ Dynamic system working! No hardcoded values needed.\"\")\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres mix run -e '\n# Test that new list is automatically picked up\nIO.puts(\"\"🧪 Testing New List Added Without Code Changes\"\")\nIO.puts(\"\"=\"\" <> String.duplicate(\"\"=\"\", 60))\n\n# Test it appears in all active lists\nall_keys = Cinegraph.Movies.MovieLists.get_active_source_keys()\nIO.puts(\"\"\\n📋 All Active Source Keys (should include test_festival):\"\")\nEnum.each(all_keys, fn key -> \n  marker = if key == \"\"test_festival\"\", do: \"\" ⭐ NEW\"\", else: \"\"\"\"\n  IO.puts(\"\"  - #{key}#{marker}\"\") \nend)\n\n# Test it appears in awards category\nawards_keys = Cinegraph.Movies.MovieLists.get_active_source_keys(category: \"\"awards\"\")\nIO.puts(\"\"\\n🏆 Awards Category (should include test_festival):\"\")\nEnum.each(awards_keys, fn key -> \n  marker = if key == \"\"test_festival\"\", do: \"\" ⭐ NEW\"\", else: \"\"\"\"\n  IO.puts(\"\"  - #{key}#{marker}\"\") \nend)\n\n# Test it tracks awards\ntracking_keys = Cinegraph.Movies.MovieLists.get_active_source_keys(tracks_awards: true)\nIO.puts(\"\"\\n🎯 Lists Tracking Awards (should include test_festival):\"\")\nEnum.each(tracking_keys, fn key -> \n  marker = if key == \"\"test_festival\"\", do: \"\" ⭐ NEW\"\", else: \"\"\"\"\n  IO.puts(\"\"  - #{key}#{marker}\"\") \nend)\n\n# Test individual lookup\ncategory = Cinegraph.Movies.MovieLists.get_category_for_source_key(\"\"test_festival\"\")\ntracks_awards = Cinegraph.Movies.MovieLists.tracks_awards_for_source_key?(\"\"test_festival\"\")\nIO.puts(\"\"\\n🔍 New List Properties:\"\")\nIO.puts(\"\"  test_festival: category=#{category}, tracks_awards=#{tracks_awards}\"\")\n\n# Test it appears in UI dropdown\navailable_lists = Cinegraph.Workers.CanonicalImportOrchestrator.available_lists()\nif Map.has_key?(available_lists, \"\"test_festival\"\") do\n  config = available_lists[\"\"test_festival\"\"]\n  IO.puts(\"\"\\n✅ SUCCESS: New list appears in UI dropdown!\"\")\n  IO.puts(\"\"  Name: #{config.name}\"\")\n  IO.puts(\"\"  Category: #{config.category}\"\")\nelse\n  IO.puts(\"\"\\n❌ FAILED: New list not in UI dropdown\"\")\nend\n\nhas_test = \"\"test_festival\"\" in all_keys\nif has_test do\n  IO.puts(\"\"\\n🎉 PERFECT! New list added with ZERO CODE CHANGES!\"\")\n  IO.puts(\"\"  ✅ Appears in all queries\"\")\n  IO.puts(\"\"  ✅ Filtered by category correctly\"\") \n  IO.puts(\"\"  ✅ Filtered by tracks_awards correctly\"\")\n  IO.puts(\"\"  ✅ Available in UI dropdown\"\")\n  IO.puts(\"\"\\n  This proves the system is now fully database-driven! 🚀\"\")\nelse\n  IO.puts(\"\"\\n❌ System still has hardcoded dependencies\"\")\nend\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres mix run -e '\n# Test the complete database-driven system\n\n# 1. Get all canonical lists from database and show they include category\nIO.puts(\"\"=== Testing Complete Database-Driven System ===\"\")\n\nimport Ecto.Query\nalias Cinegraph.{Repo, Movies.MovieLists}\n\n# Get all active lists as config (this is what the UI uses)\nconfig_map = MovieLists.all_as_config()\n\nIO.puts(\"\"\\n📊 All Lists as Config (same as UI dropdown):\"\")\nEnum.each(config_map, fn {key, config} ->\n  IO.puts(\"\"✓ #{key}: #{config.name}\"\")\n  IO.puts(\"\"  Category: #{config.category}\"\")\n  IO.puts(\"\"  Tracks Awards: #{config.metadata[\"\"tracks_awards\"\"] == true}\"\")\n  IO.puts(\"\"\"\")\nend)\n\n# 2. Verify dynamic queries work\nawards_lists = MovieLists.get_active_source_keys(tracks_awards: true)\nfestival_lists = MovieLists.get_active_source_keys(category: \"\"awards\"\")\n\nIO.puts(\"\"🏆 Lists that track awards: #{inspect(awards_lists)}\"\")\nIO.puts(\"\"🎬 Festival/awards category lists: #{inspect(festival_lists)}\"\")\n\nif Enum.sort(awards_lists) == Enum.sort(festival_lists) do\n  IO.puts(\"\"✅ SUCCESS: Award tracking and festival categories match perfectly!\"\")\nelse\n  IO.puts(\"\"❌ MISMATCH: Different results from award vs category queries\"\")\nend\n\n# 3. Test that we can get individual list configs without errors\nIO.puts(\"\"\\n🔍 Testing individual list configurations:\"\")\nEnum.each([\"\"cannes_winners\"\", \"\"venice_golden_lion\"\", \"\"berlin_golden_bear\"\"], fn key ->\n  case MovieLists.get_config(key) do\n    {:ok, config} ->\n      IO.puts(\"\"✓ #{key}: #{config.name} (category: #{config.category})\"\")\n    {:error, reason} ->\n      IO.puts(\"\"❌ #{key}: #{reason}\"\")\n  end\nend)\n\nIO.puts(\"\"\\n🎯 System is fully database-driven - no hardcoded logic remaining!\"\")\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres mix run -e '\n# Remove the test_festival entry\nimport Ecto.Query\nalias Cinegraph.{Repo, Movies.MovieLists}\n\ncase MovieLists.get_by_source_key(\"\"test_festival\"\") do\n  nil -> IO.puts(\"\"Test festival already removed\"\")\n  list -> \n    {:ok, _} = MovieLists.delete_movie_list(list)\n    IO.puts(\"\"✅ Removed test festival entry\"\")\nend\n\n# Verify final state\nconfig_map = MovieLists.all_as_config()\nIO.puts(\"\"\\n📊 Final Active Lists:\"\")\nEnum.each(config_map, fn {key, config} ->\n  category_emoji = case config.category do\n    \"\"awards\"\" -> \"\"🏆\"\"\n    \"\"curated\"\" -> \"\"📚\"\"\n    \"\"critics\"\" -> \"\"🎭\"\"\n    \"\"registry\"\" -> \"\"🏛️\"\"\n    _ -> \"\"📝\"\"\n  end\n  tracks_awards = if config.metadata[\"\"tracks_awards\"\"] == true, do: \"\" [Awards]\"\", else: \"\"\"\"\n  IO.puts(\"\"#{category_emoji} #{key}: #{config.name}#{tracks_awards}\"\")\nend)\n\nIO.puts(\"\"\\n✅ SUCCESS: System is completely database-driven!\"\")\nIO.puts(\"\"   - All hardcoded logic removed\"\")\nIO.puts(\"\"   - Dynamic queries work perfectly\"\") \nIO.puts(\"\"   - Adding new lists requires zero code changes\"\")\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres mix run -e '\n# Verify the final state of the database after clearing and reseeding\nIO.puts(\"\"=== Database State After Clear and Reseed ===\"\")\n\nimport Ecto.Query\nalias Cinegraph.{Repo, Movies.MovieLists}\n\n# Check movie lists\nlists = MovieLists.list_all_movie_lists()\nIO.puts(\"\"\\n📊 Movie Lists in Database: #{length(lists)}\"\")\nEnum.each(lists, fn list ->\n  category_emoji = case list.category do\n    \"\"awards\"\" -> \"\"🏆\"\"\n    \"\"curated\"\" -> \"\"📚\"\"\n    \"\"critics\"\" -> \"\"🎭\"\"\n    \"\"registry\"\" -> \"\"🏛️\"\"\n    _ -> \"\"📝\"\"\n  end\n  awards = if list.tracks_awards, do: \"\" [Tracks Awards]\"\", else: \"\"\"\"\n  IO.puts(\"\"#{category_emoji} #{list.source_key}: #{list.name}#{awards}\"\")\nend)\n\n# Check that Venice and Berlin are correctly configured\nfestival_lists = MovieLists.get_active_source_keys(category: \"\"awards\"\", tracks_awards: true)\nIO.puts(\"\"\\n🎬 Festival Lists with Awards:\"\")\nEnum.each(festival_lists, fn key ->\n  IO.puts(\"\"  - #{key}\"\")\nend)\n\nIO.puts(\"\"\\n✅ Database has been successfully cleared and reseeded!\"\")\nIO.puts(\"\"✅ Venice and Berlin festivals are properly configured with category=\\\"\"awards\\\"\" and tracks_awards=true\"\")\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=3ba3f8f9 mix run -e '\n# Clear existing Cannes data to test fresh\nIO.puts(\"\"Clearing existing Cannes data...\"\")\nimport Ecto.Query\nCinegraph.Repo.update_all(\n  from(m in Cinegraph.Movies.Movie, where: fragment(\"\"? \\\\? ?\"\", m.canonical_sources, \"\"cannes_winners\"\")),\n  set: [canonical_sources: fragment(\"\"? - ?\"\", m.canonical_sources, \"\"cannes_winners\"\")]\n)\n\n# Test with just one page to verify fix\nIO.puts(\"\"\\nTesting with limited data to verify extracted_awards is preserved...\"\")\n\n# Get the config and process just first page\ncase Cinegraph.Movies.MovieLists.get_config(\"\"cannes_winners\"\") do\n  {:ok, config} ->\n    IO.puts(\"\"Found Cannes config with tracks_awards: #{config.metadata[\"\"tracks_awards\"\"]}\"\")\n    \n    # Fetch and process just first page\n    case Cinegraph.Scrapers.ImdbCanonicalScraper.fetch_single_page(config.list_id, 1) do\n      {:ok, movies} ->\n        IO.puts(\"\"Fetched #{length(movies)} movies from page 1\"\")\n        \n        # Process just first 3 movies with the config\n        test_movies = Enum.take(movies, 3)\n        {:ok, results} = Cinegraph.Scrapers.ImdbCanonicalScraper.process_canonical_movies(test_movies, config)\n        \n        IO.puts(\"\"\\nProcessed #{results.summary.total} movies\"\")\n        IO.puts(\"\"Queued: #{results.summary.queued}\"\")\n        \n        # Wait for workers to process\n        IO.puts(\"\"\\nWaiting for workers to process...\"\")\n        Process.sleep(10000)\n        \n        # Check results\n        IO.puts(\"\"\\n=== Checking Results ===\"\")\n        movies_with_awards = Cinegraph.Repo.all(\n          from m in Cinegraph.Movies.Movie,\n          where: fragment(\"\"? -> ? -> ? IS NOT NULL\"\", m.canonical_sources, \"\"cannes_winners\"\", \"\"extracted_awards\"\"),\n          select: %{\n            title: m.title,\n            awards: fragment(\"\"? -> ? -> ?\"\", m.canonical_sources, \"\"cannes_winners\"\", \"\"extracted_awards\"\")\n          }\n        )\n        \n        IO.puts(\"\"Movies with extracted_awards: #{length(movies_with_awards)}\"\")\n        if length(movies_with_awards) > 0 do\n          IO.puts(\"\"\\n✅ SUCCESS! extracted_awards field is now being preserved!\"\")\n          Enum.each(movies_with_awards, fn movie ->\n            IO.puts(\"\"  - #{movie.title}: #{inspect(movie.awards)}\"\")\n          end)\n        else\n          IO.puts(\"\"\\n❌ Still no extracted_awards found\"\")\n        end\n        \n      {:error, reason} ->\n        IO.puts(\"\"Error fetching page: #{inspect(reason)}\"\")\n    end\n    \n  {:error, reason} ->\n    IO.puts(\"\"Error getting config: #{reason}\"\")\nend\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=3ba3f8f9 mix run -e '\n# Clear existing Cannes data to test fresh\nIO.puts(\"\"Clearing existing Cannes data...\"\")\n\n# Direct module call for canonical_movies function - need proper access\nalias Cinegraph.Scrapers.ImdbCanonicalScraper\n\n# Test with the public interface\nIO.puts(\"\"\\nRe-importing a few Cannes movies to test fix...\"\")\n\n# Use the public scrape_list_by_key function which properly handles everything\n# But limit to avoid timeout - we can check Oban jobs instead\ncase ImdbCanonicalScraper.fetch_single_page(\"\"ls527026601\"\", 1) do\n  {:ok, movies} ->\n    IO.puts(\"\"Fetched #{length(movies)} movies\"\")\n    \n    # Just show first few to verify we have data\n    movies\n    |> Enum.take(3)\n    |> Enum.each(fn movie ->\n      IO.puts(\"\"  - #{movie.title} (#{movie.year})\"\")\n    end)\n    \n    IO.puts(\"\"\\nTo verify the fix, run a full import and check:\"\")\n    IO.puts(\"\"SELECT COUNT(*) FROM movies WHERE canonical_sources -> \\\"\"cannes_winners\\\"\" -> \\\"\"extracted_awards\\\"\" IS NOT NULL;\"\")\n    \n  {:error, reason} ->\n    IO.puts(\"\"Error: #{inspect(reason)}\"\")\nend\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=3ba3f8f9 mix run -e '\n# Test the fix by importing a few Cannes movies\nIO.puts(\"\"\\n=== Testing Cannes Import After Fix ===\"\")\nIO.puts(\"\"Testing that extracted_awards is preserved through the import pipeline...\"\")\n\n# Clear any existing Cannes data first\nimport Ecto.Query\nCinegraph.Repo.update_all(\n  from(m in Cinegraph.Movies.Movie, where: fragment(\"\"? \\\\? ?\"\", m.canonical_sources, \"\"cannes_winners\"\")),\n  set: [canonical_sources: fragment(\"\"? - ?\"\", m.canonical_sources, \"\"cannes_winners\"\")]\n)\n\n# Import just first page to test\ncase Cinegraph.Scrapers.ImdbCanonicalScraper.scrape_list_by_key(\"\"cannes_winners\"\", pages: 1) do\n  {:ok, result} ->\n    IO.puts(\"\"\\nImport completed!\"\")\n    IO.puts(\"\"Summary: #{inspect(result.summary)}\"\")\n    \n    # Wait for workers to process\n    IO.puts(\"\"\\nWaiting 15 seconds for workers to complete...\"\")\n    Process.sleep(15000)\n    \n    # Check results\n    IO.puts(\"\"\\n=== Checking Results ===\"\")\n    \n    # Count movies with extracted_awards\n    movies_with_awards = Cinegraph.Repo.all(\n      from m in Cinegraph.Movies.Movie,\n      where: fragment(\"\"? -> ? -> ? IS NOT NULL\"\", m.canonical_sources, \"\"cannes_winners\"\", \"\"extracted_awards\"\"),\n      select: %{\n        id: m.id,\n        title: m.title,\n        imdb_id: m.imdb_id,\n        awards: fragment(\"\"? -> ? -> ?\"\", m.canonical_sources, \"\"cannes_winners\"\", \"\"extracted_awards\"\")\n      }\n    )\n    \n    total_cannes_movies = Cinegraph.Repo.one(\n      from m in Cinegraph.Movies.Movie,\n      where: fragment(\"\"? \\\\? ?\"\", m.canonical_sources, \"\"cannes_winners\"\"),\n      select: count(m.id)\n    )\n    \n    IO.puts(\"\"\\nTotal movies with Cannes data: #{total_cannes_movies}\"\")\n    IO.puts(\"\"Movies with extracted_awards: #{length(movies_with_awards)}\"\")\n    \n    if length(movies_with_awards) > 0 do\n      IO.puts(\"\"\\n✅ SUCCESS! The fix worked - extracted_awards is now being preserved!\"\")\n      IO.puts(\"\"\\n=== Sample Movies with Awards ===\"\")\n      movies_with_awards\n      |> Enum.take(3)\n      |> Enum.each(fn movie ->\n        IO.puts(\"\"\\n#{movie.title} (#{movie.imdb_id})\"\")\n        IO.puts(\"\"Awards: #{inspect(movie.awards, pretty: true)}\"\")\n      end)\n    else\n      IO.puts(\"\"\\n❌ FAILED: Still no extracted_awards found after fix\"\")\n      \n      # Debug: Check what actually got stored\n      sample_movie = Cinegraph.Repo.one(\n        from m in Cinegraph.Movies.Movie,\n        where: fragment(\"\"? \\\\? ?\"\", m.canonical_sources, \"\"cannes_winners\"\"),\n        limit: 1\n      )\n      \n      if sample_movie do\n        IO.puts(\"\"\\n=== Debug: Sample Cannes Data ===\"\")\n        IO.puts(\"\"Movie: #{sample_movie.title}\"\")\n        cannes_data = sample_movie.canonical_sources[\"\"cannes_winners\"\"]\n        IO.puts(\"\"Keys in cannes_winners: #{inspect(Map.keys(cannes_data))}\"\")\n        IO.puts(\"\"Full data: #{inspect(cannes_data, pretty: true)}\"\")\n      end\n    end\n    \n  {:error, reason} ->\n    IO.puts(\"\"Error running import: #{inspect(reason)}\"\")\nend\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres mix run -e '\n# Verify database state after clear and reseed\nIO.puts(\"\"=== Verifying Database State ===\"\")\n\nimport Ecto.Query\nalias Cinegraph.{Repo, Movies.MovieLists}\n\n# Check movie lists\nlists = MovieLists.list_all_movie_lists()\nIO.puts(\"\"\\n📊 Movie Lists in Database: #{length(lists)}\"\")\nEnum.each(lists, fn list ->\n  category_emoji = case list.category do\n    \"\"awards\"\" -> \"\"🏆\"\"\n    \"\"curated\"\" -> \"\"📚\"\"\n    \"\"critics\"\" -> \"\"🎭\"\"\n    \"\"registry\"\" -> \"\"🏛️\"\"\n    _ -> \"\"📝\"\"\n  end\n  awards = if list.tracks_awards, do: \"\" [Tracks Awards]\"\", else: \"\"\"\"\n  IO.puts(\"\"#{category_emoji} #{list.source_key}: #{list.name}#{awards}\"\")\nend)\n\n# Verify empty tables\nmovie_count = Repo.aggregate(Cinegraph.Movies.Movie, :count)\npeople_count = Repo.aggregate(Cinegraph.Movies.Person, :count)\noscar_count = Repo.aggregate(Cinegraph.Cultural.OscarCeremony, :count)\n\nIO.puts(\"\"\\n📊 Database Counts:\"\")\nIO.puts(\"\"  Movies: #{movie_count}\"\")\nIO.puts(\"\"  People: #{people_count}\"\")\nIO.puts(\"\"  Oscar Ceremonies: #{oscar_count}\"\")\n\n# Check that our festival lists are there\nfestival_lists = MovieLists.get_active_source_keys(category: \"\"awards\"\", tracks_awards: true)\nIO.puts(\"\"\\n🎬 Festival Lists with Awards:\"\")\nEnum.each(festival_lists, fn key ->\n  IO.puts(\"\"  - #{key}\"\")\nend)\n\nIO.puts(\"\"\\n✅ Database successfully cleared and reseeded according to README!\"\")\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres mix run -e '\n# Verify database state after reset and reseed\nIO.puts(\"\"=== Database State After Reset and Reseed ===\"\")\n\nimport Ecto.Query\nalias Cinegraph.{Repo, Movies.MovieLists}\n\n# Check movie lists\nlists = MovieLists.list_all_movie_lists()\nIO.puts(\"\"\\n📊 Movie Lists in Database: #{length(lists)}\"\")\nEnum.each(lists, fn list ->\n  category_emoji = case list.category do\n    \"\"awards\"\" -> \"\"🏆\"\"\n    \"\"curated\"\" -> \"\"📚\"\"\n    \"\"critics\"\" -> \"\"🎭\"\"\n    \"\"registry\"\" -> \"\"🏛️\"\"\n    _ -> \"\"📝\"\"\n  end\n  awards = if list.tracks_awards, do: \"\" [Tracks Awards]\"\", else: \"\"\"\"\n  IO.puts(\"\"#{category_emoji} #{list.source_key}: #{list.name}#{awards}\"\")\nend)\n\n# Verify empty tables\nmovie_count = Repo.aggregate(Cinegraph.Movies.Movie, :count)\npeople_count = Repo.aggregate(Cinegraph.Movies.Person, :count)\noscar_count = Repo.aggregate(Cinegraph.Cultural.OscarCeremony, :count)\noban_jobs = Repo.aggregate(Oban.Job, :count)\n\nIO.puts(\"\"\\n📊 Database Counts:\"\")\nIO.puts(\"\"  Movies: #{movie_count}\"\")\nIO.puts(\"\"  People: #{people_count}\"\")\nIO.puts(\"\"  Oscar Ceremonies: #{oscar_count}\"\")\nIO.puts(\"\"  Oban Jobs: #{oban_jobs}\"\")\n\n# Check that our festival lists are properly configured\nfestival_lists = MovieLists.get_active_source_keys(category: \"\"awards\"\", tracks_awards: true)\nIO.puts(\"\"\\n🎬 Festival Lists with Awards:\"\")\nEnum.each(festival_lists, fn key ->\n  IO.puts(\"\"  - #{key}\"\")\nend)\n\nIO.puts(\"\"\\n✅ Database successfully reset and reseeded!\"\")\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=3ba3f8f9 mix run test_cannes_import_fix.exs)",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=3ba3f8f9 mix run test_cannes_import_fix_simple.exs)",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=3ba3f8f9 mix run test_cannes_manual.exs)",
      "Bash(timeout 30 mix run test_full_extraction.exs)",
      "Bash(timeout 20 mix run test_simple_scrape.exs)",
      "Bash(timeout:*)",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres mix run -e '\nIO.puts(\"\"=== Auditing Current Cannes Import Status ===\"\")\n\nimport Ecto.Query\nalias Cinegraph.Repo\n\n# Check if any Cannes movies have been imported\ncannes_movies = Repo.all(\n  from m in Cinegraph.Movies.Movie,\n  where: fragment(\"\"? \\\\? ?\"\", m.canonical_sources, \"\"cannes_winners\"\"),\n  select: %{\n    id: m.id,\n    title: m.title,\n    imdb_id: m.imdb_id,\n    cannes_data: fragment(\"\"? -> ?\"\", m.canonical_sources, \"\"cannes_winners\"\")\n  },\n  limit: 10\n)\n\nIO.puts(\"\"\\\\nFound #{length(cannes_movies)} Cannes movies in database\"\")\n\nif length(cannes_movies) > 0 do\n  IO.puts(\"\"\\\\n=== Sample Cannes Movies ===\"\")\n  \n  Enum.each(cannes_movies, fn movie ->\n    IO.puts(\"\"\\\\n#{movie.title} (#{movie.imdb_id})\"\")\n    \n    cannes_data = movie.cannes_data\n    \n    # Check specifically for extracted_awards\n    extracted_awards = get_in(cannes_data, [\"\"extracted_awards\"\"])\n    award_text = get_in(cannes_data, [\"\"award_text\"\"])\n    list_position = get_in(cannes_data, [\"\"list_position\"\"])\n    scraped_at = get_in(cannes_data, [\"\"scraped_at\"\"])\n    \n    IO.puts(\"\"  Position: #{list_position}\"\")\n    IO.puts(\"\"  Scraped at: #{scraped_at}\"\")\n    IO.puts(\"\"  Award text: #{if award_text, do: String.slice(award_text, 0, 100), else: \"\"nil\"\"}...\"\")\n    \n    if extracted_awards do\n      IO.puts(\"\"  ✅ HAS extracted_awards: #{inspect(extracted_awards)}\"\")\n    else\n      IO.puts(\"\"  ❌ NO extracted_awards field\"\")\n    end\n  end)\n  \n  # Count how many have extracted_awards\n  with_awards = Enum.count(cannes_movies, fn movie ->\n    get_in(movie.cannes_data, [\"\"extracted_awards\"\"]) != nil\n  end)\n  \n  IO.puts(\"\"\\\\n📊 Summary:\"\")\n  IO.puts(\"\"  Movies with extracted_awards: #{with_awards}/#{length(cannes_movies)}\"\")\n  \n  if with_awards > 0 do\n    IO.puts(\"\"  ✅ SUCCESS: Award extraction is working!\"\")\n  else\n    IO.puts(\"\"  ❌ ISSUE: No movies have extracted_awards yet\"\")\n    \n    # Check if import is still running\n    IO.puts(\"\"\\\\n🔍 Checking if import is still running...\"\")\n    import_jobs = Repo.all(\n      from j in Oban.Job,\n      where: j.worker in [\"\"Cinegraph.Workers.CanonicalImportOrchestrator\"\", \"\"Cinegraph.Workers.CanonicalPageWorker\"\"],\n      where: j.state in [\"\"executing\"\", \"\"available\"\", \"\"retryable\"\"],\n      select: %{worker: j.worker, state: j.state, args: j.args}\n    )\n    \n    if length(import_jobs) > 0 do\n      IO.puts(\"\"  🔄 Import still running: #{length(import_jobs)} jobs\"\")\n      Enum.each(import_jobs, fn job ->\n        IO.puts(\"\"    #{job.worker}: #{job.state}\"\")\n      end)\n    else\n      IO.puts(\"\"  ⏹️  No active import jobs - import may be complete\"\")\n    end\n  end\nelse\n  IO.puts(\"\"\\\\n⚠️  No Cannes movies found yet\"\")\n  \n  # Check if import jobs are running\n  import_jobs = Repo.all(\n    from j in Oban.Job,\n    where: j.worker in [\"\"Cinegraph.Workers.CanonicalImportOrchestrator\"\", \"\"Cinegraph.Workers.CanonicalPageWorker\"\"],\n    where: j.state in [\"\"executing\"\", \"\"available\"\", \"\"retryable\"\"],\n    select: %{worker: j.worker, state: j.state}\n  )\n  \n  if length(import_jobs) > 0 do\n    IO.puts(\"\"  🔄 Import jobs still running: #{length(import_jobs)}\"\")\n  else\n    IO.puts(\"\"  ❓ No import jobs found\"\")\n  end\nend\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres mix run -e '\nIO.puts(\"\"=== Auditing Current Cannes Import Status ===\"\")\n\nimport Ecto.Query\nalias Cinegraph.Repo\n\n# Check if any Cannes movies have been imported\ncannes_movies = Repo.all(\n  from m in Cinegraph.Movies.Movie,\n  where: fragment(\"\"? ? ?\"\", m.canonical_sources, \"\"?\"\", \"\"cannes_winners\"\"),\n  select: %{\n    id: m.id,\n    title: m.title,\n    imdb_id: m.imdb_id,\n    cannes_data: fragment(\"\"? -> ?\"\", m.canonical_sources, \"\"cannes_winners\"\")\n  },\n  limit: 10\n)\n\nIO.puts(\"\"Found #{length(cannes_movies)} Cannes movies in database\"\")\n\nif length(cannes_movies) > 0 do\n  IO.puts(\"\"\\n=== Sample Cannes Movies ===\"\")\n  \n  Enum.each(cannes_movies, fn movie ->\n    IO.puts(\"\"\\n#{movie.title} (#{movie.imdb_id})\"\")\n    \n    cannes_data = movie.cannes_data\n    \n    # Check specifically for extracted_awards\n    extracted_awards = get_in(cannes_data, [\"\"extracted_awards\"\"])\n    award_text = get_in(cannes_data, [\"\"award_text\"\"])\n    list_position = get_in(cannes_data, [\"\"list_position\"\"])\n    scraped_at = get_in(cannes_data, [\"\"scraped_at\"\"])\n    \n    IO.puts(\"\"  Position: #{list_position}\"\")\n    IO.puts(\"\"  Scraped at: #{scraped_at}\"\")\n    IO.puts(\"\"  Award text: #{if award_text, do: String.slice(award_text, 0, 100), else: \"\"nil\"\"}...\"\")\n    \n    if extracted_awards do\n      IO.puts(\"\"  ✅ HAS extracted_awards: #{inspect(extracted_awards)}\"\")\n    else\n      IO.puts(\"\"  ❌ NO extracted_awards field\"\")\n    end\n  end)\n  \n  # Count how many have extracted_awards\n  with_awards = Enum.count(cannes_movies, fn movie ->\n    get_in(movie.cannes_data, [\"\"extracted_awards\"\"]) != nil\n  end)\n  \n  IO.puts(\"\"\\n📊 Summary:\"\")\n  IO.puts(\"\"  Movies with extracted_awards: #{with_awards}/#{length(cannes_movies)}\"\")\n  \n  if with_awards > 0 do\n    IO.puts(\"\"  ✅ SUCCESS: Award extraction is working!\"\")\n  else\n    IO.puts(\"\"  ❌ ISSUE: No movies have extracted_awards yet\"\")\n    \n    # Check if import is still running\n    IO.puts(\"\"\\n🔍 Checking if import is still running...\"\")\n    import_jobs = Repo.all(\n      from j in Oban.Job,\n      where: j.worker in [\"\"Cinegraph.Workers.CanonicalImportOrchestrator\"\", \"\"Cinegraph.Workers.CanonicalPageWorker\"\"],\n      where: j.state in [\"\"executing\"\", \"\"available\"\", \"\"retryable\"\"]\n    )\n    \n    if length(import_jobs) > 0 do\n      IO.puts(\"\"  🔄 Import still running: #{length(import_jobs)} jobs\"\")\n    else\n      IO.puts(\"\"  ⏹️  No active import jobs - import may be complete\"\")\n    end\n  end\nelse\n  IO.puts(\"\"\\n⚠️  No Cannes movies found yet\"\")\nend\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres mix run test_server_code_version.exs)",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres mix run test_direct_import.exs)",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres mix run -e '\nimport Ecto.Query\nalias Cinegraph.Repo\n\n# Check if import jobs are running\nimport_jobs = Repo.all(\n  from j in Oban.Job,\n  where: j.worker in [\"\"Cinegraph.Workers.CanonicalImportOrchestrator\"\", \"\"Cinegraph.Workers.CanonicalPageWorker\"\"],\n  where: j.state in [\"\"executing\"\", \"\"available\"\", \"\"retryable\"\"],\n  select: %{id: j.id, worker: j.worker, state: j.state, args: j.args}\n)\n\nIO.puts(\"\"=== Import Job Status ===\"\")\nif length(import_jobs) > 0 do\n  IO.puts(\"\"Found #{length(import_jobs)} active import jobs:\"\")\n  Enum.each(import_jobs, fn job ->\n    worker_short = String.replace(job.worker, \"\"Cinegraph.Workers.\"\", \"\"\"\")\n    IO.puts(\"\"  #{job.id}: #{worker_short} (#{job.state})\"\")\n  end)\nelse\n  IO.puts(\"\"No active import jobs found\"\")\nend\n\n# Check total movies\ntotal_movies = Repo.aggregate(Cinegraph.Movies.Movie, :count)\nIO.puts(\"\"\\\\nTotal movies in database: #{total_movies}\"\")\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres mix run -e '\nimport Ecto.Query\nalias Cinegraph.Repo\n\n# Check all jobs related to import\njobs = Repo.all(\n  from j in Oban.Job,\n  where: j.worker in [\"\"Cinegraph.Workers.CanonicalImportOrchestrator\"\", \"\"Cinegraph.Workers.CanonicalPageWorker\"\", \"\"Cinegraph.Workers.TMDbDetailsWorker\"\"],\n  where: j.state in [\"\"executing\"\", \"\"available\"\", \"\"retryable\"\", \"\"scheduled\"\"],\n  order_by: [desc: j.id],\n  limit: 10,\n  select: %{id: j.id, worker: j.worker, state: j.state, inserted_at: j.inserted_at}\n)\n\nIO.puts(\"\"=== Recent Import-Related Jobs ===\"\")\nif length(jobs) > 0 do\n  Enum.each(jobs, fn job ->\n    worker_short = String.replace(job.worker, \"\"Cinegraph.Workers.\"\", \"\"\"\")\n    inserted_time = job.inserted_at |> DateTime.to_string()\n    IO.puts(\"\"#{job.id}: #{worker_short} (#{job.state}) - #{inserted_time}\"\")\n  end)\nelse\n  IO.puts(\"\"No recent import-related jobs found\"\")\nend\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres mix run debug_worker_path.exs)",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres mix compile)",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres mix run test_complete_pipeline.exs)",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres mix run -e '\nimport Ecto.Query\nalias Cinegraph.Repo\n\n# Check job status\njob = Repo.get(Oban.Job, 14098)\nif job do\n  IO.puts(\"\"Job 14098 status: #{job.state}\"\")\n  if job.state == \"\"completed\"\" do\n    IO.puts(\"\"✅ Job completed successfully\"\")\n  else\n    IO.puts(\"\"Job not completed yet, state: #{job.state}\"\")\n  end\nelse\n  IO.puts(\"\"Job not found\"\")\nend\n\n# Check for any Cannes movies\n{:ok, result} = Repo.query(\"\"SELECT COUNT(*) FROM movies WHERE canonical_sources ? ?\"\", [\"\"cannes_winners\"\"])\n[[count]] = result.rows\nIO.puts(\"\"Cannes movies in database: #{count}\"\")\n\n# Check for movies with extracted_awards\n{:ok, result2} = Repo.query(\"\"SELECT COUNT(*) FROM movies WHERE canonical_sources -> ? -> ? IS NOT NULL\"\", [\"\"cannes_winners\"\", \"\"extracted_awards\"\"])\n[[with_awards]] = result2.rows\nIO.puts(\"\"Movies with extracted_awards: #{with_awards}\"\")\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres mix run -e '\nimport Ecto.Query\nalias Cinegraph.Repo\n\n# Check all recent jobs\njobs = Repo.all(\n  from j in Oban.Job,\n  where: j.id >= 14098,\n  order_by: [desc: j.id],\n  limit: 10,\n  select: %{id: j.id, worker: j.worker, state: j.state, inserted_at: j.inserted_at}\n)\n\nIO.puts(\"\"=== Recent Jobs (>= 14098) ===\"\")\nEnum.each(jobs, fn job ->\n  worker_short = String.replace(job.worker, \"\"Cinegraph.Workers.\"\", \"\"\"\")\n  IO.puts(\"\"#{job.id}: #{worker_short} (#{job.state})\"\")\nend)\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres mix run -e '\nimport Ecto.Query\nalias Cinegraph.Repo\n\n# Check the main job\njob = Repo.get(Oban.Job, 14098)\nIO.puts(\"\"CanonicalPageWorker 14098 status: #{job.state}\"\")\n\nif job.state == \"\"failed\"\" and job.errors do\n  IO.puts(\"\"❌ Job failed with errors:\"\")\n  IO.puts(inspect(job.errors))\nend\n\n# Check for any TMDbDetailsWorker jobs created after our test\ndetail_jobs = Repo.all(\n  from j in Oban.Job,\n  where: j.worker == \"\"Cinegraph.Workers.TMDbDetailsWorker\"\" and j.id > 14098,\n  order_by: [desc: j.id],\n  limit: 5,\n  select: %{id: j.id, state: j.state, args: j.args}\n)\n\nIO.puts(\"\"\\\\nTMDbDetailsWorker jobs created after 14098:\"\")\nif length(detail_jobs) > 0 do\n  Enum.each(detail_jobs, fn job ->\n    imdb_id = get_in(job.args, [\"\"imdb_id\"\"])\n    IO.puts(\"\"  #{job.id}: #{job.state} (#{imdb_id})\"\")\n  end)\nelse\n  IO.puts(\"\"  No TMDbDetailsWorker jobs found\"\")\nend\n\n# Final check for Cannes data\n{:ok, result} = Repo.query(\"\"SELECT COUNT(*) FROM movies WHERE canonical_sources ? $1\"\", [\"\"cannes_winners\"\"])\n[[count]] = result.rows\nIO.puts(\"\"\\\\nCannes movies in database: #{count}\"\")\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres mix run -e '\n# Deep dive analysis of awards JSON with fixed JSONB queries\nIO.puts(\"\"🔍 === Deep Dive Awards JSON Analysis ===\"\")\nIO.puts(\"\"Analyzing award data quality across all three festivals\"\")\n\nimport Ecto.Query\nalias Cinegraph.Repo\n\n# 1. Overall Festival Statistics\nIO.puts(\"\"\\n📊 === Festival Overview ===\"\")\n\nfestivals = [\n  {\"\"cannes_winners\"\", \"\"Cannes Film Festival\"\"},\n  {\"\"berlin_golden_bear\"\", \"\"Berlin International Film Festival\"\"},\n  {\"\"venice_golden_lion\"\", \"\"Venice International Film Festival\"\"}\n]\n\nfestival_stats = Enum.map(festivals, fn {source_key, name} ->\n  {:ok, result} = Repo.query(\"\"SELECT COUNT(*) FROM movies WHERE canonical_sources ? $1\"\", [source_key])\n  [[count]] = result.rows\n  \n  # Check extraction rates\n  {:ok, award_result} = Repo.query(\"\"SELECT COUNT(*) FROM movies WHERE canonical_sources -> $1 ->> \\\"\"extracted_awards\\\"\" IS NOT NULL\"\", [source_key])\n  [[with_awards]] = award_result.rows\n  \n  {:ok, text_result} = Repo.query(\"\"SELECT COUNT(*) FROM movies WHERE canonical_sources -> $1 ->> \\\"\"award_text\\\"\" IS NOT NULL\"\", [source_key])\n  [[with_text]] = text_result.rows\n  \n  %{\n    source_key: source_key,\n    name: name,\n    total_movies: count,\n    with_extracted_awards: with_awards,\n    with_award_text: with_text,\n    extraction_rate: if(count > 0, do: Float.round(with_awards / count * 100, 1), else: 0)\n  }\nend)\n\nEnum.each(festival_stats, fn stat ->\n  IO.puts(\"\"#{stat.name}:\"\")\n  IO.puts(\"\"  Total movies: #{stat.total_movies}\"\")\n  IO.puts(\"\"  With extracted_awards: #{stat.with_extracted_awards} (#{stat.extraction_rate}%)\"\")\n  IO.puts(\"\"  With award_text: #{stat.with_award_text}\"\")\n  IO.puts(\"\"\"\")\nend)\n\ntotal_movies = Enum.sum(Enum.map(festival_stats, & &1.total_movies))\ntotal_with_awards = Enum.sum(Enum.map(festival_stats, & &1.with_extracted_awards))\noverall_rate = if total_movies > 0, do: Float.round(total_with_awards / total_movies * 100, 1), else: 0\n\nIO.puts(\"\"🎯 Overall Statistics:\"\")\nIO.puts(\"\"  Total festival movies: #{total_movies}\"\")\nIO.puts(\"\"  Total with awards: #{total_with_awards}\"\")\nIO.puts(\"\"  Overall extraction rate: #{overall_rate}%\"\")\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres mix run -e '\n# Deep dive analysis with corrected JSONB queries\nIO.puts(\"\"🔍 === Deep Dive Awards JSON Analysis ===\"\")\n\nimport Ecto.Query\nalias Cinegraph.Repo\n\n# 1. Festival Overview with correct JSONB syntax\nIO.puts(\"\"\\n📊 === Festival Overview ===\"\")\n\nfestivals = [\n  {\"\"cannes_winners\"\", \"\"Cannes Film Festival\"\"},\n  {\"\"berlin_golden_bear\"\", \"\"Berlin International Film Festival\"\"}, \n  {\"\"venice_golden_lion\"\", \"\"Venice International Film Festival\"\"}\n]\n\nfestival_stats = Enum.map(festivals, fn {source_key, name} ->\n  # Total movies\n  {:ok, result} = Repo.query(\"\"SELECT COUNT(*) FROM movies WHERE canonical_sources ? $1\"\", [source_key])\n  [[count]] = result.rows\n  \n  # Movies with extracted_awards (correct JSONB path)\n  {:ok, award_result} = Repo.query(\"\"SELECT COUNT(*) FROM movies WHERE canonical_sources -> $1 -> \\\"\"extracted_awards\\\"\" IS NOT NULL\"\", [source_key])\n  [[with_awards]] = award_result.rows\n  \n  # Movies with award_text\n  {:ok, text_result} = Repo.query(\"\"SELECT COUNT(*) FROM movies WHERE canonical_sources -> $1 -> \\\"\"award_text\\\"\" IS NOT NULL\"\", [source_key])\n  [[with_text]] = text_result.rows\n  \n  %{\n    source_key: source_key,\n    name: name,\n    total_movies: count,\n    with_extracted_awards: with_awards,\n    with_award_text: with_text,\n    extraction_rate: if(count > 0, do: Float.round(with_awards / count * 100, 1), else: 0)\n  }\nend)\n\nEnum.each(festival_stats, fn stat ->\n  IO.puts(\"\"#{stat.name}:\"\")\n  IO.puts(\"\"  Total movies: #{stat.total_movies}\"\")\n  IO.puts(\"\"  With extracted_awards: #{stat.with_extracted_awards} (#{stat.extraction_rate}%)\"\")\n  IO.puts(\"\"  With award_text: #{stat.with_award_text}\"\")\n  IO.puts(\"\"\"\")\nend)\n\ntotal_movies = Enum.sum(Enum.map(festival_stats, & &1.total_movies))\ntotal_with_awards = Enum.sum(Enum.map(festival_stats, & &1.with_extracted_awards))\noverall_rate = if total_movies > 0, do: Float.round(total_with_awards / total_movies * 100, 1), else: 0\n\nIO.puts(\"\"🎯 Overall Statistics:\"\")\nIO.puts(\"\"  Total festival movies: #{total_movies}\"\")\nIO.puts(\"\"  Total with awards: #{total_with_awards}\"\")\nIO.puts(\"\"  Overall extraction rate: #{overall_rate}%\"\")\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres mix run -e '\n# Deep dive analysis with correct understanding of data structure\nIO.puts(\"\"🔍 === Deep Dive Awards JSON Analysis ===\"\")\n\nimport Ecto.Query\nalias Cinegraph.Repo\n\n# 1. Festival Overview Statistics\nIO.puts(\"\"\\n📊 === Festival Overview ===\"\")\n\nfestivals = [\n  {\"\"cannes_winners\"\", \"\"Cannes Film Festival\"\"},\n  {\"\"berlin_golden_bear\"\", \"\"Berlin International Film Festival\"\"}, \n  {\"\"venice_golden_lion\"\", \"\"Venice International Film Festival\"\"}\n]\n\nfestival_stats = Enum.map(festivals, fn {source_key, name} ->\n  # Use direct SQL queries to avoid JSONB operator issues in Ecto\n  {:ok, total_result} = Repo.query(\"\"SELECT COUNT(*) FROM movies WHERE canonical_sources ? $1\"\", [source_key])\n  [[total_count]] = total_result.rows\n  \n  # Check for extracted_awards presence\n  {:ok, awards_result} = Repo.query(\n    \"\"SELECT COUNT(*) FROM movies WHERE canonical_sources -> $1 -> $2 IS NOT NULL\"\", \n    [source_key, \"\"extracted_awards\"\"]\n  )\n  [[awards_count]] = awards_result.rows\n  \n  # Check for award_text presence\n  {:ok, text_result} = Repo.query(\n    \"\"SELECT COUNT(*) FROM movies WHERE canonical_sources -> $1 -> $2 IS NOT NULL\"\", \n    [source_key, \"\"award_text\"\"]\n  )\n  [[text_count]] = text_result.rows\n  \n  extraction_rate = if total_count > 0, do: Float.round(awards_count / total_count * 100, 1), else: 0\n  \n  %{\n    source_key: source_key,\n    name: name,\n    total_movies: total_count,\n    with_extracted_awards: awards_count,\n    with_award_text: text_count,\n    extraction_rate: extraction_rate\n  }\nend)\n\nEnum.each(festival_stats, fn stat ->\n  IO.puts(\"\"#{stat.name}:\"\")\n  IO.puts(\"\"  Total movies: #{stat.total_movies}\"\")\n  IO.puts(\"\"  With extracted_awards: #{stat.with_extracted_awards} (#{stat.extraction_rate}%)\"\")\n  IO.puts(\"\"  With award_text: #{stat.with_award_text}\"\")\n  IO.puts(\"\"\"\")\nend)\n\ntotal_movies = Enum.sum(Enum.map(festival_stats, & &1.total_movies))\ntotal_with_awards = Enum.sum(Enum.map(festival_stats, & &1.with_extracted_awards))\noverall_rate = if total_movies > 0, do: Float.round(total_with_awards / total_movies * 100, 1), else: 0\n\nIO.puts(\"\"🎯 Overall Statistics:\"\")\nIO.puts(\"\"  Total festival movies: #{total_movies}\"\")\nIO.puts(\"\"  Total with awards: #{total_with_awards}\"\")\nIO.puts(\"\"  Overall extraction rate: #{overall_rate}%\"\")\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres mix run -e '\n# Detailed award quality analysis\nIO.puts(\"\"\\n🏆 === Award Quality Analysis ===\"\")\n\nimport Ecto.Query\nalias Cinegraph.Repo\n\n# 2. Award Structure Quality by Festival\nfestivals = [\n  {\"\"cannes_winners\"\", \"\"Cannes Film Festival\"\"},\n  {\"\"berlin_golden_bear\"\", \"\"Berlin International Film Festival\"\"}, \n  {\"\"venice_golden_lion\"\", \"\"Venice International Film Festival\"\"}\n]\n\nEnum.each(festivals, fn {source_key, name} ->\n  IO.puts(\"\"\\n=== #{name} ===\"\")\n  \n  # Get sample awards to understand structure\n  {:ok, sample_result} = Repo.query(\"\"\"\"\"\"\n    SELECT title, canonical_sources -> $1 -> $2 as awards,\n           canonical_sources -> $1 -> $3 as award_text\n    FROM movies \n    WHERE canonical_sources ? $1 \n    LIMIT 5\n  \"\"\"\"\"\", [source_key, \"\"extracted_awards\"\", \"\"award_text\"\"])\n  \n  award_types = %{}\n  total_awards = 0\n  awards_with_year = 0\n  awards_with_category = 0\n  \n  Enum.each(sample_result.rows, fn [title, awards_json, award_text] ->\n    if awards_json do\n      awards = Jason.decode!(awards_json)\n      total_awards = total_awards + length(awards)\n      \n      Enum.each(awards, fn award ->\n        # Count structured fields\n        if award[\"\"award_year\"\"], do: awards_with_year = awards_with_year + 1\n        if award[\"\"award_category\"\"], do: awards_with_category = awards_with_category + 1\n        \n        # Track award types\n        award_name = award[\"\"award_name\"\"] || \"\"Unknown\"\"\n        award_types = Map.update(award_types, award_name, 1, &(&1 + 1))\n      end)\n      \n      IO.puts(\"\"#{title}:\"\")\n      IO.puts(\"\"  Award text: #{String.slice(award_text || \"\"\"\", 0, 60)}...\"\")\n      IO.puts(\"\"  Structured awards: #{length(awards)}\"\")\n      Enum.each(awards, fn award ->\n        year_info = if award[\"\"award_year\"\"], do: \"\" (#{award[\"\"award_year\"\"]})\"\", else: \"\"\"\"\n        category_info = if award[\"\"award_category\"\"], do: \"\" - #{award[\"\"award_category\"\"]}\"\", else: \"\"\"\"\n        IO.puts(\"\"    - #{award[\"\"award_name\"\"]}#{year_info}#{category_info}\"\")\n      end)\n      IO.puts(\"\"\"\")\n    end\n  end)\n  \n  IO.puts(\"\"Quality Metrics:\"\")\n  IO.puts(\"\"  Total sample awards: #{total_awards}\"\")\n  IO.puts(\"\"  Awards with year: #{awards_with_year} (#{if total_awards > 0, do: Float.round(awards_with_year/total_awards*100, 1), else: 0}%)\"\")\n  IO.puts(\"\"  Awards with category: #{awards_with_category} (#{if total_awards > 0, do: Float.round(awards_with_category/total_awards*100, 1), else: 0}%)\"\")\n  \n  IO.puts(\"\"\\nAward Types Found:\"\")\n  award_types\n  |> Enum.sort_by(fn {_, count} -> count end, :desc)\n  |> Enum.take(10)\n  |> Enum.each(fn {name, count} ->\n    IO.puts(\"\"  #{name}: #{count}\"\")\n  end)\nend)\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres mix run -e '\n# Detailed award quality analysis\nIO.puts(\"\"\\n🏆 === Award Quality Analysis ===\"\")\n\nimport Ecto.Query\nalias Cinegraph.Repo\n\n# 2. Award Structure Quality by Festival\nfestivals = [\n  {\"\"cannes_winners\"\", \"\"Cannes Film Festival\"\"},\n  {\"\"berlin_golden_bear\"\", \"\"Berlin International Film Festival\"\"}, \n  {\"\"venice_golden_lion\"\", \"\"Venice International Film Festival\"\"}\n]\n\nEnum.each(festivals, fn {source_key, name} ->\n  IO.puts(\"\"\\n=== #{name} ===\"\")\n  \n  # Get sample awards to understand structure\n  {:ok, sample_result} = Repo.query(\"\"\"\"\"\"\n    SELECT title, canonical_sources -> $1 -> $2 as awards,\n           canonical_sources -> $1 -> $3 as award_text\n    FROM movies \n    WHERE canonical_sources ? $1 \n    LIMIT 5\n  \"\"\"\"\"\", [source_key, \"\"extracted_awards\"\", \"\"award_text\"\"])\n  \n  total_awards = 0\n  awards_with_year = 0\n  awards_with_category = 0\n  award_types = []\n  \n  Enum.each(sample_result.rows, fn [title, awards_json, award_text] ->\n    if awards_json do\n      # Awards are already parsed as Elixir data structures from JSONB\n      awards = if is_binary(awards_json), do: Jason.decode!(awards_json), else: awards_json\n      total_awards = total_awards + length(awards)\n      \n      Enum.each(awards, fn award ->\n        # Count structured fields\n        if award[\"\"award_year\"\"], do: awards_with_year = awards_with_year + 1\n        if award[\"\"award_category\"\"], do: awards_with_category = awards_with_category + 1\n        \n        # Track award types\n        award_name = award[\"\"award_name\"\"] || \"\"Unknown\"\"\n        award_types = [award_name | award_types]\n      end)\n      \n      IO.puts(\"\"#{title}:\"\")\n      IO.puts(\"\"  Award text: #{String.slice(award_text || \\\"\"\\\"\", 0, 60)}...\"\")\n      IO.puts(\"\"  Structured awards: #{length(awards)}\"\")\n      Enum.each(awards, fn award ->\n        year_info = if award[\"\"award_year\"\"], do: \"\" (#{award[\"\"award_year\"\"]})\"\", else: \"\"\"\"\n        category_info = if award[\"\"award_category\"\"], do: \"\" - #{award[\"\"award_category\"\"]}\"\", else: \"\"\"\"\n        IO.puts(\"\"    - #{award[\"\"award_name\"\"]}#{year_info}#{category_info}\"\")\n      end)\n      IO.puts(\"\"\"\")\n    end\n  end)\n  \n  IO.puts(\"\"Quality Metrics:\"\")\n  IO.puts(\"\"  Total sample awards: #{total_awards}\"\")\n  IO.puts(\"\"  Awards with year: #{awards_with_year} (#{if total_awards > 0, do: Float.round(awards_with_year/total_awards*100, 1), else: 0}%)\"\")\n  IO.puts(\"\"  Awards with category: #{awards_with_category} (#{if total_awards > 0, do: Float.round(awards_with_category/total_awards*100, 1), else: 0}%)\"\")\n  \n  IO.puts(\"\"\\nAward Types Found:\"\")\n  award_types\n  |> Enum.frequencies()\n  |> Enum.sort_by(fn {_, count} -> count end, :desc)\n  |> Enum.take(10)\n  |> Enum.each(fn {name, count} ->\n    IO.puts(\"\"  #{name}: #{count}\"\")\n  end)\nend)\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres mix run awards_quality_analysis.exs)",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT jsonb_pretty(data) FROM oscar_ceremonies WHERE year = 2024 LIMIT 1;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT id, name, imdb_id FROM people WHERE name LIKE ''%Oppenheimer%'' OR name LIKE ''%Maestro%'' OR name = ''Cillian Murphy'' OR name = ''Bradley Cooper'' LIMIT 10;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT on.id, on.person_id, on.won, on.details, p.name as person_name, m.title as movie_title FROM oscar_nominations on LEFT JOIN people p ON on.person_id = p.id LEFT JOIN movies m ON on.movie_id = m.id WHERE on.ceremony_id = (SELECT id FROM oscar_ceremonies WHERE year = 2024) LIMIT 10;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT nom.id, nom.person_id, nom.won, nom.details, p.name as person_name, m.title as movie_title FROM oscar_nominations nom LEFT JOIN people p ON nom.person_id = p.id LEFT JOIN movies m ON nom.movie_id = m.id WHERE nom.ceremony_id = (SELECT id FROM oscar_ceremonies WHERE year = 2024) LIMIT 10;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT jsonb_pretty(data -> ''categories'' -> 0 -> ''nominees'' -> 0) FROM oscar_ceremonies WHERE year = 2024;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT nom.id, nom.person_id, nom.won, nom.details, p.name as person_name, m.title as movie_title FROM oscar_nominations nom LEFT JOIN people p ON nom.person_id = p.id LEFT JOIN movies m ON nom.movie_id = m.id WHERE m.title = ''Oppenheimer'' AND nom.ceremony_id = (SELECT id FROM oscar_ceremonies WHERE year = 2024) LIMIT 5;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT name, tracks_person FROM oscar_categories WHERE name = ''Actor in a Leading Role'' OR name LIKE ''%Best Picture%'' OR name LIKE ''%Animated Feature%'';\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=3ba3f8f9 mix run -e '\n# Test the data flow by examining one ceremony\nceremony = Cinegraph.Cultural.list_oscar_ceremonies() |> Enum.find(&(&1.year == 2024))\n\nif ceremony do\n  # Get first category (Actor in a Leading Role)\n  first_category = ceremony.data[\"\"categories\"\"] |> List.first()\n  first_nominee = first_category[\"\"nominees\"\"] |> List.first()\n  \n  IO.puts(\"\"=== Debug Oscar Nomination Data Flow ===\"\")\n  IO.puts(\"\"Category: #{first_category[\"\"category\"\"]}\"\")\n  IO.puts(\"\"Raw nominee data:\"\")\n  IO.inspect(first_nominee, pretty: true)\n  IO.puts(\"\"\"\") \n  IO.puts(\"\"Key fields:\"\")\n  IO.puts(\"\"  nominee[\\\"\"name\\\"\"]: #{first_nominee[\"\"name\"\"]}\"\")\n  IO.puts(\"\"  nominee[\\\"\"film\\\"\"]: #{first_nominee[\"\"film\"\"]}\"\")  \n  IO.puts(\"\"  nominee[\\\"\"person_imdb_ids\\\"\"]: #{inspect(first_nominee[\"\"person_imdb_ids\"\"])}\"\")\nelse\n  IO.puts(\"\"No 2024 ceremony found\"\")\nend\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=3ba3f8f9 mix run -e '\n# Test what happens during nomination creation\nceremony = Cinegraph.Cultural.list_oscar_ceremonies() |> Enum.find(&(&1.year == 2024))\n\nif ceremony do\n  # Get the Oppenheimer movie\n  movie = Cinegraph.Movies.get_movie_by_imdb_id(\"\"tt15398776\"\")\n  \n  if movie do\n    IO.puts(\"\"Found movie: #{movie.title}\"\")\n    \n    # Get first category and nominee\n    first_category = ceremony.data[\"\"categories\"\"] |> List.first()\n    first_nominee = first_category[\"\"nominees\"\"] |> List.first()\n    category_name = first_category[\"\"category\"\"]\n    \n    IO.puts(\"\"Processing nominee: #{first_nominee[\"\"name\"\"]} for #{first_nominee[\"\"film\"\"]}\"\")\n    \n    # Check if the category exists and tracks person\n    category = Cinegraph.Repo.get_by(Cinegraph.Cultural.OscarCategory, name: category_name)\n    \n    if category do\n      IO.puts(\"\"Category found: #{category.name}, tracks_person: #{category.tracks_person}\"\")\n      \n      # Check what the nomination attrs would be\n      attrs = %{\n        ceremony_id: ceremony.id,\n        category_id: category.id,\n        movie_id: movie.id,\n        person_id: nil, # We will debug this separately\n        won: first_nominee[\"\"winner\"\"] || false,\n        details: %{\n          \"\"nominee_names\"\" => first_nominee[\"\"name\"\"],\n          \"\"person_imdb_ids\"\" => first_nominee[\"\"person_imdb_ids\"\"] || []\n        }\n      }\n      \n      IO.puts(\"\"Nomination attrs that would be created:\"\")\n      IO.inspect(attrs, pretty: true)\n    else\n      IO.puts(\"\"Category not found: #{category_name}\"\")\n    end\n  else\n    IO.puts(\"\"Movie not found for IMDb ID: tt15398776\"\")\n  end\nelse\n  IO.puts(\"\"No 2024 ceremony found\"\")\nend\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\\d oscar_nominations\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"DELETE FROM oscar_nominations WHERE id IN (SELECT id FROM oscar_nominations WHERE ceremony_id = (SELECT id FROM oscar_ceremonies WHERE year = 2024) LIMIT 3);\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=3ba3f8f9 mix run -e '\n# Test re-importing 2024 ceremony\nceremony = Cinegraph.Cultural.list_oscar_ceremonies() |> Enum.find(&(&1.year == 2024))\n\nif ceremony do\n  IO.puts(\"\"Re-importing 2024 ceremony...\"\")\n  result = Cinegraph.Cultural.OscarImporter.import_ceremony(ceremony)\n  IO.inspect(result, label: \"\"Import Result\"\")\n  \n  # Check what nominations were created\n  Process.sleep(2000)\n  \n  import Ecto.Query\n  new_nominations = Cinegraph.Repo.all(\n    from n in Cinegraph.Cultural.OscarNomination,\n    where: n.ceremony_id == ^ceremony.id,\n    limit: 5,\n    select: %{\n      id: n.id,\n      won: n.won,\n      details: n.details\n    }\n  )\n  \n  IO.puts(\"\"\\nFirst 5 nominations after re-import:\"\")\n  Enum.each(new_nominations, fn nom ->\n    nominee_names = nom.details[\"\"nominee_names\"\"]\n    person_imdb_ids = nom.details[\"\"person_imdb_ids\"\"]\n    IO.puts(\"\"  ID #{nom.id}: #{nominee_names} (IMDb: #{inspect(person_imdb_ids)})\"\")\n  end)\nelse\n  IO.puts(\"\"No 2024 ceremony found\"\")\nend\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT id, details FROM oscar_nominations WHERE ceremony_id = (SELECT id FROM oscar_ceremonies WHERE year = 2024) AND category_id = (SELECT id FROM oscar_categories WHERE name = ''Actor in a Leading Role'') AND movie_id = (SELECT id FROM movies WHERE imdb_id = ''tt5535276'');\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"DELETE FROM oscar_nominations WHERE ceremony_id = (SELECT id FROM oscar_ceremonies WHERE year = 2024);\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=3ba3f8f9 mix run -e '\n# Test re-importing 2024 ceremony with fixes\nceremony = Cinegraph.Cultural.list_oscar_ceremonies() |> Enum.find(&(&1.year == 2024))\n\nif ceremony do\n  IO.puts(\"\"Re-importing 2024 ceremony with bug fixes...\"\")\n  result = Cinegraph.Cultural.OscarImporter.import_ceremony(ceremony)\n  IO.inspect(result, label: \"\"Import Result\"\")\n  \n  # Check what nominations were created\n  Process.sleep(2000)\n  \n  import Ecto.Query\n  sample_nominations = Cinegraph.Repo.all(\n    from n in Cinegraph.Cultural.OscarNomination,\n    join: c in Cinegraph.Cultural.OscarCategory, on: n.category_id == c.id,\n    join: m in Cinegraph.Movies.Movie, on: n.movie_id == m.id,\n    left_join: p in Cinegraph.Movies.Person, on: n.person_id == p.id,\n    where: n.ceremony_id == ^ceremony.id and c.tracks_person == true,\n    limit: 5,\n    select: %{\n      id: n.id,\n      category: c.name,\n      movie_title: m.title,\n      person_name: p.name,\n      person_id: n.person_id,\n      nominee_names: fragment(\"\"? ->> ?\"\", n.details, \"\"nominee_names\"\"),\n      person_imdb_ids: fragment(\"\"? -> ?\"\", n.details, \"\"person_imdb_ids\"\")\n    }\n  )\n  \n  IO.puts(\"\"\\nFirst 5 person-based nominations:\"\")\n  Enum.each(sample_nominations, fn nom ->\n    person_status = if nom.person_id, do: \"\"✅ LINKED\"\", else: \"\"❌ NO LINK\"\"\n    IO.puts(\"\"  #{nom.category}: #{nom.nominee_names} (#{person_status})\"\")\n    IO.puts(\"\"    Movie: #{nom.movie_title}\"\")\n    if nom.person_name, do: IO.puts(\"\"    Person: #{nom.person_name}\"\")\n    IO.puts(\"\"    IMDb IDs: #{inspect(nom.person_imdb_ids)}\"\")\n    IO.puts(\"\"\"\")\n  end)\nelse\n  IO.puts(\"\"No 2024 ceremony found\"\")\nend\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=3ba3f8f9 mix run -e '\n# Test re-importing 2024 ceremony with simplified fix\nceremony = Cinegraph.Cultural.list_oscar_ceremonies() |> Enum.find(&(&1.year == 2024))\n\nif ceremony do\n  IO.puts(\"\"Re-importing 2024 ceremony...\"\")\n  result = Cinegraph.Cultural.OscarImporter.import_ceremony(ceremony)\n  IO.inspect(result, label: \"\"Import Result\"\")\n  \n  # Check what nominations were created\n  Process.sleep(1000)\n  \n  import Ecto.Query\n  sample_nominations = Cinegraph.Repo.all(\n    from n in Cinegraph.Cultural.OscarNomination,\n    join: c in Cinegraph.Cultural.OscarCategory, on: n.category_id == c.id,\n    join: m in Cinegraph.Movies.Movie, on: n.movie_id == m.id,\n    where: n.ceremony_id == ^ceremony.id and c.tracks_person == true,\n    limit: 5,\n    select: %{\n      category: c.name,\n      movie_title: m.title,\n      nominee_names: fragment(\"\"? ->> ?\"\", n.details, \"\"nominee_names\"\"),\n      person_imdb_ids: fragment(\"\"? -> ?\"\", n.details, \"\"person_imdb_ids\"\")\n    }\n  )\n  \n  IO.puts(\"\"\\nFirst 5 person-based nominations:\"\")\n  Enum.each(sample_nominations, fn nom ->\n    IO.puts(\"\"  #{nom.category}: #{nom.nominee_names}\"\")\n    IO.puts(\"\"    Movie: #{nom.movie_title}\"\")\n    IO.puts(\"\"    IMDb IDs: #{inspect(nom.person_imdb_ids)}\"\")\n    IO.puts(\"\"\"\")\n  end)\n  \n  # Check overall counts\n  total_noms = Cinegraph.Repo.one(\n    from n in Cinegraph.Cultural.OscarNomination,\n    where: n.ceremony_id == ^ceremony.id,\n    select: count(n.id)\n  )\n  \n  person_noms = Cinegraph.Repo.one(\n    from n in Cinegraph.Cultural.OscarNomination,\n    join: c in Cinegraph.Cultural.OscarCategory, on: n.category_id == c.id,\n    where: n.ceremony_id == ^ceremony.id and c.tracks_person == true,\n    select: count(n.id)\n  )\n  \n  IO.puts(\"\"📊 Totals: #{total_noms} nominations, #{person_noms} person-based\"\")\nelse\n  IO.puts(\"\"No 2024 ceremony found\"\")\nend\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT nom.id, c.name as category, m.title as movie, nom.details ->> ''nominee_names'' as person_name, nom.details -> ''person_imdb_ids'' as imdb_ids FROM oscar_nominations nom JOIN oscar_categories c ON nom.category_id = c.id JOIN movies m ON nom.movie_id = m.id WHERE nom.ceremony_id = (SELECT id FROM oscar_ceremonies WHERE year = 2024) AND c.tracks_person = true ORDER BY c.name, m.title LIMIT 10;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\n-- Overall Oscar nomination statistics\nSELECT \n  ''Total Nominations'' as metric,\n  COUNT(*) as count\nFROM oscar_nominations\nWHERE ceremony_id = (SELECT id FROM oscar_ceremonies WHERE year = 2024)\n\nUNION ALL\n\nSELECT \n  ''Person-based Categories'' as metric,\n  COUNT(*) as count\nFROM oscar_nominations nom\nJOIN oscar_categories cat ON nom.category_id = cat.id\nWHERE nom.ceremony_id = (SELECT id FROM oscar_ceremonies WHERE year = 2024)\n  AND cat.tracks_person = true\n\nUNION ALL\n\nSELECT \n  ''Film-based Categories'' as metric,\n  COUNT(*) as count\nFROM oscar_nominations nom\nJOIN oscar_categories cat ON nom.category_id = cat.id\nWHERE nom.ceremony_id = (SELECT id FROM oscar_ceremonies WHERE year = 2024)\n  AND cat.tracks_person = false\n\nUNION ALL\n\nSELECT \n  ''With Person Names'' as metric,\n  COUNT(*) as count\nFROM oscar_nominations nom\nJOIN oscar_categories cat ON nom.category_id = cat.id\nWHERE nom.ceremony_id = (SELECT id FROM oscar_ceremonies WHERE year = 2024)\n  AND cat.tracks_person = true\n  AND nom.details ->> ''nominee_names'' IS NOT NULL\n  AND nom.details ->> ''nominee_names'' != ''''\n\nUNION ALL\n\nSELECT \n  ''With IMDb IDs'' as metric,\n  COUNT(*) as count\nFROM oscar_nominations nom\nJOIN oscar_categories cat ON nom.category_id = cat.id\nWHERE nom.ceremony_id = (SELECT id FROM oscar_ceremonies WHERE year = 2024)\n  AND cat.tracks_person = true\n  AND jsonb_array_length(nom.details -> ''person_imdb_ids'') > 0;\n\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT ''Total 2024 Nominations'' as metric, COUNT(*) as count FROM oscar_nominations WHERE ceremony_id = (SELECT id FROM oscar_ceremonies WHERE year = 2024);\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT id, year FROM oscar_ceremonies ORDER BY year DESC LIMIT 5;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT COUNT(*) as total_nominations FROM oscar_nominations WHERE ceremony_id = 21;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT ceremony_id, COUNT(*) as count FROM oscar_nominations GROUP BY ceremony_id ORDER BY ceremony_id DESC;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\nSELECT \n  nom.id,\n  cer.year,\n  cat.name as category,\n  mov.title as movie,\n  nom.details ->> ''nominee_names'' as nominee_names,\n  nom.details -> ''person_imdb_ids'' as person_imdb_ids,\n  cat.tracks_person\nFROM oscar_nominations nom\nJOIN oscar_ceremonies cer ON nom.ceremony_id = cer.id\nJOIN oscar_categories cat ON nom.category_id = cat.id\nJOIN movies mov ON nom.movie_id = mov.id\nWHERE cat.tracks_person = true\nORDER BY nom.id DESC\nLIMIT 10;\n\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\nSELECT \n  nom.id,\n  cer.year,\n  cat.name as category,\n  mov.title as movie,\n  nom.details ->> ''nominee_names'' as nominee_names,\n  nom.details -> ''person_imdb_ids'' as person_imdb_ids\nFROM oscar_nominations nom\nJOIN oscar_ceremonies cer ON nom.ceremony_id = cer.id\nJOIN oscar_categories cat ON nom.category_id = cat.id\nJOIN movies mov ON nom.movie_id = mov.id\nWHERE cat.name LIKE ''Actor%'' OR cat.name LIKE ''Actress%''\nORDER BY nom.id DESC\nLIMIT 10;\n\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT name, tracks_person, COUNT(nom.id) as nomination_count FROM oscar_categories cat LEFT JOIN oscar_nominations nom ON cat.id = nom.category_id GROUP BY cat.id, cat.name, cat.tracks_person ORDER BY nomination_count DESC, cat.name;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=3ba3f8f9 mix run -e '\n# Test importing 2024 ceremony to see if acting nominations get created\nceremony = Cinegraph.Cultural.list_oscar_ceremonies() |> Enum.find(&(&1.year == 2024))\n\nif ceremony do\n  IO.puts(\"\"=== Testing 2024 Oscar Import ===\"\")\n  \n  # Check if we have the right ceremony ID\n  IO.puts(\"\"Ceremony: #{ceremony.year} (ID: #{ceremony.id})\"\")\n  \n  try do\n    result = Cinegraph.Cultural.OscarImporter.import_ceremony(ceremony)\n    IO.inspect(result, label: \"\"Import Result\"\")\n    \n    # Check what was created\n    Process.sleep(2000)\n    \n    import Ecto.Query\n    new_nominations = Cinegraph.Repo.all(\n      from n in Cinegraph.Cultural.OscarNomination,\n      join: c in Cinegraph.Cultural.OscarCategory, on: n.category_id == c.id,\n      where: n.ceremony_id == ^ceremony.id,\n      limit: 10,\n      select: %{\n        category: c.name,\n        tracks_person: c.tracks_person,\n        nominee_names: fragment(\"\"? ->> ?\"\", n.details, \"\"nominee_names\"\")\n      }\n    )\n    \n    IO.puts(\"\"\\nNominations created:\"\")\n    Enum.each(new_nominations, fn nom ->\n      person_indicator = if nom.tracks_person, do: \"\"[PERSON]\"\", else: \"\"[FILM]\"\"\n      IO.puts(\"\"  #{person_indicator} #{nom.category}: #{nom.nominee_names}\"\")\n    end)\n    \n  rescue\n    e -> IO.puts(\"\"Error during import: #{inspect(e)}\"\")\n  end\nelse\n  IO.puts(\"\"No 2024 ceremony found\"\")\nend\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\n-- Comprehensive Oscar Nomination Audit\nSELECT \n  ''Total 2024 Nominations'' as metric,\n  COUNT(*) as count\nFROM oscar_nominations \nWHERE ceremony_id = 21\n\nUNION ALL\n\nSELECT \n  ''Person-Based Categories'' as metric,\n  COUNT(*) as count\nFROM oscar_nominations nom\nJOIN oscar_categories cat ON nom.category_id = cat.id\nWHERE nom.ceremony_id = 21 AND cat.tracks_person = true\n\nUNION ALL\n\nSELECT \n  ''Film-Based Categories'' as metric,\n  COUNT(*) as count\nFROM oscar_nominations nom\nJOIN oscar_categories cat ON nom.category_id = cat.id\nWHERE nom.ceremony_id = 21 AND cat.tracks_person = false\n\nUNION ALL\n\nSELECT \n  ''Person Names Present'' as metric,\n  COUNT(*) as count\nFROM oscar_nominations nom\nJOIN oscar_categories cat ON nom.category_id = cat.id\nWHERE nom.ceremony_id = 21 \n  AND cat.tracks_person = true\n  AND nom.details ->> ''nominee_names'' IS NOT NULL\n  AND nom.details ->> ''nominee_names'' != ''''\n\nUNION ALL\n\nSELECT \n  ''Person IMDb IDs Present'' as metric,\n  COUNT(*) as count\nFROM oscar_nominations nom\nJOIN oscar_categories cat ON nom.category_id = cat.id\nWHERE nom.ceremony_id = 21\n  AND cat.tracks_person = true\n  AND jsonb_array_length(nom.details -> ''person_imdb_ids'') > 0;\n\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\n-- 2024 Oscar Nominations Comprehensive Audit\nSELECT \n    ''Total nominations'' as metric, \n    COUNT(*)::text as value \nFROM oscar_nominations nom \nWHERE nom.ceremony_id = (SELECT id FROM oscar_ceremonies WHERE year = 2024)\n\nUNION ALL\n\nSELECT \n    ''Person-based categories'' as metric,\n    COUNT(*)::text as value\nFROM oscar_nominations nom\nJOIN oscar_categories cat ON nom.category_id = cat.id\nWHERE nom.ceremony_id = (SELECT id FROM oscar_ceremonies WHERE year = 2024)\nAND cat.tracks_person = true\n\nUNION ALL\n\nSELECT \n    ''Film-based categories'' as metric,\n    COUNT(*)::text as value  \nFROM oscar_nominations nom\nJOIN oscar_categories cat ON nom.category_id = cat.id\nWHERE nom.ceremony_id = (SELECT id FROM oscar_ceremonies WHERE year = 2024)\nAND cat.tracks_person = false\n\nUNION ALL\n\nSELECT \n    ''Person nominations with person names'' as metric,\n    COUNT(*)::text as value\nFROM oscar_nominations nom\nJOIN oscar_categories cat ON nom.category_id = cat.id\nWHERE nom.ceremony_id = (SELECT id FROM oscar_ceremonies WHERE year = 2024)\nAND cat.tracks_person = true\nAND nom.details ->> ''nominee_names'' IS NOT NULL\nAND nom.details ->> ''nominee_names'' <> ''''\n\nUNION ALL\n\nSELECT \n    ''Person nominations with IMDb IDs'' as metric,\n    COUNT(*)::text as value\nFROM oscar_nominations nom\nJOIN oscar_categories cat ON nom.category_id = cat.id\nWHERE nom.ceremony_id = (SELECT id FROM oscar_ceremonies WHERE year = 2024)\nAND cat.tracks_person = true\nAND nom.details -> ''person_imdb_ids'' IS NOT NULL\n\nORDER BY metric;\n\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\n-- Sample person-based nominations to verify fix quality\nSELECT \n    cat.name as category,\n    m.title as movie,\n    nom.details ->> ''nominee_names'' as person_name,\n    nom.details -> ''person_imdb_ids'' as imdb_ids,\n    nom.won\nFROM oscar_nominations nom\nJOIN oscar_categories cat ON nom.category_id = cat.id  \nJOIN movies m ON nom.movie_id = m.id\nWHERE nom.ceremony_id = (SELECT id FROM oscar_ceremonies WHERE year = 2024)\nAND cat.tracks_person = true\nORDER BY cat.name, m.title\nLIMIT 10;\n\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\n-- Sample film-based nominations  \nSELECT \n    cat.name as category,\n    m.title as movie,\n    nom.details ->> ''nominee_names'' as stored_name,\n    nom.won\nFROM oscar_nominations nom\nJOIN oscar_categories cat ON nom.category_id = cat.id\nJOIN movies m ON nom.movie_id = m.id  \nWHERE nom.ceremony_id = (SELECT id FROM oscar_ceremonies WHERE year = 2024)\nAND cat.tracks_person = false\nORDER BY cat.name, m.title\nLIMIT 8;\n\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\n-- Final audit: Verify person names vs movie titles in person-based categories\nSELECT \n    CASE \n        WHEN nom.details ->> ''nominee_names'' = m.title THEN ''ERROR: Movie title stored''\n        WHEN nom.details ->> ''nominee_names'' != m.title THEN ''CORRECT: Person name stored''\n        ELSE ''UNKNOWN''\n    END as validation_result,\n    COUNT(*) as count\nFROM oscar_nominations nom\nJOIN oscar_categories cat ON nom.category_id = cat.id\nJOIN movies m ON nom.movie_id = m.id\nWHERE nom.ceremony_id = (SELECT id FROM oscar_ceremonies WHERE year = 2024)\nAND cat.tracks_person = true\nGROUP BY validation_result\nORDER BY validation_result;\n\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\n-- Final audit: Verify person names vs movie titles in person-based categories  \nSELECT \n    CASE \n        WHEN nom.details ->> ''nominee_names'' = m.title THEN ''ERROR: Movie title stored''\n        WHEN nom.details ->> ''nominee_names'' <> m.title THEN ''CORRECT: Person name stored''\n        ELSE ''UNKNOWN''\n    END as validation_result,\n    COUNT(*) as count\nFROM oscar_nominations nom\nJOIN oscar_categories cat ON nom.category_id = cat.id\nJOIN movies m ON nom.movie_id = m.id\nWHERE nom.ceremony_id = (SELECT id FROM oscar_ceremonies WHERE year = 2024)\nAND cat.tracks_person = true\nGROUP BY validation_result\nORDER BY validation_result;\n\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\n-- Fresh Oscar Nominations Audit\nSELECT \n    ''Total nominations'' as metric, \n    COUNT(*)::text as value \nFROM oscar_nominations nom \nWHERE nom.ceremony_id = (SELECT id FROM oscar_ceremonies WHERE year = 2024)\n\nUNION ALL\n\nSELECT \n    ''People nominations (actors/directors/etc)'' as metric,\n    COUNT(*)::text as value\nFROM oscar_nominations nom\nJOIN oscar_categories cat ON nom.category_id = cat.id\nWHERE nom.ceremony_id = (SELECT id FROM oscar_ceremonies WHERE year = 2024)\nAND cat.tracks_person = true\n\nUNION ALL\n\nSELECT \n    ''People nominations with correct names'' as metric,\n    COUNT(*)::text as value\nFROM oscar_nominations nom\nJOIN oscar_categories cat ON nom.category_id = cat.id\nWHERE nom.ceremony_id = (SELECT id FROM oscar_ceremonies WHERE year = 2024)\nAND cat.tracks_person = true\nAND nom.details ->> ''nominee_names'' IS NOT NULL\nAND nom.details ->> ''nominee_names'' <> ''''\n\nUNION ALL\n\nSELECT \n    ''People nominations storing movie titles (ERROR)'' as metric,\n    COUNT(*)::text as value\nFROM oscar_nominations nom\nJOIN oscar_categories cat ON nom.category_id = cat.id\nJOIN movies m ON nom.movie_id = m.id\nWHERE nom.ceremony_id = (SELECT id FROM oscar_ceremonies WHERE year = 2024)\nAND cat.tracks_person = true\nAND nom.details ->> ''nominee_names'' = m.title\n\nORDER BY metric;\n\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\n-- Check category breakdown for 2024\nSELECT \n    cat.name as category,\n    cat.tracks_person,\n    COUNT(nom.id) as nominations\nFROM oscar_categories cat\nLEFT JOIN oscar_nominations nom ON cat.id = nom.category_id \n    AND nom.ceremony_id = (SELECT id FROM oscar_ceremonies WHERE year = 2024)\nWHERE cat.tracks_person = true\nGROUP BY cat.id, cat.name, cat.tracks_person\nORDER BY cat.name;\n\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\n-- Sample the people nominations we do have\nSELECT \n    cat.name as category,\n    m.title as movie,\n    nom.details ->> ''nominee_names'' as person_names,\n    nom.won\nFROM oscar_nominations nom\nJOIN oscar_categories cat ON nom.category_id = cat.id\nJOIN movies m ON nom.movie_id = m.id\nWHERE nom.ceremony_id = (SELECT id FROM oscar_ceremonies WHERE year = 2024)\nAND cat.tracks_person = true\nORDER BY cat.name, m.title\nLIMIT 15;\n\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\n-- Test the query logic for People Nominations display\nSELECT \n    ''Total People Nominations'' as metric,\n    COUNT(*)::text as value\nFROM oscar_nominations on_table\nJOIN oscar_categories cat ON on_table.category_id = cat.id\nWHERE cat.tracks_person = true\n\nUNION ALL\n\nSELECT \n    ''People Nominations with Names'' as metric,\n    COUNT(*)::text as value\nFROM oscar_nominations on_table\nJOIN oscar_categories cat ON on_table.category_id = cat.id\nWHERE cat.tracks_person = true \n  AND on_table.details ->> ''nominee_names'' IS NOT NULL \n  AND on_table.details ->> ''nominee_names'' != ''''\n\nUNION ALL\n\nSELECT \n    ''Display Value'' as metric,\n    CASE \n        WHEN (SELECT COUNT(*) FROM oscar_nominations on1 JOIN oscar_categories cat1 ON on1.category_id = cat1.id WHERE cat1.tracks_person = true) = \n             (SELECT COUNT(*) FROM oscar_nominations on2 JOIN oscar_categories cat2 ON on2.category_id = cat2.id WHERE cat2.tracks_person = true AND on2.details ->> ''nominee_names'' IS NOT NULL AND on2.details ->> ''nominee_names'' != '''')\n        THEN (SELECT COUNT(*)::text || '' ✅'' FROM oscar_nominations on3 JOIN oscar_categories cat3 ON on3.category_id = cat3.id WHERE cat3.tracks_person = true)\n        ELSE (SELECT COUNT(*)::text FROM oscar_nominations on4 JOIN oscar_categories cat4 ON on4.category_id = cat4.id WHERE cat4.tracks_person = true AND on4.details ->> ''nominee_names'' IS NOT NULL AND on4.details ->> ''nominee_names'' != '''') || ''/'' || \n             (SELECT COUNT(*)::text FROM oscar_nominations on5 JOIN oscar_categories cat5 ON on5.category_id = cat5.id WHERE cat5.tracks_person = true) || '' ⚠️''\n    END\n\nORDER BY metric;\n\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\n-- Test the query logic for People Nominations display\nSELECT \n    ''Total People Nominations'' as metric,\n    COUNT(*)::text as value\nFROM oscar_nominations on_table\nJOIN oscar_categories cat ON on_table.category_id = cat.id\nWHERE cat.tracks_person = true\n\nUNION ALL\n\nSELECT \n    ''People Nominations with Names'' as metric,\n    COUNT(*)::text as value\nFROM oscar_nominations on_table\nJOIN oscar_categories cat ON on_table.category_id = cat.id\nWHERE cat.tracks_person = true \n  AND on_table.details ->> ''nominee_names'' IS NOT NULL \n  AND on_table.details ->> ''nominee_names'' <> ''''\n\nORDER BY metric DESC;\n\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\n-- Comprehensive audit of current awards data state\nSELECT ''Oscar data in structured tables'' as category, COUNT(DISTINCT nom.id) as count\nFROM oscar_nominations nom\n\nUNION ALL\n\nSELECT ''Oscar data in movies.awards JSONB'' as category, COUNT(*) as count\nFROM movies \nWHERE awards IS NOT NULL \nAND awards ? ''oscar_nominations''\n\nUNION ALL\n\nSELECT ''Cannes data in canonical_sources'' as category, COUNT(*) as count\nFROM movies \nWHERE canonical_sources ? ''cannes_winners''\n\nUNION ALL\n\nSELECT ''Venice data in canonical_sources'' as category, COUNT(*) as count\nFROM movies \nWHERE canonical_sources ? ''venice_golden_lion''\n\nUNION ALL\n\nSELECT ''Berlin data in canonical_sources'' as category, COUNT(*) as count\nFROM movies \nWHERE canonical_sources ? ''berlin_golden_bear''\n\nUNION ALL\n\nSELECT ''Cannes with extracted_awards'' as category, COUNT(*) as count\nFROM movies \nWHERE canonical_sources -> ''cannes_winners'' -> ''extracted_awards'' IS NOT NULL\n\nUNION ALL\n\nSELECT ''Venice with extracted_awards'' as category, COUNT(*) as count\nFROM movies \nWHERE canonical_sources -> ''venice_golden_lion'' -> ''extracted_awards'' IS NOT NULL\n\nUNION ALL\n\nSELECT ''Berlin with extracted_awards'' as category, COUNT(*) as count\nFROM movies \nWHERE canonical_sources -> ''berlin_golden_bear'' -> ''extracted_awards'' IS NOT NULL\n\nORDER BY category;\n\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\n-- Check Oscar ceremonies and nominations\nSELECT \n    oc.year,\n    COUNT(DISTINCT on_table.id) as nominations,\n    COUNT(DISTINCT CASE WHEN on_table.won = true THEN on_table.id END) as wins\nFROM oscar_ceremonies oc\nLEFT JOIN oscar_nominations on_table ON on_table.ceremony_id = oc.id\nGROUP BY oc.year\nORDER BY oc.year DESC\nLIMIT 10;\n\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\n-- Audit Oscar data quality and person tracking\nSELECT \n    ''Total Oscar Categories'' as metric,\n    COUNT(*)::text as value\nFROM oscar_categories\n\nUNION ALL\n\nSELECT \n    ''Categories tracking people'' as metric,\n    COUNT(*)::text as value\nFROM oscar_categories\nWHERE tracks_person = true\n\nUNION ALL\n\nSELECT \n    ''Total Oscar nominations'' as metric,\n    COUNT(*)::text as value\nFROM oscar_nominations\n\nUNION ALL\n\nSELECT \n    ''Nominations with person_id linked'' as metric,\n    COUNT(*)::text as value\nFROM oscar_nominations\nWHERE person_id IS NOT NULL\n\nUNION ALL\n\nSELECT \n    ''People nominations with names in details'' as metric,\n    COUNT(*)::text as value\nFROM oscar_nominations nom\nJOIN oscar_categories cat ON nom.category_id = cat.id\nWHERE cat.tracks_person = true\nAND nom.details ->> ''nominee_names'' IS NOT NULL\n\nUNION ALL\n\nSELECT \n    ''People nominations with IMDb IDs'' as metric,\n    COUNT(*)::text as value\nFROM oscar_nominations nom\nJOIN oscar_categories cat ON nom.category_id = cat.id\nWHERE cat.tracks_person = true\nAND nom.details -> ''person_imdb_ids'' IS NOT NULL\n\nORDER BY metric;\n\")",
      "Bash(MIX_ENV=dev mix ecto.migrations)",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\n-- Check 2024 Oscar import results\nSELECT \n  ''Total Nominations'' as metric,\n  COUNT(*) as count\nFROM oscar_nominations\nWHERE ceremony_id = (SELECT id FROM oscar_ceremonies WHERE year = 2024)\n\nUNION ALL\n\nSELECT \n  ''Fuzzy Matched Movies'' as metric,\n  COUNT(DISTINCT movie_id) as count\nFROM oscar_nominations\nWHERE ceremony_id = (SELECT id FROM oscar_ceremonies WHERE year = 2024)\n\nUNION ALL\n\nSELECT \n  ''Categories with Nominations'' as metric,\n  COUNT(DISTINCT category_id) as count  \nFROM oscar_nominations\nWHERE ceremony_id = (SELECT id FROM oscar_ceremonies WHERE year = 2024)\n\nORDER BY metric;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\n-- Check which categories have nominations\nSELECT \n  c.name as category,\n  COUNT(n.id) as nominations\nFROM oscar_categories c\nLEFT JOIN oscar_nominations n ON n.category_id = c.id \n  AND n.ceremony_id = (SELECT id FROM oscar_ceremonies WHERE year = 2024)\nWHERE c.id IN (\n  SELECT DISTINCT category_id \n  FROM oscar_nominations \n  WHERE ceremony_id = (SELECT id FROM oscar_ceremonies WHERE year = 2024)\n)\nGROUP BY c.id, c.name\nORDER BY c.name;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\n-- Final audit of 2024 Oscar nominations\nSELECT \n  ''Total 2024 Nominations'' as metric,\n  COUNT(*) as value\nFROM oscar_nominations \nWHERE ceremony_id = (SELECT id FROM oscar_ceremonies WHERE year = 2024)\n\nUNION ALL\n\nSELECT \n  ''Person-based Nominations'' as metric,\n  COUNT(*) as value\nFROM oscar_nominations n\nJOIN oscar_categories c ON n.category_id = c.id\nWHERE n.ceremony_id = (SELECT id FROM oscar_ceremonies WHERE year = 2024)\n  AND c.tracks_person = true\n\nUNION ALL\n\nSELECT \n  ''Film-based Nominations'' as metric,\n  COUNT(*) as value\nFROM oscar_nominations n\nJOIN oscar_categories c ON n.category_id = c.id\nWHERE n.ceremony_id = (SELECT id FROM oscar_ceremonies WHERE year = 2024)\n  AND c.tracks_person = false\n\nUNION ALL\n\nSELECT \n  ''Unique Movies'' as metric,\n  COUNT(DISTINCT movie_id) as value\nFROM oscar_nominations\nWHERE ceremony_id = (SELECT id FROM oscar_ceremonies WHERE year = 2024)\n\nUNION ALL\n\nSELECT \n  ''Categories with Data'' as metric,\n  COUNT(DISTINCT category_id) as value\nFROM oscar_nominations\nWHERE ceremony_id = (SELECT id FROM oscar_ceremonies WHERE year = 2024)\n\nORDER BY metric;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres mix run -e 'IO.inspect(Cinegraph.Festivals.get_or_create_oscar_organization(), label: \"\"Oscar Org Result\"\")')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres mix run -e 'org = Cinegraph.Festivals.get_or_create_oscar_organization(); IO.puts(\"\"Created: #{org.name} (ID: #{org.id})\"\")')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT * FROM festival_organizations WHERE abbreviation = ''AMPAS'';\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres mix run -e 'IO.puts(\"\"Testing Oscar ceremonies: #{length(Cinegraph.Cultural.list_oscar_ceremonies())}\"\")')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres mix test --include slow)",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres mix run -e 'IO.puts(\"\"✅ Dashboard Oscar stats test\"\"); org = Cinegraph.Festivals.get_or_create_oscar_organization(); IO.puts(\"\"Oscar org: #{org.name} (#{org.id})\"\")')",
      "Bash(gt continue:*)",
      "Bash(gt stack:*)",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\\dt\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\\d festival_organizations\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\\d festival_ceremonies\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT * FROM festival_organizations;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\nSELECT \n  ''Festival Ceremonies'' as table_name,\n  COUNT(*) as total_records,\n  COUNT(name) as name_filled,\n  COUNT(date) as date_filled, \n  COUNT(location) as location_filled,\n  COUNT(data_source) as data_source_filled,\n  COUNT(source_url) as source_url_filled,\n  COUNT(scraped_at) as scraped_at_filled\nFROM festival_ceremonies\n\nUNION ALL\n\nSELECT \n  ''Festival Organizations'' as table_name,\n  COUNT(*) as total_records,\n  COUNT(name) as name_filled,\n  COUNT(founded_year) as founded_year_filled,\n  COUNT(website) as website_filled,\n  COUNT(description) as description_filled,\n  COUNT(country) as country_filled,\n  COUNT(logo_url) as logo_url_filled\nFROM festival_organizations\n\nUNION ALL\n\nSELECT \n  ''Festival Categories'' as table_name,\n  COUNT(*) as total_records,\n  COUNT(name) as name_filled,\n  COUNT(category_type) as category_type_filled,\n  COUNT(description) as description_filled,\n  COALESCE(SUM(CASE WHEN tracks_person = true THEN 1 ELSE 0 END), 0) as tracks_person_true,\n  COALESCE(SUM(CASE WHEN tracks_person = false THEN 1 ELSE 0 END), 0) as tracks_person_false,\n  NULL as unused\nFROM festival_categories\n\nORDER BY table_name;\n\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\nSELECT \n  ''Festival Ceremonies'' as table_name,\n  COUNT(*) as total_records,\n  COUNT(name) as name_filled,\n  COUNT(date) as date_filled, \n  COUNT(location) as location_filled,\n  COUNT(data_source) as data_source_filled,\n  COUNT(source_url) as source_url_filled,\n  COUNT(scraped_at) as scraped_at_filled\nFROM festival_ceremonies\n\nUNION ALL\n\nSELECT \n  ''Festival Organizations'' as table_name,\n  COUNT(*) as total_records,\n  COUNT(name) as name_filled,\n  COUNT(founded_year) as founded_year_filled,\n  COUNT(website) as website_filled,\n  COUNT(country) as country_filled,\n  COUNT(logo_url) as logo_url_filled,\n  NULL as unused\nFROM festival_organizations\n\nUNION ALL\n\nSELECT \n  ''Festival Categories'' as table_name,\n  COUNT(*) as total_records,\n  COUNT(name) as name_filled,\n  COUNT(category_type) as category_type_filled,\n  COALESCE(SUM(CASE WHEN tracks_person = true THEN 1 ELSE 0 END), 0) as tracks_person_true,\n  COALESCE(SUM(CASE WHEN tracks_person = false THEN 1 ELSE 0 END), 0) as tracks_person_false,\n  NULL as unused1,\n  NULL as unused2\nFROM festival_categories\n\nORDER BY table_name;\n\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\\d festival_ceremonies\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\\d festival_organizations\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\\d festival_categories\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\\d festival_nominations\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\n-- Festival Ceremonies Field Usage Audit\nSELECT \n  ''Festival Ceremonies'' as table_name,\n  COUNT(*) as total_records,\n  COUNT(name) as name_filled,\n  COUNT(date) as date_filled, \n  COUNT(location) as location_filled,\n  COUNT(data_source) as data_source_filled,\n  COUNT(source_url) as source_url_filled,\n  COUNT(scraped_at) as scraped_at_filled\nFROM festival_ceremonies\n\nUNION ALL\n\n-- Festival Organizations Field Usage Audit  \nSELECT \n  ''Festival Organizations'' as table_name,\n  COUNT(*) as total_records,\n  COUNT(name) as name_filled,\n  COUNT(abbreviation) as abbreviation_filled,\n  COUNT(country) as country_filled,\n  COUNT(founded_year) as founded_year_filled,\n  COUNT(website) as website_filled,\n  NULL as unused\nFROM festival_organizations\n\nUNION ALL\n\n-- Festival Categories Field Usage Audit\nSELECT \n  ''Festival Categories'' as table_name,\n  COUNT(*) as total_records,\n  COUNT(name) as name_filled,\n  COUNT(category_type) as category_type_filled,\n  COALESCE(SUM(CASE WHEN tracks_person = true THEN 1 ELSE 0 END), 0) as tracks_person_true,\n  COALESCE(SUM(CASE WHEN tracks_person = false THEN 1 ELSE 0 END), 0) as tracks_person_false,\n  NULL as unused1,\n  NULL as unused2\nFROM festival_categories\n\nORDER BY table_name;\n\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\n-- Nominations Field Usage Audit\nSELECT \n  ''Festival Nominations'' as table_name,\n  COUNT(*) as total_records,\n  COUNT(movie_id) as movie_id_filled,\n  COUNT(person_id) as person_id_filled,\n  COUNT(prize_name) as prize_name_filled,\n  COALESCE(SUM(CASE WHEN won = true THEN 1 ELSE 0 END), 0) as won_true,\n  COALESCE(SUM(CASE WHEN won = false THEN 1 ELSE 0 END), 0) as won_false,\n  NULL as unused\nFROM festival_nominations;\n\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\n-- Sample data analysis\nSELECT ''Ceremony Sample'' as analysis_type,\n       year, name, date, location, ceremony_number, data_source\nFROM festival_ceremonies \nLIMIT 3\n\nUNION ALL\n\nSELECT ''Organization Sample'' as analysis_type,\n       name::text, abbreviation, country, founded_year::text, website, NULL\nFROM festival_organizations\nLIMIT 1;\n\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\n-- Ceremony Sample Data\nSELECT year, name, date, location, ceremony_number, data_source\nFROM festival_ceremonies \nORDER BY year \nLIMIT 5;\n\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\n-- Organization Sample Data\nSELECT name, abbreviation, country, founded_year, website\nFROM festival_organizations;\n\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\n-- Check if ceremony names exist in the data JSONB field\nSELECT year, data -> ''title'' as ceremony_title, data -> ''location'' as ceremony_location, data -> ''date'' as ceremony_date\nFROM festival_ceremonies \nORDER BY year \nLIMIT 3;\n\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=3ba3f8f9 ZYTE_API_KEY=9e754bb61e684aad88a98eceada363ba mix run -e '\n# Test Venice import functionality available through the UI\nIO.puts(\"\"=== Testing Festival Awards Import UI Integration ===\"\")\n\n# 1. Check if Venice functions are available (what UI would call)\nIO.puts(\"\"\\n1. Testing Cultural Venice functions...\"\")\nvenice_functions = [\n  {\"\"import_venice_year/2\"\", &Cinegraph.Cultural.import_venice_year/2},\n  {\"\"get_venice_import_status/0\"\", &Cinegraph.Cultural.get_venice_import_status/0},\n  {\"\"list_venice_ceremonies/0\"\", &Cinegraph.Cultural.list_venice_ceremonies/0}\n]\n\nEnum.each(venice_functions, fn {name, _func} ->\n  IO.puts(\"\"  ✅ #{name} - Available\"\")\nend)\n\n# 2. Check Venice organization exists (created by UI)\nvenice_org = Cinegraph.Festivals.get_organization_by_abbreviation(\"\"VIFF\"\")\nif venice_org do\n  IO.puts(\"\"\\n2. ✅ Venice Organization Found:\"\")\n  IO.puts(\"\"   Name: #{venice_org.name}\"\")\n  IO.puts(\"\"   Abbreviation: #{venice_org.abbreviation}\"\")\n  IO.puts(\"\"   Country: #{venice_org.country}\"\")\nelse\n  IO.puts(\"\"\\n2. ℹ️ Venice Organization not yet created (will be created on first import)\"\")\nend\n\n# 3. Test the UI integration path (simulate what happens when user clicks Import)\nIO.puts(\"\"\\n3. Testing UI Integration Path...\"\")\nIO.puts(\"\"   User selects: Venice International Film Festival\"\")\nIO.puts(\"\"   User enters year: 2025\"\")\nIO.puts(\"\"   User clicks: Import Festival\"\")\n\n# 4. Check Venice import status (what UI shows)\nstatus = Cinegraph.Cultural.get_venice_import_status()\nIO.puts(\"\"\\n4. ✅ Venice Import Status (UI display):\"\")\nIO.puts(\"\"   Running jobs: #{status.running_jobs}\"\")\nIO.puts(\"\"   Queued jobs: #{status.queued_jobs}\"\")\nIO.puts(\"\"   Completed jobs: #{status.completed_jobs}\"\")\nIO.puts(\"\"   Failed jobs: #{status.failed_jobs}\"\")\n\n# 5. Check database stats (what UI shows in Database Statistics)\nvenice_count = try do\n  venice_org = Cinegraph.Festivals.get_organization_by_abbreviation(\"\"VIFF\"\")\n  if venice_org && venice_org.id do\n    import Ecto.Query\n    Cinegraph.Repo.one(\n      from n in Cinegraph.Festivals.FestivalNomination,\n      join: c in Cinegraph.Festivals.FestivalCeremony, on: n.ceremony_id == c.id,\n      where: c.organization_id == ^venice_org.id,\n      select: count(n.movie_id, :distinct)\n    ) || 0\n  else\n    0\n  end\ncatch\n  _ -> 0\nend\n\nIO.puts(\"\"\\n5. ✅ Database Statistics (UI Venice Movies count): #{venice_count}\"\")\n\nIO.puts(\"\"\\n🎉 Festival Awards Import UI Integration Complete!\"\")\nIO.puts(\"\"   ✅ All Venice functions accessible\"\")\nIO.puts(\"\"   ✅ Festival import form ready\"\") \nIO.puts(\"\"   ✅ Progress tracking implemented\"\")\nIO.puts(\"\"   ✅ Statistics display configured\"\")\nIO.puts(\"\"   ✅ Database integration working\"\")\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres ZYTE_API_KEY=9e754bb61e684aad88a98eceada363ba mix run -e '\n# Check Venice scraper capabilities and see what years are available\nIO.puts(\"\"=== Venice Film Festival Scraper Analysis ===\"\")\n\n# 1. Check if we can get available years\nIO.puts(\"\"\\n1. Testing get_available_years function...\"\")\ncase Cinegraph.Scrapers.VeniceFilmFestivalScraper.get_available_years() do\n  {:ok, years} ->\n    IO.puts(\"\"✅ Available years: #{inspect(Enum.sort(years))}\"\")\n    IO.puts(\"\"   Years count: #{length(years)}\"\")\n    IO.puts(\"\"   Range: #{Enum.min(years)}-#{Enum.max(years)}\"\")\n  {:error, reason} ->\n    IO.puts(\"\"❌ Error getting years: #{inspect(reason)}\"\")\nend\n\n# 2. Check current Venice worker jobs\nimport Ecto.Query\njobs = Cinegraph.Repo.all(\n  from j in Oban.Job,\n  where: j.worker == \"\"Cinegraph.Workers.VeniceFestivalWorker\"\",\n  order_by: [desc: j.inserted_at],\n  limit: 5,\n  select: %{id: j.id, state: j.state, args: j.args, errors: j.errors}\n)\n\nIO.puts(\"\"\\n2. Current Venice Worker Jobs:\"\")\nEnum.each(jobs, fn job ->\n  IO.puts(\"\"   Job #{job.id}: #{job.state} - #{inspect(job.args)}\"\")\n  if job.errors && length(job.errors) > 0 do\n    IO.puts(\"\"     Errors: #{inspect(job.errors)}\"\")\n  end\nend)\n\n# 3. Test what happens when we try a Venice import\nIO.puts(\"\"\\n3. Testing Venice import process...\"\")\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres ZYTE_API_KEY=9e754bb61e684aad88a98eceada363ba mix run -e '\n# Test the updated Festival Awards Import UI functionality\nIO.puts(\"\"=== Testing Updated Festival Awards Import UI ===\"\")\n\n# 1. Test that venice_years function works\nIO.puts(\"\"\\n1. Testing Venice Years Dropdown Generation...\"\")\ntry do\n  # This simulates what the LiveView does in mount/3\n  venice_years = [\n    # Simulate the generate_venice_years function\n    %{value: \"\"all\"\", label: \"\"All Available Years (2020-2025)\"\"} |\n    Enum.map(2025..2020//-1, fn year ->\n      %{value: to_string(year), label: \"\"#{year} Venice Film Festival\"\"}\n    end)\n  ]\n  \n  IO.puts(\"\"✅ Venice Years Dropdown Options:\"\")\n  Enum.each(venice_years, fn option ->\n    marker = if option.value == \"\"all\"\", do: \"\" ⭐ NEW\"\", else: \"\"\"\"\n    IO.puts(\"\"   #{option.value}: #{option.label}#{marker}\"\")\n  end)\n  \nrescue\n  error ->\n    IO.puts(\"\"❌ Error generating Venice years: #{inspect(error)}\"\")\nend\n\n# 2. Test the updated event handler logic\nIO.puts(\"\"\\n2. Testing Import Event Handler Updates...\"\")\n\ntest_cases = [\n  {%{\"\"festival\"\" => \"\"venice\"\", \"\"year_range\"\" => \"\"2025\"\"}, \"\"Single Year Import\"\"},\n  {%{\"\"festival\"\" => \"\"venice\"\", \"\"year_range\"\" => \"\"all\"\"}, \"\"All Years Import\"\"},\n]\n\nEnum.each(test_cases, fn {params, description} ->\n  IO.puts(\"\"  Testing #{description}: #{inspect(params)}\"\")\n  case params do\n    %{\"\"festival\"\" => \"\"venice\"\", \"\"year_range\"\" => \"\"all\"\"} ->\n      IO.puts(\"\"    ✅ Would call: Cultural.import_venice_years(2020..2025)\"\")\n      \n    %{\"\"festival\"\" => \"\"venice\"\", \"\"year_range\"\" => year_str} ->\n      case Integer.parse(year_str) do\n        {year, \"\"\"\"} when year > 1900 and year <= 2030 ->\n          IO.puts(\"\"    ✅ Would call: Cultural.import_venice_year(#{year})\"\")\n        _ ->\n          IO.puts(\"\"    ❌ Invalid year format\"\")\n      end\n      \n    _ ->\n      IO.puts(\"\"    ❌ Unsupported festival\"\")\n  end\nend)\n\nIO.puts(\"\"\\n3. ✅ UI Improvements Summary:\"\")\nIO.puts(\"\"   ✅ Year input changed to dropdown\"\")\nIO.puts(\"\"   ✅ Added \\\"\"All Years\\\"\" option for complete import\"\")\nIO.puts(\"\"   ✅ Venice years dynamically generated (2020-2025)\"\")\nIO.puts(\"\"   ✅ Updated event handler to support year_range parameter\"\")\nIO.puts(\"\"   ✅ Better UX with descriptive labels\"\")\n\nIO.puts(\"\"\\n🎉 Festival Awards Import UI Successfully Updated!\"\")\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres mix run -e '\n# Clear stuck Venice jobs to test the new UI cleanly\nIO.puts(\"\"=== Clearing Stuck Venice Jobs ===\"\")\n\nimport Ecto.Query\nalias Cinegraph.Repo\n\n# Find stuck Venice jobs\nstuck_jobs = Repo.all(\n  from j in Oban.Job,\n  where: j.worker == \"\"Cinegraph.Workers.VeniceFestivalWorker\"\" and j.state == \"\"available\"\",\n  select: %{id: j.id, args: j.args, inserted_at: j.inserted_at}\n)\n\nIO.puts(\"\"Found #{length(stuck_jobs)} stuck Venice jobs:\"\")\nEnum.each(stuck_jobs, fn job ->\n  IO.puts(\"\"  Job #{job.id}: #{inspect(job.args)} (#{job.inserted_at})\"\")\nend)\n\n# Cancel the stuck jobs\nif length(stuck_jobs) > 0 do\n  job_ids = Enum.map(stuck_jobs, & &1.id)\n  \n  {cancelled_count, _} = Repo.update_all(\n    from(j in Oban.Job, where: j.id in ^job_ids),\n    set: [state: \"\"cancelled\"\", cancelled_at: DateTime.utc_now()]\n  )\n  \n  IO.puts(\"\"✅ Cancelled #{cancelled_count} stuck Venice jobs\"\")\nelse\n  IO.puts(\"\"✅ No stuck jobs to cancel\"\")\nend\n\n# Check final Venice job status\nfinal_status = from(j in Oban.Job, \n  where: j.worker == \"\"Cinegraph.Workers.VeniceFestivalWorker\"\",\n  group_by: j.state,\n  select: {j.state, count(j.id)}\n) |> Repo.all() |> Enum.into(%{})\n\nIO.puts(\"\"\\n📊 Final Venice Job Status:\"\")\nIO.puts(\"\"  Available: #{Map.get(final_status, \"\"available\"\", 0)}\"\")\nIO.puts(\"\"  Executing: #{Map.get(final_status, \"\"executing\"\", 0)}\"\")\nIO.puts(\"\"  Completed: #{Map.get(final_status, \"\"completed\"\", 0)}\"\")\nIO.puts(\"\"  Cancelled: #{Map.get(final_status, \"\"cancelled\"\", 0)}\"\")\n\nIO.puts(\"\"\\n🎉 Venice Jobs Cleared - Ready to test new UI!\"\")\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=3ba3f8f9 ZYTE_API_KEY=9e754bb61e684aad88a98eceada363ba mix run -e 'IO.puts(\"\"Testing Venice import with fixed Oban configuration...\"\"); result = Cinegraph.Cultural.import_venice_year(2025); IO.inspect(result, label: \"\"Venice Import Result\"\"); Process.sleep(5000); status = Cinegraph.Cultural.get_venice_import_status(); IO.inspect(status, label: \"\"Venice Job Status\"\")')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres mix run -e '\n# Check Festival Awards Import functionality\nIO.puts(\"\"=== Testing Festival Awards Import UI Integration ===\"\")\n\n# 1. Check Venice import status (what UI would show)\nstatus = Cinegraph.Cultural.get_venice_import_status()\nIO.puts(\"\"\\n1. ✅ Venice Import Status (UI display):\"\")\nIO.puts(\"\"   Running jobs: #{status.running_jobs}\"\")\nIO.puts(\"\"   Queued jobs: #{status.queued_jobs}\"\")\nIO.puts(\"\"   Completed jobs: #{status.completed_jobs}\"\")\nIO.puts(\"\"   Failed jobs: #{status.failed_jobs}\"\")\n\n# 2. Check database statistics (what UI shows)\nimport Ecto.Query\nvenice_org = Cinegraph.Festivals.get_organization_by_abbreviation(\"\"VIFF\"\")\nvenice_count = if venice_org do\n  Cinegraph.Repo.one(\n    from n in Cinegraph.Festivals.FestivalNomination,\n    join: c in Cinegraph.Festivals.FestivalCeremony, on: n.ceremony_id == c.id,\n    where: c.organization_id == ^venice_org.id,\n    select: count(n.movie_id, :distinct)\n  ) || 0\nelse\n  0\nend\n\nIO.puts(\"\"\\n2. ✅ Database Statistics (UI Venice Movies count): #{venice_count}\"\")\n\n# 3. Test dropdown functionality\nvenice_years = [\n  %{value: \"\"all\"\", label: \"\"All Available Years (2020-2025)\"\"} |\n  Enum.map(2025..2020//-1, fn year ->\n    %{value: to_string(year), label: \"\"#{year} Venice Film Festival\"\"}\n  end)\n]\n\nIO.puts(\"\"\\n3. ✅ Venice Years Dropdown Options:\"\")\nEnum.each(venice_years, fn option ->\n  marker = if option.value == \"\"all\"\", do: \"\" ⭐\"\", else: \"\"\"\"\n  IO.puts(\"\"   #{option.value}: #{option.label}#{marker}\"\")\nend)\n\nIO.puts(\"\"\\n🎉 Festival Awards Import UI Successfully Working!\"\")\nIO.puts(\"\"   ✅ Venice jobs now process instead of getting stuck\"\")\nIO.puts(\"\"   ✅ UI displays real-time job status\"\")  \nIO.puts(\"\"   ✅ Dropdown interface with year options\"\")\nIO.puts(\"\"   ✅ All Years option for bulk import\"\")\nIO.puts(\"\"   ✅ Statistics tracking and display\"\")\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres mix run -e '\nimport Ecto.Query\nalias Cinegraph.Repo\n\n# Check all Venice jobs\nvenice_jobs = Repo.all(\n  from j in Oban.Job,\n  where: j.worker == \"\"Cinegraph.Workers.VeniceFestivalWorker\"\",\n  order_by: [desc: j.id],\n  select: %{\n    id: j.id, \n    state: j.state, \n    args: j.args, \n    inserted_at: j.inserted_at,\n    scheduled_at: j.scheduled_at,\n    attempted_at: j.attempted_at,\n    attempt: j.attempt,\n    errors: j.errors\n  }\n)\n\nIO.puts(\"\"=== All Venice Jobs ===\"\")\nEnum.each(venice_jobs, fn job ->\n  IO.puts(\"\"\\nJob #{job.id}:\"\")\n  IO.puts(\"\"  State: #{job.state}\"\")\n  IO.puts(\"\"  Args: #{inspect(job.args)}\"\")\n  IO.puts(\"\"  Attempt: #{job.attempt}\"\")\n  IO.puts(\"\"  Inserted: #{job.inserted_at}\"\")\n  if job.errors && length(job.errors) > 0 do\n    IO.puts(\"\"  Errors: #{inspect(job.errors)}\"\")\n  end\nend)\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres ZYTE_API_KEY=9e754bb61e684aad88a98eceada363ba mix run -e '\n# Test the Venice scraper directly to see if it works\nalias Cinegraph.Scrapers.VeniceFilmFestivalScraper\n\nIO.puts(\"\"Testing Venice scraper directly for 2025...\"\")\n\n# Try with timeout to prevent hanging\ntask = Task.async(fn ->\n  VeniceFilmFestivalScraper.fetch_festival_data(2025)\nend)\n\ncase Task.yield(task, 10_000) || Task.shutdown(task) do\n  {:ok, result} ->\n    IO.inspect(result, label: \"\"Scraper Result\"\")\n  nil ->\n    IO.puts(\"\"Scraper timed out after 10 seconds\"\")\n  {:exit, reason} ->\n    IO.puts(\"\"Scraper crashed: #{inspect(reason)}\"\")\nend\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres mix run -e '\nimport Ecto.Query\nalias Cinegraph.Repo\n\n# Cancel stuck executing jobs\n{cancelled_count, _} = Repo.update_all(\n  from(j in Oban.Job, \n    where: j.worker == \"\"Cinegraph.Workers.VeniceFestivalWorker\"\" and j.state == \"\"executing\"\"\n  ),\n  set: [state: \"\"cancelled\"\", cancelled_at: DateTime.utc_now()]\n)\n\nIO.puts(\"\"Cancelled #{cancelled_count} stuck Venice jobs\"\")\n\n# Check remaining jobs\nremaining = Repo.one(\n  from j in Oban.Job,\n  where: j.worker == \"\"Cinegraph.Workers.VeniceFestivalWorker\"\" and j.state != \"\"cancelled\"\",\n  select: count(j.id)\n)\n\nIO.puts(\"\"Remaining non-cancelled Venice jobs: #{remaining}\"\")\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres mix run -e '\nimport Ecto.Query\nalias Cinegraph.Repo\n\n# Cancel stuck executing jobs\n{cancelled_count, _} = Repo.update_all(\n  from(j in Oban.Job, \n    where: j.worker == \"\"Cinegraph.Workers.VeniceFestivalWorker\"\" and j.state == \"\"executing\"\"\n  ),\n  set: [state: \"\"cancelled\"\", cancelled_at: DateTime.utc_now()]\n)\n\nIO.puts(\"\"Cancelled #{cancelled_count} stuck Venice jobs\"\")\n\n# Check remaining jobs\nremaining = Repo.one(\n  from j in Oban.Job,\n  where: j.worker == \"\"Cinegraph.Workers.VeniceFestivalWorker\"\" and j.state not in [\"\"cancelled\"\", \"\"completed\"\", \"\"discarded\"\"],\n  select: count(j.id)\n)\n\nIO.puts(\"\"Remaining active Venice jobs: #{remaining}\"\")\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres ZYTE_API_KEY=9e754bb61e684aad88a98eceada363ba mix run -e '\n# Test Zyte API directly with a simpler request\nurl = \"\"https://www.imdb.com/event/ev0000681/2025/1/\"\"\napi_key = Application.get_env(:cinegraph, :zyte_api_key)\n\nIO.puts(\"\"Testing Zyte API with Venice 2025 URL: #{url}\"\")\nIO.puts(\"\"API Key present: #{api_key != nil && api_key != \\\"\"\\\"\"}\"\")\n\nheaders = [\n  {\"\"Authorization\"\", \"\"Basic #{Base.encode64(api_key <> \"\":\"\")}\"\"},\n  {\"\"Content-Type\"\", \"\"application/json\"\"}\n]\n\nbody = Jason.encode!(%{\n  url: url,\n  browserHtml: true,\n  javascript: true,\n  viewport: %{\n    width: 1920,\n    height: 1080\n  }\n})\n\noptions = [\n  timeout: 30_000,\n  recv_timeout: 30_000,\n  hackney: [pool: :default]\n]\n\nIO.puts(\"\"\\nMaking request to Zyte API...\"\")\ncase HTTPoison.post(\"\"https://api.zyte.com/v1/extract\"\", body, headers, options) do\n  {:ok, %{status_code: 200, body: response}} ->\n    IO.puts(\"\"✅ Success! Got response\"\")\n    case Jason.decode(response) do\n      {:ok, %{\"\"browserHtml\"\" => html}} ->\n        IO.puts(\"\"HTML length: #{String.length(html)} characters\"\")\n        # Check if __NEXT_DATA__ exists\n        if String.contains?(html, \"\"__NEXT_DATA__\"\") do\n          IO.puts(\"\"✅ Found __NEXT_DATA__ in response\"\")\n        else\n          IO.puts(\"\"❌ No __NEXT_DATA__ found in response\"\")\n        end\n      {:ok, data} ->\n        IO.puts(\"\"Response structure: #{inspect(Map.keys(data))}\"\")\n      {:error, reason} ->\n        IO.puts(\"\"Failed to parse JSON: #{inspect(reason)}\"\")\n    end\n    \n  {:ok, %{status_code: status, body: body}} ->\n    IO.puts(\"\"❌ Zyte API error (#{status}): #{String.slice(body, 0, 200)}\"\")\n    \n  {:error, %HTTPoison.Error{reason: reason}} ->\n    IO.puts(\"\"❌ HTTP error: #{inspect(reason)}\"\")\nend\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres ZYTE_API_KEY=9e754bb61e684aad88a98eceada363ba mix run -e '\n# Test Zyte API directly with a simpler request\nurl = \"\"https://www.imdb.com/event/ev0000681/2025/1/\"\"\napi_key = Application.get_env(:cinegraph, :zyte_api_key)\n\nIO.puts(\"\"Testing Zyte API with Venice 2025 URL: #{url}\"\")\nIO.puts(\"\"API Key present: #{not is_nil(api_key) and api_key != \"\"\"\"}\"\")\n\nheaders = [\n  {\"\"Authorization\"\", \"\"Basic #{Base.encode64(api_key <> \"\":\"\")}\"\"},\n  {\"\"Content-Type\"\", \"\"application/json\"\"}\n]\n\nbody = Jason.encode!(%{\n  url: url,\n  browserHtml: true,\n  javascript: true,\n  viewport: %{\n    width: 1920,\n    height: 1080\n  }\n})\n\noptions = [\n  timeout: 30_000,\n  recv_timeout: 30_000,\n  hackney: [pool: :default]\n]\n\nIO.puts(\"\"\\nMaking request to Zyte API...\"\")\ncase HTTPoison.post(\"\"https://api.zyte.com/v1/extract\"\", body, headers, options) do\n  {:ok, %{status_code: 200, body: response}} ->\n    IO.puts(\"\"✅ Success! Got response\"\")\n    case Jason.decode(response) do\n      {:ok, %{\"\"browserHtml\"\" => html}} ->\n        IO.puts(\"\"HTML length: #{String.length(html)} characters\"\")\n        # Check if __NEXT_DATA__ exists\n        if String.contains?(html, \"\"__NEXT_DATA__\"\") do\n          IO.puts(\"\"✅ Found __NEXT_DATA__ in response\"\")\n        else\n          IO.puts(\"\"❌ No __NEXT_DATA__ found in response\"\")\n        end\n      {:ok, data} ->\n        IO.puts(\"\"Response structure: #{inspect(Map.keys(data))}\"\")\n      {:error, reason} ->\n        IO.puts(\"\"Failed to parse JSON: #{inspect(reason)}\"\")\n    end\n    \n  {:ok, %{status_code: status, body: body}} ->\n    IO.puts(\"\"❌ Zyte API error (#{status}): #{String.slice(body, 0, 200)}\"\")\n    \n  {:error, %HTTPoison.Error{reason: reason}} ->\n    IO.puts(\"\"❌ HTTP error: #{inspect(reason)}\"\")\nend\n')",
      "Bash(ZYTE_API_KEY=9e754bb61e684aad88a98eceada363ba mix run -e '\n# Test fetching raw HTML to see what we actually get\nurl = \"\"https://www.imdb.com/event/ev0000681/2025/1/\"\"\napi_key = Application.get_env(:cinegraph, :zyte_api_key)\n\nheaders = [\n  {\"\"Authorization\"\", \"\"Basic #{Base.encode64(api_key <> \"\":\"\")}\"\"},\n  {\"\"Content-Type\"\", \"\"application/json\"\"}\n]\n\nbody = Jason.encode!(%{\n  url: url,\n  browserHtml: true,\n  javascript: true,\n  viewport: %{width: 1920, height: 1080}\n})\n\ncase HTTPoison.post(\"\"https://api.zyte.com/v1/extract\"\", body, headers, timeout: 30_000, recv_timeout: 30_000) do\n  {:ok, %{status_code: 200, body: response}} ->\n    case Jason.decode(response) do\n      {:ok, %{\"\"browserHtml\"\" => html}} ->\n        # Save HTML for inspection\n        File.write!(\"\"venice_2025.html\"\", html)\n        IO.puts(\"\"HTML saved to venice_2025.html\"\")\n        \n        # Check for various possible data structures\n        has_next_data = String.contains?(html, \"\"__NEXT_DATA__\"\")\n        has_awards_section = String.contains?(html, \"\"event-awards\"\")\n        has_nominees = String.contains?(html, \"\"nominee\"\")\n        has_winner = String.contains?(html, \"\"winner\"\")\n        \n        IO.puts(\"\"\\n=== HTML Structure Analysis ===\"\")\n        IO.puts(\"\"Has __NEXT_DATA__: #{has_next_data}\"\")\n        IO.puts(\"\"Has awards section: #{has_awards_section}\"\")\n        IO.puts(\"\"Has nominees: #{has_nominees}\"\")\n        IO.puts(\"\"Has winner: #{has_winner}\"\")\n        \n        # Try to find the actual award data structure\n        if String.contains?(html, \"\"Golden Lion\"\") do\n          IO.puts(\"\"\\n✅ Found Golden Lion award mention\"\")\n        end\n        \n        if String.contains?(html, \"\"Silver Lion\"\") do\n          IO.puts(\"\"✅ Found Silver Lion award mention\"\")\n        end\n        \n        # Check for React/Next.js app structure\n        if String.contains?(html, \"\"data-testid\"\") do\n          IO.puts(\"\"\\n📊 Found data-testid attributes (likely React app)\"\")\n        end\n        \n      {:ok, other} ->\n        IO.puts(\"\"Unexpected response structure: #{inspect(Map.keys(other))}\"\")\n    end\n    \n  {:ok, %{status_code: status}} ->\n    IO.puts(\"\"HTTP #{status} response\"\")\n    \n  {:error, reason} ->\n    IO.puts(\"\"Error: #{inspect(reason)}\"\")\nend\n')",
      "Bash(ZYTE_API_KEY=9e754bb61e684aad88a98eceada363ba mix run -e '\n# Test fetching raw HTML to see what we actually get\nurl = \"\"https://www.imdb.com/event/ev0000681/2025/1/\"\"\napi_key = Application.get_env(:cinegraph, :zyte_api_key)\n\nheaders = [\n  {\"\"Authorization\"\", \"\"Basic #{Base.encode64(api_key <> \"\":\"\")}\"\"},\n  {\"\"Content-Type\"\", \"\"application/json\"\"}\n]\n\nbody = Jason.encode!(%{\n  url: url,\n  browserHtml: true,\n  javascript: true,\n  viewport: %{width: 1920, height: 1080}\n})\n\ncase HTTPoison.post(\"\"https://api.zyte.com/v1/extract\"\", body, headers, timeout: 30_000, recv_timeout: 30_000) do\n  {:ok, %{status_code: 200, body: response}} ->\n    case Jason.decode(response) do\n      {:ok, %{\"\"browserHtml\"\" => html}} ->\n        # Save HTML for inspection\n        File.write!(\"\"venice_2025.html\"\", html)\n        IO.puts(\"\"HTML saved to venice_2025.html\"\")\n        \n        # Check for various possible data structures\n        has_next_data = String.contains?(html, \"\"__NEXT_DATA__\"\")\n        has_awards_section = String.contains?(html, \"\"event-awards\"\")\n        has_nominees = String.contains?(html, \"\"nominee\"\")\n        has_winner = String.contains?(html, \"\"winner\"\")\n        \n        IO.puts(\"\"\\n=== HTML Structure Analysis ===\"\")\n        IO.puts(\"\"Has __NEXT_DATA__: #{has_next_data}\"\")\n        IO.puts(\"\"Has awards section: #{has_awards_section}\"\")\n        IO.puts(\"\"Has nominees: #{has_nominees}\"\")\n        IO.puts(\"\"Has winner: #{has_winner}\"\")\n        \n        # Try to find the actual award data structure\n        if String.contains?(html, \"\"Golden Lion\"\") do\n          IO.puts(\"\"\\n✅ Found Golden Lion award mention\"\")\n        end\n        \n        if String.contains?(html, \"\"Silver Lion\"\") do\n          IO.puts(\"\"✅ Found Silver Lion award mention\"\")\n        end\n        \n        # Check for React/Next.js app structure\n        if String.contains?(html, \"\"data-testid\"\") do\n          IO.puts(\"\"\\n📊 Found data-testid attributes (likely React app)\"\")\n        end\n        \n      {:ok, other} ->\n        IO.puts(\"\"Unexpected response structure: #{inspect(Map.keys(other))}\"\")\n    end\n    \n  {:ok, %{status_code: status}} ->\n    IO.puts(\"\"HTTP #{status} response\"\")\n    \n  {:error, reason} ->\n    IO.puts(\"\"Error: #{inspect(reason)}\"\")\nend\n')",
      "Bash(ZYTE_API_KEY=9e754bb61e684aad88a98eceada363ba mix run test_venice_html.exs)",
      "Bash(ZYTE_API_KEY=9e754bb61e684aad88a98eceada363ba mix run -e '\n# Test Venice import with updated scraper\nresult = Cinegraph.Cultural.import_venice_year(2025)\nIO.inspect(result, label: \"\"Venice Import Result\"\")\n\n# Wait a bit for the job to start\nProcess.sleep(5000)\n\n# Check job status\nimport Ecto.Query\njob = Cinegraph.Repo.one(\n  from j in Oban.Job,\n  where: j.worker == \"\"Cinegraph.Workers.VeniceFestivalWorker\"\",\n  order_by: [desc: j.id],\n  limit: 1\n)\n\nif job do\n  IO.puts(\"\"\\nJob status: #{job.state}\"\")\n  if job.errors && length(job.errors) > 0 do\n    IO.puts(\"\"Errors: #{inspect(job.errors)}\"\")\n  end\nend\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres mix run -e '\n# Test Venice import with updated scraper that uses direct HTTP\nIO.puts(\"\"=== Testing Venice Import with Direct HTTP ===\"\")\n\n# Clear any stuck jobs first\nimport Ecto.Query\nalias Cinegraph.Repo\n\n{cancelled_count, _} = Repo.update_all(\n  from(j in Oban.Job, \n    where: j.worker == \"\"Cinegraph.Workers.VeniceFestivalWorker\"\" and j.state in [\"\"executing\"\", \"\"available\"\"]\n  ),\n  set: [state: \"\"cancelled\"\", cancelled_at: DateTime.utc_now()]\n)\n\nif cancelled_count > 0 do\n  IO.puts(\"\"Cancelled #{cancelled_count} stuck Venice jobs\"\")\nend\n\n# Try importing Venice 2025 again\nIO.puts(\"\"\\nImporting Venice 2025...\"\")\nresult = Cinegraph.Cultural.import_venice_year(2025)\nIO.inspect(result, label: \"\"Import Result\"\")\n\n# Wait for job to process\nProcess.sleep(10000)\n\n# Check job status\njob = Repo.one(\n  from j in Oban.Job,\n  where: j.worker == \"\"Cinegraph.Workers.VeniceFestivalWorker\"\",\n  order_by: [desc: j.id],\n  limit: 1\n)\n\nif job do\n  IO.puts(\"\"\\n📊 Latest Job Status: #{job.state}\"\")\n  \n  if job.state == \"\"completed\"\" do\n    IO.puts(\"\"✅ SUCCESS! Venice import completed\"\")\n    \n    # Check if ceremony was created\n    venice_org = Cinegraph.Festivals.get_organization_by_abbreviation(\"\"VIFF\"\")\n    if venice_org do\n      ceremony = Cinegraph.Festivals.get_ceremony_by_year(venice_org.id, 2025)\n      if ceremony do\n        IO.puts(\"\"\\n🎬 Venice 2025 Ceremony Created!\"\")\n        awards = ceremony.data[\"\"awards\"\"] || %{}\n        IO.puts(\"\"Found #{map_size(awards)} award categories\"\")\n        \n        # Check for nominations\n        nomination_count = Repo.one(\n          from n in Cinegraph.Festivals.FestivalNomination,\n          where: n.ceremony_id == ^ceremony.id,\n          select: count(n.id)\n        )\n        IO.puts(\"\"Created #{nomination_count} nominations\"\")\n      end\n    end\n  elsif job.state == \"\"failed\"\" || job.state == \"\"discarded\"\" do\n    IO.puts(\"\"❌ Job failed\"\")\n    if job.errors && length(job.errors) > 0 do\n      IO.puts(\"\"Errors: #{inspect(job.errors)}\"\")\n    end\n  else\n    IO.puts(\"\"⏳ Job still in state: #{job.state}\"\")\n  end\nend\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres mix run -e '\n# Test Venice import with updated scraper that uses direct HTTP\nIO.puts(\"\"=== Testing Venice Import with Direct HTTP ===\"\")\n\n# Clear any stuck jobs first\nimport Ecto.Query\nalias Cinegraph.Repo\n\n{cancelled_count, _} = Repo.update_all(\n  from(j in Oban.Job, \n    where: j.worker == \"\"Cinegraph.Workers.VeniceFestivalWorker\"\" and j.state in [\"\"executing\"\", \"\"available\"\"]\n  ),\n  set: [state: \"\"cancelled\"\", cancelled_at: DateTime.utc_now()]\n)\n\nif cancelled_count > 0 do\n  IO.puts(\"\"Cancelled #{cancelled_count} stuck Venice jobs\"\")\nend\n\n# Try importing Venice 2025 again\nIO.puts(\"\"\\nImporting Venice 2025...\"\")\nresult = Cinegraph.Cultural.import_venice_year(2025)\nIO.inspect(result, label: \"\"Import Result\"\")\n\n# Wait for job to process\nProcess.sleep(10000)\n\n# Check job status\njob = Repo.one(\n  from j in Oban.Job,\n  where: j.worker == \"\"Cinegraph.Workers.VeniceFestivalWorker\"\",\n  order_by: [desc: j.id],\n  limit: 1\n)\n\nif job do\n  IO.puts(\"\"\\n📊 Latest Job Status: #{job.state}\"\")\n  \n  if job.state == \"\"completed\"\" do\n    IO.puts(\"\"✅ SUCCESS! Venice import completed\"\")\n    \n    # Check if ceremony was created\n    venice_org = Cinegraph.Festivals.get_organization_by_abbreviation(\"\"VIFF\"\")\n    if venice_org do\n      ceremony = Cinegraph.Festivals.get_ceremony_by_year(venice_org.id, 2025)\n      if ceremony do\n        IO.puts(\"\"\\n🎬 Venice 2025 Ceremony Created!\"\")\n        awards = ceremony.data[\"\"awards\"\"] || %{}\n        IO.puts(\"\"Found #{map_size(awards)} award categories\"\")\n        \n        # Check for nominations\n        nomination_count = Repo.one(\n          from n in Cinegraph.Festivals.FestivalNomination,\n          where: n.ceremony_id == ^ceremony.id,\n          select: count(n.id)\n        )\n        IO.puts(\"\"Created #{nomination_count} nominations\"\")\n      end\n    end\n  elsif job.state == \"\"failed\"\" || job.state == \"\"discarded\"\" do\n    IO.puts(\"\"❌ Job failed\"\")\n    if job.errors && length(job.errors) > 0 do\n      IO.puts(\"\"Errors: #{inspect(job.errors)}\"\")\n    end\n  else\n    IO.puts(\"\"⏳ Job still in state: #{job.state}\"\")\n  end\nend\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres mix run -e '\n# Test 1: Direct HTTP request (no Zyte)\nurl = \"\"https://www.imdb.com/event/ev0000681/2024/1/\"\"\nIO.puts(\"\"=== Test 1: Direct HTTP (no Zyte) ===\"\")\nIO.puts(\"\"URL: #{url}\"\")\n\nheaders = [\n  {\"\"User-Agent\"\", \"\"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36\"\"},\n  {\"\"Accept\"\", \"\"text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\"\"}\n]\n\ncase HTTPoison.get(url, headers, timeout: 10_000, recv_timeout: 10_000) do\n  {:ok, %{status_code: 200, body: body}} ->\n    IO.puts(\"\"✅ SUCCESS! Got HTML (#{byte_size(body)} bytes)\"\")\n    # Check for Venice content\n    if String.contains?(body, \"\"Venice\"\") do\n      IO.puts(\"\"✅ Contains Venice content\"\")\n    end\n    if String.contains?(body, \"\"Golden Lion\"\") do\n      IO.puts(\"\"✅ Contains Golden Lion\"\")\n    end\n    \n  {:ok, %{status_code: status}} ->\n    IO.puts(\"\"❌ HTTP #{status} response\"\")\n    \n  {:error, reason} ->\n    IO.puts(\"\"❌ Error: #{inspect(reason)}\"\")\nend\n')",
      "Bash(ZYTE_API_KEY=9e754bb61e684aad88a98eceada363ba mix run -e '\n# Test 2: Zyte API\nurl = \"\"https://www.imdb.com/event/ev0000681/2024/1/\"\"\napi_key = Application.get_env(:cinegraph, :zyte_api_key)\n\nIO.puts(\"\"=== Test 2: Zyte API ===\"\")\nIO.puts(\"\"URL: #{url}\"\")\nIO.puts(\"\"API Key present: #{api_key != nil && api_key != \\\"\"\\\"\"}\"\")\n\nheaders = [\n  {\"\"Authorization\"\", \"\"Basic #{Base.encode64(api_key <> \"\":\"\")}\"\"},\n  {\"\"Content-Type\"\", \"\"application/json\"\"}\n]\n\nbody = Jason.encode!(%{\n  url: url,\n  browserHtml: true,\n  javascript: true,\n  viewport: %{width: 1920, height: 1080}\n})\n\ncase HTTPoison.post(\"\"https://api.zyte.com/v1/extract\"\", body, headers, timeout: 30_000, recv_timeout: 30_000) do\n  {:ok, %{status_code: 200, body: response}} ->\n    case Jason.decode(response) do\n      {:ok, %{\"\"browserHtml\"\" => html}} ->\n        IO.puts(\"\"✅ SUCCESS with Zyte! Got HTML (#{byte_size(html)} bytes)\"\")\n        if String.contains?(html, \"\"Venice\"\") do\n          IO.puts(\"\"✅ Contains Venice content\"\")\n        end\n        if String.contains?(html, \"\"Golden Lion\"\") do\n          IO.puts(\"\"✅ Contains Golden Lion\"\")\n        end\n      {:ok, _} ->\n        IO.puts(\"\"❌ Unexpected Zyte response structure\"\")\n    end\n    \n  {:ok, %{status_code: status}} ->\n    IO.puts(\"\"❌ Zyte API returned HTTP #{status}\"\")\n    \n  {:error, reason} ->\n    IO.puts(\"\"❌ Error calling Zyte: #{inspect(reason)}\"\")\nend\n')",
      "Bash(ZYTE_API_KEY=9e754bb61e684aad88a98eceada363ba mix run -e '\n# Test 2: Zyte API\nurl = \"\"https://www.imdb.com/event/ev0000681/2024/1/\"\"\napi_key = Application.get_env(:cinegraph, :zyte_api_key)\n\nIO.puts(\"\"=== Test 2: Zyte API ===\"\")\nIO.puts(\"\"URL: #{url}\"\")\nIO.puts(\"\"API Key present: #{not is_nil(api_key)}\"\")\n\nheaders = [\n  {\"\"Authorization\"\", \"\"Basic #{Base.encode64(api_key <> \"\":\"\")}\"\"},\n  {\"\"Content-Type\"\", \"\"application/json\"\"}\n]\n\nbody = Jason.encode!(%{\n  url: url,\n  browserHtml: true,\n  javascript: true,\n  viewport: %{width: 1920, height: 1080}\n})\n\ncase HTTPoison.post(\"\"https://api.zyte.com/v1/extract\"\", body, headers, timeout: 30_000, recv_timeout: 30_000) do\n  {:ok, %{status_code: 200, body: response}} ->\n    case Jason.decode(response) do\n      {:ok, %{\"\"browserHtml\"\" => html}} ->\n        IO.puts(\"\"✅ SUCCESS with Zyte! Got HTML (#{byte_size(html)} bytes)\"\")\n        if String.contains?(html, \"\"Venice\"\") do\n          IO.puts(\"\"✅ Contains Venice content\"\")\n        end\n        if String.contains?(html, \"\"Golden Lion\"\") do\n          IO.puts(\"\"✅ Contains Golden Lion\"\")\n        end\n      {:ok, _} ->\n        IO.puts(\"\"❌ Unexpected Zyte response structure\"\")\n    end\n    \n  {:ok, %{status_code: status}} ->\n    IO.puts(\"\"❌ Zyte API returned HTTP #{status}\"\")\n    \n  {:error, reason} ->\n    IO.puts(\"\"❌ Error calling Zyte: #{inspect(reason)}\"\")\nend\n')",
      "Bash(ZYTE_API_KEY=9e754bb61e684aad88a98eceada363ba mix run test_venice_fetch.exs)",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres mix run -e '\n# Test Venice import again\nIO.puts(\"\"Testing Venice import with association fix...\"\")\n\nresult = Cinegraph.Cultural.import_venice_year(2024)\nIO.inspect(result, label: \"\"Venice Import Result\"\")\n\n# Wait for job to process\nProcess.sleep(10000)\n\n# Check job status\nimport Ecto.Query\njob = Cinegraph.Repo.one(\n  from j in Oban.Job,\n  where: j.worker == \"\"Cinegraph.Workers.VeniceFestivalWorker\"\",\n  order_by: [desc: j.id],\n  limit: 1\n)\n\nif job do\n  IO.puts(\"\"\\n📊 Latest Job Status: #{job.state}\"\")\n  \n  if job.state == \"\"completed\"\" do\n    IO.puts(\"\"✅ SUCCESS! Venice import completed\"\")\n    \n    # Check for ceremony and nominations\n    venice_org = Cinegraph.Festivals.get_organization_by_abbreviation(\"\"VIFF\"\")\n    if venice_org do\n      ceremony = Cinegraph.Festivals.get_ceremony_by_year(venice_org.id, 2024)\n      if ceremony do\n        IO.puts(\"\"\\n🎬 Venice 2024 Ceremony Found!\"\")\n        awards = ceremony.data[\"\"awards\"\"] || %{}\n        IO.puts(\"\"Award categories: #{map_size(awards)}\"\")\n        \n        # Check for nominations created\n        nomination_count = Cinegraph.Repo.one(\n          from n in Cinegraph.Festivals.FestivalNomination,\n          where: n.ceremony_id == ^ceremony.id,\n          select: count(n.id)\n        )\n        IO.puts(\"\"Nominations created: #{nomination_count}\"\")\n      end\n    end\n  elsif job.state == \"\"failed\"\" || job.state == \"\"discarded\"\" do\n    IO.puts(\"\"❌ Job failed\"\")\n    if job.errors && length(job.errors) > 0 do\n      IO.puts(\"\"Errors: #{inspect(job.errors)}\"\")\n    end\n  else\n    IO.puts(\"\"⏳ Job still in state: #{job.state}\"\")\n  end\nend\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres mix run -e '\n# Test Venice import again\nIO.puts(\"\"Testing Venice import with association fix...\"\")\n\nresult = Cinegraph.Cultural.import_venice_year(2024)\nIO.inspect(result, label: \"\"Venice Import Result\"\")\n\n# Wait for job to process\nProcess.sleep(10000)\n\n# Check job status\nimport Ecto.Query\njob = Cinegraph.Repo.one(\n  from(j in Oban.Job,\n    where: j.worker == \"\"Cinegraph.Workers.VeniceFestivalWorker\"\",\n    order_by: [desc: j.id],\n    limit: 1\n  )\n)\n\nif job do\n  IO.puts(\"\"\\n📊 Latest Job Status: #{job.state}\"\")\n  \n  if job.state == \"\"completed\"\" do\n    IO.puts(\"\"✅ SUCCESS! Venice import completed\"\")\n    \n    # Check for ceremony and nominations\n    venice_org = Cinegraph.Festivals.get_organization_by_abbreviation(\"\"VIFF\"\")\n    if venice_org do\n      ceremony = Cinegraph.Festivals.get_ceremony_by_year(venice_org.id, 2024)\n      if ceremony do\n        IO.puts(\"\"\\n🎬 Venice 2024 Ceremony Found!\"\")\n        awards = ceremony.data[\"\"awards\"\"] || %{}\n        IO.puts(\"\"Award categories: #{map_size(awards)}\"\")\n        \n        # Check for nominations created\n        nomination_count = Cinegraph.Repo.one(\n          from(n in Cinegraph.Festivals.FestivalNomination,\n            where: n.ceremony_id == ^ceremony.id,\n            select: count(n.id)\n          )\n        )\n        IO.puts(\"\"Nominations created: #{nomination_count}\"\")\n      end\n    end\n  elsif job.state == \"\"failed\"\" || job.state == \"\"discarded\"\" do\n    IO.puts(\"\"❌ Job failed\"\")\n    if job.errors && length(job.errors) > 0 do\n      IO.puts(\"\"Errors: #{inspect(job.errors)}\"\")\n    end\n  else\n    IO.puts(\"\"⏳ Job still in state: #{job.state}\"\")\n  end\nend\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres mix run test_venice_worker_fix.exs)",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres mix run -e '\n# Check Venice import final status\nimport Ecto.Query\n\n# Check if ceremony was created\nvenice_org = Cinegraph.Festivals.get_organization_by_abbreviation(\"\"VIFF\"\")\nif venice_org do\n  ceremony = Cinegraph.Festivals.get_ceremony_by_year(venice_org.id, 2024)\n  if ceremony do\n    IO.puts(\"\"✅ Venice 2024 Ceremony Created!\"\")\n    awards = ceremony.data[\"\"awards\"\"] || %{}\n    IO.puts(\"\"Award categories: #{map_size(awards)}\"\")\n    \n    # Count nominations\n    nomination_count = Cinegraph.Repo.one(\n      from(n in Cinegraph.Festivals.FestivalNomination,\n        where: n.ceremony_id == ^ceremony.id,\n        select: count(n.id)\n      )\n    )\n    IO.puts(\"\"Nominations created: #{nomination_count}\"\")\n    \n    # Count by category\n    categories = Cinegraph.Repo.all(\n      from(n in Cinegraph.Festivals.FestivalNomination,\n        join: c in Cinegraph.Festivals.FestivalCategory, on: n.category_id == c.id,\n        where: n.ceremony_id == ^ceremony.id,\n        group_by: c.name,\n        select: {c.name, count(n.id)}\n      )\n    )\n    \n    IO.puts(\"\"\\n=== Nominations by Category ===\"\")\n    Enum.each(categories, fn {name, count} ->\n      IO.puts(\"\"  #{name}: #{count}\"\")\n    end)\n    \n    # Check for movies queued\n    queued_jobs = Cinegraph.Repo.one(\n      from(j in Oban.Job,\n        where: j.worker == \"\"Cinegraph.Workers.TMDbDetailsWorker\"\" and j.state in [\"\"available\"\", \"\"executing\"\"],\n        select: count(j.id)\n      )\n    )\n    IO.puts(\"\"\\nTMDb jobs still processing: #{queued_jobs}\"\")\n  end\nend\n')",
      "Bash(TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 mix run -e '\n# Test a few of the stuck IMDb IDs\nstuck_ids = [\"\"tt30810792\"\", \"\"tt28231777\"\", \"\"tt26341960\"\"]\n\nEnum.each(stuck_ids, fn imdb_id ->\n  result = Cinegraph.Services.TMDb.find_by_imdb_id(imdb_id)\n  case result do\n    {:ok, %{\"\"movie_results\"\" => []}} ->\n      IO.puts(\"\"#{imdb_id}: NOT FOUND in TMDb\"\")\n    {:ok, %{\"\"movie_results\"\" => [movie | _]}} ->\n      IO.puts(\"\"#{imdb_id}: Found - #{movie[\"\"title\"\"]} (#{movie[\"\"original_title\"\"]})\"\")\n    {:error, reason} ->\n      IO.puts(\"\"#{imdb_id}: ERROR - #{inspect(reason)}\"\")\n  end\nend)\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT id, worker, queue, state, attempt, max_attempts, errors FROM oban_jobs WHERE worker = ''Cinegraph.Workers.UnifiedFestivalWorker'' ORDER BY id DESC LIMIT 10;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT DISTINCT queue, COUNT(*) as job_count FROM oban_jobs GROUP BY queue ORDER BY queue;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT id, worker, queue, state, attempt, max_attempts FROM oban_jobs WHERE worker = ''Cinegraph.Workers.UnifiedFestivalWorker'' ORDER BY id DESC LIMIT 10;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT name, abbreviation FROM festival_organizations ORDER BY name;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT fc.year, fo.name, fc.name as ceremony_name FROM festival_ceremonies fc JOIN festival_organizations fo ON fc.organization_id = fo.id WHERE fc.year = 2024 ORDER BY fo.name;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT fo.name, COUNT(fn.id) as nominations_count FROM festival_organizations fo LEFT JOIN festival_ceremonies fc ON fo.id = fc.organization_id AND fc.year = 2024 LEFT JOIN festival_nominations fn ON fc.id = fn.ceremony_id GROUP BY fo.id, fo.name ORDER BY nominations_count DESC;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\n-- Check festival ceremonies \nSELECT \n  fo.name as festival,\n  COUNT(fc.id) as ceremonies,\n  STRING_AGG(DISTINCT fc.year::text, '', '' ORDER BY fc.year::text) as years\nFROM festival_organizations fo\nLEFT JOIN festival_ceremonies fc ON fo.id = fc.organization_id\nGROUP BY fo.id, fo.name\nORDER BY fo.name;\n\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\n-- Check festival nominations\nSELECT \n  fo.name as festival,\n  fc.year,\n  COUNT(fn.id) as total_nominations,\n  COUNT(CASE WHEN fn.won = true THEN 1 END) as total_wins,\n  COUNT(DISTINCT fcat.id) as categories\nFROM festival_organizations fo\nLEFT JOIN festival_ceremonies fc ON fo.id = fc.organization_id\nLEFT JOIN festival_nominations fn ON fc.id = fn.ceremony_id\nLEFT JOIN festival_categories fcat ON fn.category_id = fcat.id\nGROUP BY fo.id, fo.name, fc.year\nHAVING COUNT(fc.id) > 0\nORDER BY fo.name, fc.year;\n\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\n-- Check the specific nomination details\nSELECT \n  fo.name as festival,\n  fc.year,\n  fcat.name as category,\n  fn.won,\n  fn.prize_name,\n  m.title as movie_title,\n  m.imdb_id,\n  fn.details\nFROM festival_organizations fo\nJOIN festival_ceremonies fc ON fo.id = fc.organization_id\nJOIN festival_nominations fn ON fc.id = fn.ceremony_id\nJOIN festival_categories fcat ON fn.category_id = fcat.id\nLEFT JOIN movies m ON fn.movie_id = m.id\nWHERE fo.abbreviation = ''VIFF'' AND fc.year = 2024;\n\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\n-- Check all festival organizations and their ceremony status\nSELECT \n  fo.name as festival,\n  fo.abbreviation,\n  COUNT(fc.id) as ceremonies_count,\n  COUNT(fn.id) as nominations_count,\n  STRING_AGG(DISTINCT fc.year::text, '', '' ORDER BY fc.year::text) as ceremony_years\nFROM festival_organizations fo\nLEFT JOIN festival_ceremonies fc ON fo.id = fc.organization_id\nLEFT JOIN festival_nominations fn ON fc.id = fn.ceremony_id\nGROUP BY fo.id, fo.name, fo.abbreviation\nORDER BY fo.name;\n\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\n-- Check all festival ceremonies, including those without nominations\nSELECT \n  fo.name as festival,\n  fo.abbreviation,\n  fc.year,\n  fc.name as ceremony_name,\n  jsonb_array_length(COALESCE(fc.data -> ''awards'', ''{}''::jsonb)) as awards_in_data,\n  COUNT(fn.id) as nominations_count\nFROM festival_organizations fo\nLEFT JOIN festival_ceremonies fc ON fo.id = fc.organization_id\nLEFT JOIN festival_nominations fn ON fc.id = fn.ceremony_id\nGROUP BY fo.id, fo.name, fo.abbreviation, fc.id, fc.year, fc.name, fc.data\nORDER BY fo.name, fc.year;\n\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT jsonb_pretty(data) FROM festival_ceremonies WHERE year = 2024 AND organization_id = (SELECT id FROM festival_organizations WHERE abbreviation = ''VIFF'') LIMIT 1;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT id, worker, queue, state, args FROM oban_jobs WHERE worker = ''Cinegraph.Workers.FestivalDiscoveryWorker'' ORDER BY id DESC LIMIT 10;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT COUNT(*) as nominations FROM festival_nominations WHERE ceremony_id = 104;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=3ba3f8f9 mix run -e '\n# Queue a FestivalDiscoveryWorker job for Venice 2024 ceremony\nalias Cinegraph.Workers.FestivalDiscoveryWorker\n\njob_args = %{\n  \"\"ceremony_id\"\" => 104,\n  \"\"source\"\" => \"\"manual_test\"\"\n}\n\ncase FestivalDiscoveryWorker.new(job_args) |> Oban.insert() do\n  {:ok, job} ->\n    IO.puts(\"\"✅ Successfully queued FestivalDiscoveryWorker job #{job.id} for Venice 2024 ceremony\"\")\n    \n    # Wait for job to process\n    IO.puts(\"\"Waiting for job to process...\"\")\n    Process.sleep(15000)\n    \n    # Check updated nomination count\n    import Ecto.Query\n    count = Cinegraph.Repo.one(\n      from n in Cinegraph.Festivals.FestivalNomination,\n      where: n.ceremony_id == 104,\n      select: count(n.id)\n    )\n    \n    IO.puts(\"\"Updated nomination count: #{count}\"\")\n    \n  {:error, reason} ->\n    IO.puts(\"\"❌ Failed to queue job: #{inspect(reason)}\"\")\nend\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT jsonb_pretty(data->''''awards'''') FROM festival_ceremonies WHERE id = 104 LIMIT 1;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=3ba3f8f9 mix run -e '\n# Clear existing Venice nominations first\nIO.puts(\"\"Clearing existing Venice 2024 nominations...\"\")\nimport Ecto.Query\nCinegraph.Repo.delete_all(\n  from n in Cinegraph.Festivals.FestivalNomination,\n  where: n.ceremony_id == 104\n)\n\n# Queue a FestivalDiscoveryWorker job for Venice 2024 ceremony with fixed worker\nalias Cinegraph.Workers.FestivalDiscoveryWorker\n\njob_args = %{\n  \"\"ceremony_id\"\" => 104,\n  \"\"source\"\" => \"\"fixed_worker_test\"\"\n}\n\ncase FestivalDiscoveryWorker.new(job_args) |> Oban.insert() do\n  {:ok, job} ->\n    IO.puts(\"\"✅ Successfully queued FestivalDiscoveryWorker job #{job.id} for Venice 2024 ceremony\"\")\n    \n    # Wait for job to process\n    IO.puts(\"\"Waiting for job to process...\"\")\n    Process.sleep(20000)\n    \n    # Check updated nomination count\n    count = Cinegraph.Repo.one(\n      from n in Cinegraph.Festivals.FestivalNomination,\n      where: n.ceremony_id == 104,\n      select: count(n.id)\n    )\n    \n    IO.puts(\"\"Updated nomination count: #{count}\"\")\n    \n    # Show sample nominations\n    sample_nominations = Cinegraph.Repo.all(\n      from n in Cinegraph.Festivals.FestivalNomination,\n      join: c in Cinegraph.Festivals.FestivalCategory, on: n.category_id == c.id,\n      join: m in Cinegraph.Movies.Movie, on: n.movie_id == m.id,\n      where: n.ceremony_id == 104,\n      limit: 5,\n      select: %{\n        category: c.name,\n        movie_title: m.title,\n        won: n.won,\n        imdb_id: m.imdb_id\n      }\n    )\n    \n    IO.puts(\"\"\\\\nSample nominations:\"\")\n    Enum.each(sample_nominations, fn nom ->\n      winner_text = if nom.won, do: \"\" (WINNER)\"\", else: \"\"\"\"\n      IO.puts(\"\"  #{nom.category}: #{nom.movie_title} (#{nom.imdb_id})#{winner_text}\"\")\n    end)\n    \n  {:error, reason} ->\n    IO.puts(\"\"❌ Failed to queue job: #{inspect(reason)}\"\")\nend\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT id, state, errors FROM oban_jobs WHERE id = 42540;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT jsonb_pretty(meta) FROM oban_jobs WHERE id = 42540;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 mix run -e '\n# Test the data format detection for Venice ceremony\nceremony = Cinegraph.Repo.get(Cinegraph.Festivals.FestivalCeremony, 104) |> Cinegraph.Repo.preload(:organization)\n\nif ceremony do\n  IO.puts(\"\"Ceremony: #{ceremony.organization.abbreviation} #{ceremony.year}\"\")\n  \n  # Test extract_categories function\n  defmodule TestExtractor do\n    def extract_categories(data) do\n      cond do\n        # Oscar format: data[\"\"categories\"\"] with nominees inside\n        data[\"\"categories\"\"] || data[:categories] ->\n          categories = data[\"\"categories\"\"] || data[:categories] || []\n          {categories, :oscar_format}\n        \n        # Venice/Festival format: data[\"\"awards\"\"] with categories as keys\n        data[\"\"awards\"\"] || data[:awards] ->\n          awards = data[\"\"awards\"\"] || data[:awards] || %{}\n          # Convert to list of {category_name, nominees} tuples  \n          categories = Enum.map(awards, fn {category_name, nominees} ->\n            {category_name, nominees}\n          end)\n          {categories, :awards_format}\n        \n        true ->\n          {[], :unknown_format}\n      end\n    end\n  end\n  \n  {categories, format} = TestExtractor.extract_categories(ceremony.data)\n  \n  IO.puts(\"\"Format detected: #{format}\"\")\n  IO.puts(\"\"Categories found: #{length(categories)}\"\")\n  \n  if length(categories) > 0 do\n    IO.puts(\"\"\\\\nFirst category:\"\")\n    first_category = List.first(categories)\n    \n    case format do\n      :awards_format ->\n        {category_name, nominees} = first_category\n        IO.puts(\"\"  Name: #{category_name}\"\")\n        IO.puts(\"\"  Nominees: #{length(nominees)}\"\")\n        if length(nominees) > 0 do\n          first_nominee = List.first(nominees)\n          IO.puts(\"\"  First nominee keys: #{inspect(Map.keys(first_nominee))}\"\")\n          IO.puts(\"\"  First nominee: #{inspect(first_nominee, limit: :infinity)}\"\")\n        end\n      :oscar_format ->\n        IO.puts(\"\"  Category data: #{inspect(first_category, limit: :infinity)}\"\")\n    end\n  end\nelse\n  IO.puts(\"\"Ceremony not found\"\")\nend\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT jsonb_object_keys(data) FROM festival_ceremonies WHERE id = 104;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT jsonb_pretty(data->''''categories'''') FROM festival_ceremonies WHERE id = 104 LIMIT 1;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=3ba3f8f9 mix run -e '\n# Queue another FestivalDiscoveryWorker job for Venice 2024 ceremony with the fix\nalias Cinegraph.Workers.FestivalDiscoveryWorker\n\njob_args = %{\n  \"\"ceremony_id\"\" => 104,\n  \"\"source\"\" => \"\"format_detection_fix_test\"\"\n}\n\ncase FestivalDiscoveryWorker.new(job_args) |> Oban.insert() do\n  {:ok, job} ->\n    IO.puts(\"\"✅ Successfully queued FestivalDiscoveryWorker job #{job.id} for Venice 2024 ceremony\"\")\n    \n    # Wait for job to process\n    IO.puts(\"\"Waiting for job to process...\"\")\n    Process.sleep(15000)\n    \n    # Check updated nomination count\n    import Ecto.Query\n    count = Cinegraph.Repo.one(\n      from n in Cinegraph.Festivals.FestivalNomination,\n      where: n.ceremony_id == 104,\n      select: count(n.id)\n    )\n    \n    IO.puts(\"\"Updated nomination count: #{count}\"\")\n    \n    # Check what categories were created\n    categories = Cinegraph.Repo.all(\n      from c in Cinegraph.Festivals.FestivalCategory,\n      where: c.organization_id == 71,\n      select: %{id: c.id, name: c.name}\n    )\n    \n    IO.puts(\"\"Categories created: #{length(categories)}\"\")\n    Enum.each(categories, fn cat ->\n      IO.puts(\"\"  - #{cat.name} (ID: #{cat.id})\"\")\n    end)\n    \n  {:error, reason} ->\n    IO.puts(\"\"❌ Failed to queue job: #{inspect(reason)}\"\")\nend\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\nSELECT \n    fo.name as festival,\n    fo.abbreviation,\n    COUNT(fc.id) as ceremonies,\n    COUNT(fn.id) as total_nominations,\n    COUNT(CASE WHEN fn.won = true THEN 1 END) as total_wins,\n    COUNT(DISTINCT fcat.id) as categories\nFROM festival_organizations fo\nLEFT JOIN festival_ceremonies fc ON fo.id = fc.organization_id\nLEFT JOIN festival_nominations fn ON fc.id = fn.ceremony_id\nLEFT JOIN festival_categories fcat ON fn.category_id = fcat.id\nGROUP BY fo.id, fo.name, fo.abbreviation\nORDER BY fo.name;\n\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT \n  ''Ceremonies'' as table_name, COUNT(*) as count \nFROM festival_ceremonies \nUNION ALL \nSELECT \n  ''Categories'' as table_name, COUNT(*) as count \nFROM festival_categories\nUNION ALL\nSELECT \n  ''Nominations'' as table_name, COUNT(*) as count \nFROM festival_nominations\nORDER BY table_name;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT \n  c.id, c.year, c.name, o.name as organization_name, o.abbreviation\nFROM festival_ceremonies c \nJOIN festival_organizations o ON c.organization_id = o.id;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT version FROM schema_migrations ORDER BY version DESC LIMIT 10;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\\d festival_nominations\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT COUNT(*) FROM festival_events;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT source_key, name, active, source_config FROM festival_events ORDER BY source_key;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=3ba3f8f9 mix run -e \"\n# Test if we can find Venice festival\ncase Cinegraph.Events.get_active_by_source_key(\"\"venice\"\") do\n  nil -> \n    IO.puts(\"\"❌ Venice festival not found in database\"\")\n  festival_event ->\n    IO.puts(\"\"✅ Found Venice festival: #{festival_event.name}\"\")\n    \n    # Test scraper configuration conversion\n    scraper_config = Cinegraph.Events.FestivalEvent.to_scraper_config(festival_event)\n    IO.puts(\"\"Scraper config: #{inspect(scraper_config, pretty: true)}\"\")\n    \n    # Test fetching festival data\n    IO.puts(\"\"\\nTesting festival data fetch for 2024...\"\")\n    case Cinegraph.Scrapers.UnifiedFestivalScraper.fetch_festival_data(\"\"venice\"\", 2024) do\n      {:ok, data} ->\n        IO.puts(\"\"✅ Successfully fetched festival data\"\")\n        IO.puts(\"\"Awards found: #{map_size(data.awards || %{})}\"\")\n        \n        # Show first few award categories\n        if map_size(data.awards || %{}) > 0 do\n          IO.puts(\"\"\\nFirst few categories:\"\")\n          data.awards\n          |> Enum.take(3)\n          |> Enum.each(fn {category, nominations} ->\n            IO.puts(\"\"  - #{category}: #{length(nominations)} nominations\"\")\n          end)\n        end\n        \n      {:error, reason} ->\n        IO.puts(\"\"❌ Failed to fetch festival data: #{inspect(reason)}\"\")\n    end\nend\n\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=3ba3f8f9 mix run -e \"\n# Test Venice import to restore nominations\nIO.puts(\"\"🎬 Testing Venice Festival Import for 2024\"\")\n\n# Use the VeniceFestivalWorker directly\ncase Cinegraph.Workers.VeniceFestivalWorker.queue_year(2024) do\n  {:ok, job} ->\n    IO.puts(\"\"✅ Successfully queued Venice 2024 import job: #{job.id}\"\")\n    IO.puts(\"\"Job will be processed by Oban worker. Check the dashboard for progress.\"\")\n    \n  {:error, reason} ->\n    IO.puts(\"\"❌ Failed to queue Venice import: #{inspect(reason)}\"\")\nend\n\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT \n  ''Ceremonies'' as table_name, COUNT(*) as count \nFROM festival_ceremonies \nUNION ALL \nSELECT \n  ''Categories'' as table_name, COUNT(*) as count \nFROM festival_categories\nUNION ALL\nSELECT \n  ''Nominations'' as table_name, COUNT(*) as count \nFROM festival_nominations\nORDER BY table_name;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT COUNT(*) as total_wins FROM festival_nominations WHERE won = true;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT COUNT(*) FROM festival_nominations WHERE ceremony_id = (SELECT id FROM festival_ceremonies WHERE year = 2024 AND organization_id = (SELECT id FROM festival_organizations WHERE abbreviation = ''VIFF''));\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=3ba3f8f9 mix run -e '\n# Queue a FestivalDiscoveryWorker job for Venice 2024 ceremony with the bug fix\nalias Cinegraph.Workers.FestivalDiscoveryWorker\n\njob_args = %{\n  \"\"ceremony_id\"\" => 111,\n  \"\"source\"\" => \"\"manual_bug_fix_test\"\"\n}\n\ncase FestivalDiscoveryWorker.new(job_args) |> Oban.insert() do\n  {:ok, job} ->\n    IO.puts(\"\"✅ Successfully queued FestivalDiscoveryWorker job #{job.id} for Venice 2024 ceremony (ID: 111)\"\")\n    \n    # Wait for job to process\n    IO.puts(\"\"Waiting for job to process...\"\")\n    Process.sleep(15000)\n    \n    # Check updated nomination count\n    import Ecto.Query\n    count = Cinegraph.Repo.one(\n      from n in Cinegraph.Festivals.FestivalNomination,\n      where: n.ceremony_id == 111,\n      select: count(n.id)\n    )\n    \n    IO.puts(\"\"Venice 2024 nomination count after fix: #{count}\"\")\n    \n  {:error, reason} ->\n    IO.puts(\"\"❌ Failed to queue job: #{inspect(reason)}\"\")\nend')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT abbreviation, name FROM festival_organizations ORDER BY name;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\nSELECT \n    fo.abbreviation,\n    fo.name,\n    COUNT(DISTINCT fc.id) as ceremonies,\n    COUNT(fn.id) as nominations,\n    COUNT(CASE WHEN fn.won = true THEN 1 END) as wins\nFROM festival_organizations fo\nLEFT JOIN festival_ceremonies fc ON fo.id = fc.organization_id\nLEFT JOIN festival_nominations fn ON fc.id = fn.ceremony_id\nGROUP BY fo.id, fo.abbreviation, fo.name\nORDER BY fo.name;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres mix run:*)",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\n-- Check the raw Cannes 2024 ceremony data structure\nSELECT \n    fc.id,\n    fc.year,\n    fo.name as organization,\n    jsonb_pretty(fc.data) as ceremony_data\nFROM festival_ceremonies fc\nJOIN festival_organizations fo ON fc.organization_id = fo.id\nWHERE fo.abbreviation = ''''CFF'''' AND fc.year = 2024;\n\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\n-- Extract just the award winners from Cannes 2024 ceremony data\nSELECT \n    award_name,\n    jsonb_array_length(awards) as total_entries,\n    (SELECT COUNT(*) FROM jsonb_array_elements(awards) AS elem WHERE elem ->> ''winner'' = ''true'') as winners\nFROM (\n    SELECT \n        key as award_name,\n        value as awards\n    FROM festival_ceremonies fc\n    JOIN festival_organizations fo ON fc.organization_id = fo.id\n    CROSS JOIN jsonb_each(fc.data -> ''awards'') \n    WHERE fo.abbreviation = ''CFF'' AND fc.year = 2024\n) award_data;\n\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\n-- Check the most recent FestivalDiscoveryWorker jobs for Cannes ceremony\nSELECT \n    j.id,\n    j.state,\n    j.worker,\n    j.args ->> ''ceremony_id'' as ceremony_id,\n    j.inserted_at,\n    j.completed_at,\n    j.meta\nFROM oban_jobs j\nWHERE j.worker = ''Cinegraph.Workers.FestivalDiscoveryWorker''\n  AND j.args ->> ''ceremony_id'' = ''121''\nORDER BY j.id DESC\nLIMIT 5;\n\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\n-- Check if Cannes movies were actually created from TMDb jobs\nSELECT \n    COUNT(*) as cannes_movies_with_imdb,\n    COUNT(CASE WHEN m.tmdb_data IS NOT NULL THEN 1 END) as with_tmdb_data\nFROM movies m\nWHERE m.imdb_id IN (\n    -- Get all IMDb IDs from Cannes 2024 ceremony data\n    SELECT DISTINCT elem ->> ''imdb_id'' as imdb_id\n    FROM festival_ceremonies fc\n    JOIN festival_organizations fo ON fc.organization_id = fo.id\n    CROSS JOIN jsonb_each(fc.data -> ''awards'') AS awards(category, nominees)\n    CROSS JOIN jsonb_array_elements(nominees) AS nominee\n    CROSS JOIN jsonb_array_elements(nominee -> ''films'') AS elem\n    WHERE fo.abbreviation = ''CFF'' AND fc.year = 2024 \n      AND elem ->> ''imdb_id'' IS NOT NULL\n);\n\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=3ba3f8f9 mix run -e '\n# Debug the FestivalDiscoveryWorker processing for Cannes\nceremony = Cinegraph.Repo.get(Cinegraph.Festivals.FestivalCeremony, 121) |> Cinegraph.Repo.preload(:organization)\n\nIO.puts(\"\"=== Debugging Cannes 2024 Processing (Ceremony ID: #{ceremony.id}) ===\"\")\n\n# Test the format detection (should be awards_format)\n{categories, format} = ceremony.data\n|> case do\n  data ->\n    oscar_categories = data[\"\"categories\"\"] || data[:categories] || []\n    awards = data[\"\"awards\"\"] || data[:awards] || %{}\n    \n    cond do\n      length(oscar_categories) > 0 ->\n        {oscar_categories, :oscar_format}\n      map_size(awards) > 0 ->\n        categories = Enum.map(awards, fn {category_name, nominees} ->\n          {category_name, nominees}\n        end)\n        {categories, :awards_format}\n      true ->\n        {[], :unknown_format}\n    end\nend\n\nIO.puts(\"\"Format detected: #{format}\"\")\nIO.puts(\"\"Categories found: #{length(categories)}\"\")\n\n# Test processing the first category (palme_dor) with its nominees\nfirst_category = List.first(categories)\n{category_name, nominees} = first_category\n\nIO.puts(\"\"\\\\nFirst category: #{category_name} (#{length(nominees)} nominees)\"\")\n\n# Check the structure of the first nominee\nfirst_nominee = List.first(nominees)\nIO.puts(\"\"\\\\nFirst nominee structure:\"\")\nIO.inspect(first_nominee, pretty: true, limit: :infinity)\n\n# Test film extraction\nfilms = first_nominee[\"\"films\"\"] || []\nif length(films) > 0 do\n  film = List.first(films)\n  imdb_id = film[\"\"imdb_id\"\"] \n  title = film[\"\"title\"\"] \n  year = film[\"\"year\"\"]\n  IO.puts(\"\"\\\\nExtracted film info:\"\")\n  IO.puts(\"\"  IMDb ID: #{imdb_id}\"\")\n  IO.puts(\"\"  Title: #{title}\"\")\n  IO.puts(\"\"  Year: #{year}\"\")\n  \n  # Check if movie exists\n  movie = Cinegraph.Repo.get_by(Cinegraph.Movies.Movie, imdb_id: imdb_id)\n  IO.puts(\"\"  Movie in DB: #{if movie, do: \"\"YES (ID: #{movie.id})\"\", else: \"\"NO\"\"}\"\")\nend\n\n# Check winner status\nis_winner = first_nominee[\"\"winner\"\"] || false\nIO.puts(\"\"\\\\nWinner status: #{is_winner}\"\")\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\n-- Check if any of the Cannes nominations have movie_id populated\nSELECT \n    fn.id,\n    fn.movie_id,\n    fn.won,\n    fc.name as category_name,\n    fn.details,\n    CASE \n        WHEN fn.movie_id IS NOT NULL THEN m.title \n        ELSE ''NO MOVIE LINKED'' \n    END as movie_title\nFROM festival_nominations fn\nJOIN festival_ceremonies fcer ON fn.ceremony_id = fcer.id  \nJOIN festival_organizations fo ON fcer.organization_id = fo.id\nJOIN festival_categories fc ON fn.category_id = fc.id\nLEFT JOIN movies m ON fn.movie_id = m.id\nWHERE fo.abbreviation = ''CFF'' AND fcer.year = 2024\nORDER BY fn.id;\n\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\n-- Check if The Substance (tt17526714) should be marked as winner in ceremony data\nSELECT \n    award_category,\n    film_title,\n    film_imdb_id,\n    winner_status\nFROM (\n    SELECT \n        awards.key as award_category,\n        elem -> ''films'' -> 0 ->> ''title'' as film_title,\n        elem -> ''films'' -> 0 ->> ''imdb_id'' as film_imdb_id,\n        elem ->> ''winner'' as winner_status\n    FROM festival_ceremonies fc\n    CROSS JOIN jsonb_each(fc.data -> ''awards'') AS awards(key, value)\n    CROSS JOIN jsonb_array_elements(value) AS elem\n    WHERE fc.id = 121\n) winners\nWHERE film_imdb_id = ''tt17526714'';\n\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\n-- Look for recent Oban job logs that might show what was skipped\nSELECT \n    j.id,\n    j.errors\nFROM oban_jobs j\nWHERE j.id = 45027\n  AND j.errors IS NOT NULL;\n\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\n-- First, let''s clear the existing broken Cannes nominations\nDELETE FROM festival_nominations \nWHERE ceremony_id = 121;\n\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=3ba3f8f9 mix run -e '\n# Re-run FestivalDiscoveryWorker for Cannes ceremony 121\nalias Cinegraph.Workers.FestivalDiscoveryWorker\n\njob_args = %{\n  \"\"ceremony_id\"\" => 121,\n  \"\"source\"\" => \"\"manual_rerun_after_debug\"\"\n}\n\nIO.puts(\"\"=== Re-running FestivalDiscoveryWorker for Cannes 2024 ===\"\")\n\ncase FestivalDiscoveryWorker.new(job_args) |> Oban.insert() do\n  {:ok, job} ->\n    IO.puts(\"\"✅ Queued FestivalDiscoveryWorker job #{job.id} for Cannes ceremony 121\"\")\n    \n    # Wait for job to complete\n    IO.puts(\"\"Waiting for job to process...\"\")\n    Process.sleep(30000)\n    \n    # Check results\n    import Ecto.Query\n    \n    # Count nominations created\n    nomination_count = Cinegraph.Repo.one(\n      from n in Cinegraph.Festivals.FestivalNomination,\n      where: n.ceremony_id == 121,\n      select: count(n.id)\n    )\n    \n    # Count winners\n    winner_count = Cinegraph.Repo.one(\n      from n in Cinegraph.Festivals.FestivalNomination,\n      where: n.ceremony_id == 121 and n.won == true,\n      select: count(n.id)\n    )\n    \n    IO.puts(\"\"\\\\n=== Results After Re-run ===\"\")\n    IO.puts(\"\"Nominations created: #{nomination_count}\"\")\n    IO.puts(\"\"Winners found: #{winner_count}\"\")\n    \n    if nomination_count > 7 do\n      IO.puts(\"\"✅ SUCCESS: More nominations created than before!\"\")\n    else\n      IO.puts(\"\"❌ STILL BROKEN: Same issue persists\"\")\n    end\n    \n  {:error, reason} ->\n    IO.puts(\"\"❌ Failed to queue job: #{inspect(reason)}\"\")\nend\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\n-- Verify the Cannes 2024 data is now correct\nSELECT \n    fo.abbreviation,\n    fo.name,\n    COUNT(DISTINCT fc.id) as ceremonies,\n    COUNT(fn.id) as nominations,\n    COUNT(CASE WHEN fn.won = true THEN 1 END) as wins\nFROM festival_organizations fo\nLEFT JOIN festival_ceremonies fc ON fo.id = fc.organization_id\nLEFT JOIN festival_nominations fn ON fc.id = fn.ceremony_id\nWHERE fo.abbreviation = ''CFF''\nGROUP BY fo.id, fo.abbreviation, fo.name;\n\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\n-- Check sample Cannes winners to verify data quality\nSELECT \n    fcat.name as category,\n    m.title as movie_title,\n    m.imdb_id,\n    fn.won,\n    fn.details ->> ''nominee_names'' as person_names\nFROM festival_nominations fn\nJOIN festival_ceremonies fc ON fn.ceremony_id = fc.id\nJOIN festival_organizations fo ON fc.organization_id = fo.id\nJOIN festival_categories fcat ON fn.category_id = fcat.id\nJOIN movies m ON fn.movie_id = m.id\nWHERE fo.abbreviation = ''CFF'' AND fc.year = 2024 AND fn.won = true\nORDER BY fcat.name\nLIMIT 10;\n\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT ''Events'' as system, source_key, name FROM festival_events UNION ALL SELECT ''Organizations'' as system, abbreviation, name FROM festival_organizations ORDER BY system, name;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT source_key FROM festival_events WHERE source_key != ''oscars'' ORDER BY source_key;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT source_key FROM festival_events WHERE source_key <> ''oscars'' ORDER BY source_key;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\n-- Check if Academy Awards organization exists in festival_organizations table\nSELECT \n  ''AMPAS in festival_organizations'' as check_type,\n  CASE \n    WHEN COUNT(*) > 0 THEN ''EXISTS'' \n    ELSE ''MISSING'' \n  END as status,\n  COUNT(*) as count\nFROM festival_organizations \nWHERE abbreviation = ''AMPAS''\n\nUNION ALL\n\n-- Check if oscars event exists in festival_events table  \nSELECT \n  ''oscars in festival_events'' as check_type,\n  CASE \n    WHEN COUNT(*) > 0 THEN ''EXISTS'' \n    ELSE ''MISSING'' \n  END as status,\n  COUNT(*) as count\nFROM festival_events \nWHERE source_key = ''oscars''\n\nUNION ALL\n\n-- Check all festival organizations\nSELECT \n  ''Total festival_organizations'' as check_type,\n  ''INFO'' as status,\n  COUNT(*) as count\nFROM festival_organizations\n\nUNION ALL\n\n-- Check all festival events\nSELECT \n  ''Total festival_events'' as check_type,\n  ''INFO'' as status,\n  COUNT(*) as count\nFROM festival_events\n\nORDER BY check_type;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\n-- Check Oscar festival event details\nSELECT \n  source_key,\n  name,\n  abbreviation,\n  active,\n  primary_source,\n  tracks_nominations,\n  tracks_winners_only,\n  min_available_year,\n  max_available_year\nFROM festival_events \nWHERE source_key = ''oscars'';\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=3ba3f8f9 mix run -e '\n# Test what UnifiedFestivalScraper returns for \"\"oscars\"\"\ncase Cinegraph.Scrapers.UnifiedFestivalScraper.get_festival_config(\"\"oscars\"\") do\n  nil -> \n    IO.puts(\"\"❌ UnifiedFestivalScraper.get_festival_config(\\\"\"oscars\\\"\") returns nil\"\")\n    \n    # Test the underlying Events call\n    case Cinegraph.Events.get_active_by_source_key(\"\"oscars\"\") do\n      nil -> IO.puts(\"\"❌ Events.get_active_by_source_key(\\\"\"oscars\\\"\") returns nil\"\")\n      event -> IO.puts(\"\"✅ Events.get_active_by_source_key(\\\"\"oscars\\\"\") found: #{event.name}\"\")\n    end\n    \n  config -> \n    IO.puts(\"\"✅ UnifiedFestivalScraper.get_festival_config(\\\"\"oscars\\\"\") found config:\"\")\n    IO.inspect(config, pretty: true)\nend\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\n-- Check recent UnifiedFestivalWorker jobs for oscars\nSELECT \n  id,\n  worker,\n  args ->> ''festival'' as festival,\n  args ->> ''year'' as year,\n  state,\n  attempt,\n  max_attempts,\n  inserted_at,\n  completed_at,\n  errors\nFROM oban_jobs \nWHERE worker = ''Cinegraph.Workers.UnifiedFestivalWorker'' \n  AND args ->> ''festival'' = ''oscars''\nORDER BY id DESC \nLIMIT 10;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\n-- Check recent FestivalDiscoveryWorker job failures\nSELECT \n  id,\n  worker,\n  args ->> ''ceremony_id'' as ceremony_id,\n  state,\n  attempt,\n  max_attempts,\n  inserted_at,\n  completed_at,\n  CASE \n    WHEN errors IS NOT NULL THEN substring(errors::text, 1, 200) || ''...''\n    ELSE ''No errors''\n  END as error_summary\nFROM oban_jobs \nWHERE worker = ''Cinegraph.Workers.FestivalDiscoveryWorker'' \n  AND state IN (''failed'', ''retryable'', ''discarded'')\nORDER BY id DESC \nLIMIT 15;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\n-- Check all possible job states\nSELECT DISTINCT state, COUNT(*) \nFROM oban_jobs \nWHERE worker = ''Cinegraph.Workers.FestivalDiscoveryWorker''\nGROUP BY state\nORDER BY state;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\n-- Check UnifiedFestivalWorker job states\nSELECT \n  worker,\n  state,\n  COUNT(*) as job_count,\n  MIN(inserted_at) as earliest,\n  MAX(completed_at) as latest_completed\nFROM oban_jobs \nWHERE worker IN (''Cinegraph.Workers.UnifiedFestivalWorker'', ''Cinegraph.Workers.FestivalDiscoveryWorker'')\nGROUP BY worker, state\nORDER BY worker, state;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\n-- Check job timing and potential overlaps\nSELECT \n  id,\n  worker,\n  args ->> ''festival'' as festival,\n  args ->> ''year'' as year,\n  args ->> ''ceremony_id'' as ceremony_id,\n  state,\n  inserted_at,\n  completed_at,\n  EXTRACT(EPOCH FROM (completed_at - inserted_at)) as duration_seconds\nFROM oban_jobs \nWHERE worker IN (''Cinegraph.Workers.UnifiedFestivalWorker'', ''Cinegraph.Workers.FestivalDiscoveryWorker'')\nORDER BY inserted_at DESC \nLIMIT 20;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\n-- Check constraints and indexes on festival_nominations table\n\\d festival_nominations\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\nSELECT\n  conname as constraint_name,\n  contype as constraint_type,\n  conkey as column_positions,\n  pg_get_constraintdef(oid) as definition\nFROM pg_constraint \nWHERE conrelid = ''festival_nominations''::regclass;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\n-- Check for duplicate nominations\nSELECT \n  ceremony_id,\n  category_id,\n  movie_id,\n  person_id,\n  COUNT(*) as duplicate_count\nFROM festival_nominations\nGROUP BY ceremony_id, category_id, movie_id, person_id\nHAVING COUNT(*) > 1\nORDER BY duplicate_count DESC\nLIMIT 10;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\n-- Check nominations with NULL movie_id (waiting for TMDb jobs to complete)\nSELECT \n  fo.name as festival,\n  fc.year,\n  fcat.name as category,\n  COUNT(*) as nominations_without_movie\nFROM festival_nominations fn\nJOIN festival_ceremonies fc ON fn.ceremony_id = fc.id\nJOIN festival_organizations fo ON fc.organization_id = fo.id\nJOIN festival_categories fcat ON fn.category_id = fcat.id\nWHERE fn.movie_id IS NULL\nGROUP BY fo.name, fc.year, fcat.name\nORDER BY nominations_without_movie DESC\nLIMIT 10;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\n-- Check if ceremony data was processed multiple times\nSELECT \n  fc.id as ceremony_id,\n  fo.name as festival,\n  fc.year,\n  COUNT(fn.id) as total_nominations,\n  MAX(fn.inserted_at) as latest_nomination_created,\n  MIN(fn.inserted_at) as earliest_nomination_created,\n  COUNT(DISTINCT DATE_TRUNC(''minute'', fn.inserted_at)) as processing_sessions\nFROM festival_ceremonies fc\nJOIN festival_organizations fo ON fc.organization_id = fo.id\nLEFT JOIN festival_nominations fn ON fn.ceremony_id = fc.id\nWHERE fc.year = 2024\nGROUP BY fc.id, fo.name, fc.year\nORDER BY fo.name;\")",
      "Bash(git reset:*)",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT source_key, name, country, founded_year, primary_source FROM festival_events ORDER BY import_priority DESC, typical_start_month;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT fe.source_key, fe.name, fd.year, fd.start_date, fd.end_date, fd.status FROM festival_events fe LEFT JOIN festival_dates fd ON fe.id = fd.festival_event_id ORDER BY fe.source_key, fd.year;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT source_key, name, active, tracks_awards FROM movie_lists ORDER BY source_key;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT source_key, name, active, import_priority FROM festival_events ORDER BY import_priority DESC, name;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT source_key, COUNT(DISTINCT fc.year) AS ceremonies, COUNT(fn.id) AS total_nominations, COUNT(CASE WHEN fn.won = true THEN 1 END) AS total_wins FROM festival_events fe LEFT JOIN festival_ceremonies fc ON fe.id = fc.organization_id LEFT JOIN festival_nominations fn ON fc.id = fn.ceremony_id GROUP BY fe.source_key, fe.name ORDER BY fe.import_priority DESC;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT fo.abbreviation, COUNT(DISTINCT fc.year) AS ceremonies, COUNT(fn.id) AS total_nominations, COUNT(CASE WHEN fn.won = true THEN 1 END) AS total_wins FROM festival_organizations fo LEFT JOIN festival_ceremonies fc ON fo.id = fc.organization_id LEFT JOIN festival_nominations fn ON fc.id = fn.ceremony_id GROUP BY fo.id, fo.abbreviation ORDER BY total_nominations DESC;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\\dt\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT COUNT(*) FROM festival_ceremonies;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT COUNT(*) FROM festival_nominations;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT source_key, name, source_config FROM festival_events WHERE source_key IN (''venice'', ''cannes'', ''berlin'') ORDER BY source_key;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=3ba3f8f9 mix run -e \"\n# Test the restored database-driven festival scraper\nIO.puts(\"\"Testing database-driven festival scraper...\"\")\n\n# Test fetching Venice 2024 data  \ncase Cinegraph.Scrapers.UnifiedFestivalScraper.fetch_festival_data(\"\"venice\"\", 2024) do\n  {:ok, data} ->\n    IO.puts(\"\"✅ Successfully fetched Venice 2024 data\"\")\n    IO.puts(\"\"Festival: #{data.festival}\"\")\n    IO.puts(\"\"Awards count: #{map_size(data.awards || %{})}\"\")\n    \n    # Show first few award categories\n    if map_size(data.awards || %{}) > 0 do\n      IO.puts(\"\"\\nFirst few categories:\"\")\n      data.awards\n      |> Enum.take(3)\n      |> Enum.each(fn {category, nominations} ->\n        IO.puts(\"\"  - #{category}: #{length(nominations)} nominations\"\")\n      end)\n    end\n    \n  {:error, reason} ->\n    IO.puts(\"\"❌ Failed to fetch Venice data: #{inspect(reason)}\"\")\nend\n\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=3ba3f8f9 mix run -e \"\n# Test Venice festival import using the worker\nIO.puts(\"\"Testing Venice 2024 import...\"\")\n\ncase Cinegraph.Workers.VeniceFestivalWorker.queue_year(2024) do\n  {:ok, job} ->\n    IO.puts(\"\"✅ Successfully queued Venice 2024 import job: #{job.id}\"\")\n    IO.puts(\"\"Job state: #{job.state}\"\")\n    \n  {:error, reason} ->\n    IO.puts(\"\"❌ Failed to queue Venice import: #{inspect(reason)}\"\")\nend\n\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT COUNT(*) FROM festival_nominations;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT fn.id, fn.won, fc.year, fcat.name as category, m.title as movie FROM festival_nominations fn JOIN festival_ceremonies fc ON fn.ceremony_id = fc.id JOIN festival_categories fcat ON fn.category_id = fcat.id LEFT JOIN movies m ON fn.movie_id = m.id ORDER BY fn.id;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT fe.source_key, fe.name, COUNT(fc.id) as ceremonies, COUNT(fn.id) as nominations FROM festival_events fe LEFT JOIN festival_organizations fo ON fe.source_key = fo.abbreviation LEFT JOIN festival_ceremonies fc ON fo.id = fc.organization_id LEFT JOIN festival_nominations fn ON fc.id = fn.ceremony_id GROUP BY fe.source_key, fe.name ORDER BY nominations DESC, fe.source_key;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT fo.name, fo.abbreviation, COUNT(fc.id) as ceremonies, COUNT(fn.id) as nominations FROM festival_organizations fo LEFT JOIN festival_ceremonies fc ON fo.id = fc.organization_id LEFT JOIN festival_nominations fn ON fc.id = fn.ceremony_id GROUP BY fo.name, fo.abbreviation ORDER BY nominations DESC;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\\d festival_events\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT source_key, name, abbreviation, active, source_config->>''event_id'' as event_id FROM festival_events WHERE active = true ORDER BY source_key;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\n-- Comprehensive audit of festival data\nSELECT \n    ''Oscar Ceremonies'' as data_type,\n    COUNT(*) as count\nFROM oscar_ceremonies\n\nUNION ALL\n\nSELECT \n    ''Oscar Nominations'' as data_type,\n    COUNT(*) as count\nFROM oscar_nominations\n\nUNION ALL\n\nSELECT \n    ''Oscar Categories'' as data_type,\n    COUNT(*) as count\nFROM oscar_categories\n\nUNION ALL\n\nSELECT \n    ''Festival Organizations'' as data_type,\n    COUNT(*) as count\nFROM festival_organizations\n\nUNION ALL\n\nSELECT \n    ''Festival Ceremonies'' as data_type,\n    COUNT(*) as count\nFROM festival_ceremonies\n\nUNION ALL\n\nSELECT \n    ''Festival Nominations'' as data_type,\n    COUNT(*) as count\nFROM festival_nominations\n\nUNION ALL\n\nSELECT \n    ''Festival Categories'' as data_type,\n    COUNT(*) as count\nFROM festival_categories\n\nORDER BY data_type;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT fo.abbreviation, fc.year, fc.name, fc.scraped_at, COUNT(fn.id) as nominations FROM festival_organizations fo JOIN festival_ceremonies fc ON fo.id = fc.organization_id LEFT JOIN festival_nominations fn ON fc.id = fn.ceremony_id WHERE fc.scraped_at > NOW() - INTERVAL ''30 days'' GROUP BY fo.abbreviation, fc.year, fc.name, fc.scraped_at ORDER BY fc.scraped_at DESC LIMIT 10;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT source_key, source_config FROM festival_events WHERE source_key IN (''oscars'', ''cannes'', ''venice'') ORDER BY source_key;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"UPDATE festival_events SET source_config = ''{\"\"base_url\"\": \"\"https://www.oscars.org\"\", \"\"scraping_method\"\": \"\"html_parser\"\", \"\"ceremony_path_template\"\": \"\"/ceremonies/{year}\"\"}'' WHERE source_key = ''oscars'';\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT fo.abbreviation, fc.year, fc.data_source, fc.source_url, COUNT(fn.id) as nominations FROM festival_organizations fo JOIN festival_ceremonies fc ON fo.id = fc.organization_id LEFT JOIN festival_nominations fn ON fc.id = fn.ceremony_id WHERE fo.abbreviation = ''AMPAS'' GROUP BY fo.abbreviation, fc.year, fc.data_source, fc.source_url ORDER BY fc.year DESC LIMIT 5;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT source_key, source_config FROM festival_events WHERE source_key != ''oscars'' AND active = true ORDER BY source_key LIMIT 3;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"SELECT source_key, source_config FROM festival_events WHERE source_key <> ''oscars'' AND active = true ORDER BY source_key LIMIT 3;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\n-- Comprehensive audit of current awards data state\nSELECT ''Oscar data in structured tables'' as category, COUNT(DISTINCT nom.id) as count\nFROM oscar_nominations nom\n\nUNION ALL\n\nSELECT ''Oscar data in movies.awards JSONB'' as category, COUNT(*) as count\nFROM movies \nWHERE awards IS NOT NULL \nAND awards ? ''oscar_nominations''\n\nUNION ALL\n\nSELECT ''Cannes data in canonical_sources'' as category, COUNT(*) as count\nFROM movies \nWHERE canonical_sources ? ''cannes_winners''\n\nUNION ALL\n\nSELECT ''Venice data in canonical_sources'' as category, COUNT(*) as count\nFROM movies \nWHERE canonical_sources ? ''venice_golden_lion''\n\nUNION ALL\n\nSELECT ''Berlin data in canonical_sources'' as category, COUNT(*) as count\nFROM movies \nWHERE canonical_sources ? ''berlin_golden_bear''\n\nUNION ALL\n\nSELECT ''Cannes with extracted_awards'' as category, COUNT(*) as count\nFROM movies \nWHERE canonical_sources -> ''cannes_winners'' -> ''extracted_awards'' IS NOT NULL\n\nUNION ALL\n\nSELECT ''Venice with extracted_awards'' as category, COUNT(*) as count\nFROM movies \nWHERE canonical_sources -> ''venice_golden_lion'' -> ''extracted_awards'' IS NOT NULL\n\nUNION ALL\n\nSELECT ''Berlin with extracted_awards'' as category, COUNT(*) as count\nFROM movies \nWHERE canonical_sources -> ''berlin_golden_bear'' -> ''extracted_awards'' IS NOT NULL\n\nORDER BY category;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=3ba3f8f9 mix run -e '\n# Queue a FestivalDiscoveryWorker job for New Horizons 2024 ceremony\nalias Cinegraph.Workers.FestivalDiscoveryWorker\n\njob_args = %{\n  \"\"ceremony_id\"\" => 206,\n  \"\"source\"\" => \"\"test_fix\"\"\n}\n\ncase FestivalDiscoveryWorker.new(job_args) |> Oban.insert() do\n  {:ok, job} ->\n    IO.puts(\"\"✅ Queued FestivalDiscoveryWorker job #{job.id} for New Horizons 2024\"\")\n    \n    # Wait for job to process\n    IO.puts(\"\"Waiting for job to process...\"\")\n    Process.sleep(15000)\n    \n    # Check nomination count\n    import Ecto.Query\n    \n    # Total nominations created\n    total_count = Cinegraph.Repo.one(\n      from n in Cinegraph.Festivals.FestivalNomination,\n      where: n.ceremony_id == 206,\n      select: count(n.id)\n    )\n    \n    # Nominations with movie_id (movie exists)\n    with_movie = Cinegraph.Repo.one(\n      from n in Cinegraph.Festivals.FestivalNomination,\n      where: n.ceremony_id == 206 and not is_nil(n.movie_id),\n      select: count(n.id)\n    )\n    \n    # Pending nominations (movie_imdb_id only)\n    pending = Cinegraph.Repo.one(\n      from n in Cinegraph.Festivals.FestivalNomination,\n      where: n.ceremony_id == 206 and is_nil(n.movie_id) and not is_nil(n.movie_imdb_id),\n      select: count(n.id)\n    )\n    \n    IO.puts(\"\"\\n=== Results After First Import ===\"\"\n    IO.puts(\"\"Total nominations created: #{total_count}\"\")\n    IO.puts(\"\"Nominations with existing movies: #{with_movie}\"\")\n    IO.puts(\"\"Pending nominations (movie not yet created): #{pending}\"\")\n    \n    # Check if we have 9 nominations like before\n    if total_count >= 9 do\n      IO.puts(\"\"\\n✅ SUCCESS! All #{total_count} nominations were created on first run!\"\")\n      IO.puts(\"\"The fix is working - nominations are no longer lost when movies dont exist yet.\"\")\n    else\n      IO.puts(\"\"\\n⚠️  Only #{total_count} nominations created, expected at least 9\"\")\n    end\n    \n    # Check TMDb jobs queued\n    tmdb_jobs = Cinegraph.Repo.one(\n      from j in Oban.Job,\n      where: j.worker == \"\"Cinegraph.Workers.TMDbDetailsWorker\"\" and j.state in [\"\"available\"\", \"\"executing\"\"],\n      select: count(j.id)\n    )\n    \n    IO.puts(\"\"\\nTMDb jobs queued/running: #{tmdb_jobs}\"\")\n    \n  {:error, reason} ->\n    IO.puts(\"\"❌ Failed to queue job: #{inspect(reason)}\"\")\nend\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=3ba3f8f9 mix run -e '\n# Queue a FestivalDiscoveryWorker job for New Horizons 2024 ceremony\nalias Cinegraph.Workers.FestivalDiscoveryWorker\n\njob_args = %{\n  \"\"ceremony_id\"\" => 206,\n  \"\"source\"\" => \"\"test_fix\"\"\n}\n\ncase FestivalDiscoveryWorker.new(job_args) |> Oban.insert() do\n  {:ok, job} ->\n    IO.puts(\"\"✅ Queued FestivalDiscoveryWorker job #{job.id} for New Horizons 2024\"\")\n    \n    # Wait for job to process\n    IO.puts(\"\"Waiting for job to process...\"\")\n    Process.sleep(15000)\n    \n    # Check nomination count\n    import Ecto.Query\n    \n    # Total nominations created\n    total_count = Cinegraph.Repo.one(\n      from n in Cinegraph.Festivals.FestivalNomination,\n      where: n.ceremony_id == 206,\n      select: count(n.id)\n    )\n    \n    # Nominations with movie_id (movie exists)\n    with_movie = Cinegraph.Repo.one(\n      from n in Cinegraph.Festivals.FestivalNomination,\n      where: n.ceremony_id == 206 and not is_nil(n.movie_id),\n      select: count(n.id)\n    )\n    \n    # Pending nominations (movie_imdb_id only)\n    pending = Cinegraph.Repo.one(\n      from n in Cinegraph.Festivals.FestivalNomination,\n      where: n.ceremony_id == 206 and is_nil(n.movie_id) and not is_nil(n.movie_imdb_id),\n      select: count(n.id)\n    )\n    \n    IO.puts(\"\"\\\\n=== Results After First Import ===\"\")\n    IO.puts(\"\"Total nominations created: #{total_count}\"\")\n    IO.puts(\"\"Nominations with existing movies: #{with_movie}\"\")\n    IO.puts(\"\"Pending nominations (movie not yet created): #{pending}\"\")\n    \n    # Check if we have 9 nominations like before\n    if total_count >= 9 do\n      IO.puts(\"\"\\\\n✅ SUCCESS! All #{total_count} nominations were created on first run!\"\")\n      IO.puts(\"\"The fix is working - nominations are no longer lost when movies dont exist yet.\"\")\n    else\n      IO.puts(\"\"\\\\n⚠️  Only #{total_count} nominations created, expected at least 9\"\")\n    end\n    \n    # Check TMDb jobs queued\n    tmdb_jobs = Cinegraph.Repo.one(\n      from j in Oban.Job,\n      where: j.worker == \"\"Cinegraph.Workers.TMDbDetailsWorker\"\" and j.state in [\"\"available\"\", \"\"executing\"\"],\n      select: count(j.id)\n    )\n    \n    IO.puts(\"\"\\\\nTMDb jobs queued/running: #{tmdb_jobs}\"\")\n    \n  {:error, reason} ->\n    IO.puts(\"\"❌ Failed to queue job: #{inspect(reason)}\"\")\nend\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=3ba3f8f9 mix run -e '\n# Retry the failed job\nimport Ecto.Query\n\n# Get the failed job\njob = Cinegraph.Repo.get(Oban.Job, 60119)\n\nif job do\n  # Update state to available to retry\n  job\n  |> Ecto.Changeset.change(%{state: \"\"available\"\", attempt: 0, errors: nil})\n  |> Cinegraph.Repo.update()\n  \n  IO.puts(\"\"Job 60119 reset for retry\"\")\n  \n  # Wait for it to process\n  Process.sleep(15000)\n  \n  # Check results\n  total_count = Cinegraph.Repo.one(\n    from n in Cinegraph.Festivals.FestivalNomination,\n    where: n.ceremony_id == 206,\n    select: count(n.id)\n  )\n  \n  with_movie = Cinegraph.Repo.one(\n    from n in Cinegraph.Festivals.FestivalNomination,\n    where: n.ceremony_id == 206 and not is_nil(n.movie_id),\n    select: count(n.id)\n  )\n  \n  pending = Cinegraph.Repo.one(\n    from n in Cinegraph.Festivals.FestivalNomination,\n    where: n.ceremony_id == 206 and is_nil(n.movie_id) and not is_nil(n.movie_imdb_id),\n    select: count(n.id)\n  )\n  \n  IO.puts(\"\"\\\\n=== Results After Fix ===\"\")\n  IO.puts(\"\"Total nominations: #{total_count}\"\")\n  IO.puts(\"\"With existing movies: #{with_movie}\"\")\n  IO.puts(\"\"Pending (waiting for movie creation): #{pending}\"\")\n  \n  if total_count >= 9 do\n    IO.puts(\"\"\\\\n✅ SUCCESS! All nominations captured on first run!\"\")\n  end\nelse\n  IO.puts(\"\"Job not found\"\")\nend\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=3ba3f8f9 mix run -e '\n# Clear the nominations and re-run fresh\nimport Ecto.Query\n\n# Clear existing nominations for ceremony 206\nCinegraph.Repo.delete_all(\n  from n in Cinegraph.Festivals.FestivalNomination,\n  where: n.ceremony_id == 206\n)\n\nIO.puts(\"\"Cleared existing nominations for ceremony 206\"\")\n\n# Queue a new job\nalias Cinegraph.Workers.FestivalDiscoveryWorker\n\njob_args = %{\n  \"\"ceremony_id\"\" => 206,\n  \"\"source\"\" => \"\"test_fix_v2\"\"\n}\n\ncase FestivalDiscoveryWorker.new(job_args) |> Oban.insert() do\n  {:ok, job} ->\n    IO.puts(\"\"✅ Queued new FestivalDiscoveryWorker job #{job.id}\"\")\n    \n    # Wait for processing\n    Process.sleep(15000)\n    \n    # Check results\n    total_count = Cinegraph.Repo.one(\n      from n in Cinegraph.Festivals.FestivalNomination,\n      where: n.ceremony_id == 206,\n      select: count(n.id)\n    )\n    \n    with_movie = Cinegraph.Repo.one(\n      from n in Cinegraph.Festivals.FestivalNomination,\n      where: n.ceremony_id == 206 and not is_nil(n.movie_id),\n      select: count(n.id)\n    )\n    \n    pending = Cinegraph.Repo.one(\n      from n in Cinegraph.Festivals.FestivalNomination,\n      where: n.ceremony_id == 206 and is_nil(n.movie_id) and not is_nil(n.movie_imdb_id),\n      select: count(n.id)\n    )\n    \n    IO.puts(\"\"\\\\n=== Final Results After Fix ===\"\")\n    IO.puts(\"\"Total nominations: #{total_count}\"\")\n    IO.puts(\"\"With existing movies: #{with_movie}\"\")\n    IO.puts(\"\"Pending (waiting for movie creation): #{pending}\"\")\n    \n    if total_count >= 9 do\n      IO.puts(\"\"\\\\n✅ SUCCESS! All #{total_count} nominations captured on first run!\"\")\n      IO.puts(\"\"The fix is working - nominations are created even when movies dont exist yet.\"\")\n    else\n      IO.puts(\"\"\\\\n⚠️  Only #{total_count} nominations created, expected at least 9\"\")\n    end\n    \n  {:error, reason} ->\n    IO.puts(\"\"❌ Failed to queue job: #{inspect(reason)}\"\")\nend\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\n-- Check current state of festival nominations with person data\nSELECT \n    ''Total Person Nominations'' as metric,\n    COUNT(*) as count\nFROM festival_nominations fn\nJOIN festival_categories fc ON fn.category_id = fc.id\nWHERE fc.tracks_person = true\n\nUNION ALL\n\nSELECT \n    ''With person_id linked'' as metric,\n    COUNT(*) as count\nFROM festival_nominations fn\nJOIN festival_categories fc ON fn.category_id = fc.id\nWHERE fc.tracks_person = true AND fn.person_id IS NOT NULL\n\nUNION ALL\n\nSELECT \n    ''With person_imdb_ids (pending)'' as metric,\n    COUNT(*) as count\nFROM festival_nominations fn\nJOIN festival_categories fc ON fn.category_id = fc.id\nWHERE fc.tracks_person = true AND array_length(fn.person_imdb_ids, 1) > 0\n\nUNION ALL\n\nSELECT \n    ''With person_name stored'' as metric,\n    COUNT(*) as count\nFROM festival_nominations fn\nJOIN festival_categories fc ON fn.category_id = fc.id\nWHERE fc.tracks_person = true AND fn.person_name IS NOT NULL\n\nORDER BY metric;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\n-- Clear existing Oscar nominations for a clean test\nDELETE FROM festival_nominations \nWHERE ceremony_id IN (\n  SELECT fc.id \n  FROM festival_ceremonies fc\n  JOIN festival_organizations fo ON fc.organization_id = fo.id\n  WHERE fo.abbreviation = ''AMPAS''\n);\n\n-- Check the count after deletion\nSELECT COUNT(*) as deleted_count FROM festival_nominations \nWHERE ceremony_id IN (\n  SELECT fc.id \n  FROM festival_ceremonies fc\n  JOIN festival_organizations fo ON fc.organization_id = fo.id\n  WHERE fo.abbreviation = ''AMPAS''\n);\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=3ba3f8f9 mix run -e 'result = Cinegraph.Cultural.import_oscar_years(2024..2024); IO.inspect(result, label: \"\"Oscar Import Result\"\")')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=3ba3f8f9 mix run -e 'result = Cinegraph.Cultural.import_oscar_years(2024..2024); IO.inspect(result, label: \"\"First Oscar Import Result\"\")')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\n-- Check People Nominations count after first import\nSELECT \n    ''Total Nominations'' as metric,\n    COUNT(*) as count\nFROM festival_nominations fn\nJOIN festival_ceremonies fc ON fn.ceremony_id = fc.id\nJOIN festival_organizations fo ON fc.organization_id = fo.id\nWHERE fo.abbreviation = ''AMPAS'' AND fc.year = 2024\n\nUNION ALL\n\nSELECT \n    ''People Nominations'' as metric,\n    COUNT(*) as count\nFROM festival_nominations fn\nJOIN festival_categories fcat ON fn.category_id = fcat.id\nJOIN festival_ceremonies fc ON fn.ceremony_id = fc.id\nJOIN festival_organizations fo ON fc.organization_id = fo.id\nWHERE fo.abbreviation = ''AMPAS'' AND fc.year = 2024 AND fcat.tracks_person = true\n\nUNION ALL\n\nSELECT \n    ''Film Nominations'' as metric,\n    COUNT(*) as count\nFROM festival_nominations fn\nJOIN festival_categories fcat ON fn.category_id = fcat.id\nJOIN festival_ceremonies fc ON fn.ceremony_id = fc.id\nJOIN festival_organizations fo ON fc.organization_id = fo.id\nWHERE fo.abbreviation = ''AMPAS'' AND fc.year = 2024 AND fcat.tracks_person = false\n\nORDER BY metric;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\nSELECT \n    worker,\n    state,\n    COUNT(*) as count\nFROM oban_jobs \nWHERE worker IN (''Cinegraph.Workers.UnifiedFestivalWorker'', ''Cinegraph.Workers.FestivalDiscoveryWorker'')\nAND state IN (''available'', ''executing'', ''retryable'')\nGROUP BY worker, state\nORDER BY worker, state;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\nSELECT \n    fc.id,\n    fc.year,\n    fo.abbreviation,\n    fc.data IS NOT NULL as has_data\nFROM festival_ceremonies fc\nJOIN festival_organizations fo ON fc.organization_id = fo.id\nWHERE fo.abbreviation = ''AMPAS'' AND fc.year = 2024;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=3ba3f8f9 mix run -e '\n# Manually trigger FestivalDiscoveryWorker for Oscar 2024 ceremony\nalias Cinegraph.Workers.FestivalDiscoveryWorker\n\njob_args = %{\n  \"\"ceremony_id\"\" => 236,\n  \"\"source\"\" => \"\"test_duplicate_fix\"\"\n}\n\ncase FestivalDiscoveryWorker.new(job_args) |> Oban.insert() do\n  {:ok, job} ->\n    IO.puts(\"\"✅ Queued FestivalDiscoveryWorker job #{job.id} for Oscar 2024 ceremony\"\")\n    \n    # Wait for processing\n    Process.sleep(10000)\n    \n    # Check nomination counts\n    import Ecto.Query\n    \n    total_count = Cinegraph.Repo.one(\n      from n in Cinegraph.Festivals.FestivalNomination,\n      where: n.ceremony_id == 236,\n      select: count(n.id)\n    )\n    \n    people_count = Cinegraph.Repo.one(\n      from n in Cinegraph.Festivals.FestivalNomination,\n      join: c in Cinegraph.Festivals.FestivalCategory, on: n.category_id == c.id,\n      where: n.ceremony_id == 236 and c.tracks_person == true,\n      select: count(n.id)\n    )\n    \n    film_count = Cinegraph.Repo.one(\n      from n in Cinegraph.Festivals.FestivalNomination,\n      join: c in Cinegraph.Festivals.FestivalCategory, on: n.category_id == c.id,\n      where: n.ceremony_id == 236 and c.tracks_person == false,\n      select: count(n.id)\n    )\n    \n    IO.puts(\"\"\\n=== First Import Results ===\"\")\n    IO.puts(\"\"Total nominations: #{total_count}\"\")\n    IO.puts(\"\"People nominations: #{people_count}\"\")\n    IO.puts(\"\"Film nominations: #{film_count}\"\")\n    \n  {:error, reason} ->\n    IO.puts(\"\"❌ Failed to queue job: #{inspect(reason)}\"\")\nend')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\nSELECT \n    id,\n    state,\n    attempt,\n    errors\nFROM oban_jobs \nWHERE id = 64999;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=3ba3f8f9 mix run -e '\n# Manually trigger FestivalDiscoveryWorker for Oscar 2024 ceremony - first run\nalias Cinegraph.Workers.FestivalDiscoveryWorker\n\njob_args = %{\n  \"\"ceremony_id\"\" => 236,\n  \"\"source\"\" => \"\"test_duplicate_fix_v2\"\"\n}\n\ncase FestivalDiscoveryWorker.new(job_args) |> Oban.insert() do\n  {:ok, job} ->\n    IO.puts(\"\"✅ Queued FestivalDiscoveryWorker job #{job.id} for Oscar 2024 ceremony (first run)\"\")\n    \n    # Wait for processing\n    Process.sleep(15000)\n    \n    # Check nomination counts\n    import Ecto.Query\n    \n    total_count = Cinegraph.Repo.one(\n      from n in Cinegraph.Festivals.FestivalNomination,\n      where: n.ceremony_id == 236,\n      select: count(n.id)\n    )\n    \n    people_count = Cinegraph.Repo.one(\n      from n in Cinegraph.Festivals.FestivalNomination,\n      join: c in Cinegraph.Festivals.FestivalCategory, on: n.category_id == c.id,\n      where: n.ceremony_id == 236 and c.tracks_person == true,\n      select: count(n.id)\n    )\n    \n    film_count = Cinegraph.Repo.one(\n      from n in Cinegraph.Festivals.FestivalNomination,\n      join: c in Cinegraph.Festivals.FestivalCategory, on: n.category_id == c.id,\n      where: n.ceremony_id == 236 and c.tracks_person == false,\n      select: count(n.id)\n    )\n    \n    IO.puts(\"\"\\n=== First Import Results ===\"\")\n    IO.puts(\"\"Total nominations: #{total_count}\"\")\n    IO.puts(\"\"People nominations: #{people_count}\"\")\n    IO.puts(\"\"Film nominations: #{film_count}\"\")\n    \n  {:error, reason} ->\n    IO.puts(\"\"❌ Failed to queue job: #{inspect(reason)}\"\")\nend')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=3ba3f8f9 mix run -e '\n# Manually trigger FestivalDiscoveryWorker for Oscar 2024 ceremony - second run\nalias Cinegraph.Workers.FestivalDiscoveryWorker\n\njob_args = %{\n  \"\"ceremony_id\"\" => 236,\n  \"\"source\"\" => \"\"test_duplicate_fix_second_run\"\"\n}\n\ncase FestivalDiscoveryWorker.new(job_args) |> Oban.insert() do\n  {:ok, job} ->\n    IO.puts(\"\"✅ Queued FestivalDiscoveryWorker job #{job.id} for Oscar 2024 ceremony (SECOND RUN)\"\")\n    \n    # Wait for processing\n    Process.sleep(15000)\n    \n    # Check nomination counts\n    import Ecto.Query\n    \n    total_count = Cinegraph.Repo.one(\n      from n in Cinegraph.Festivals.FestivalNomination,\n      where: n.ceremony_id == 236,\n      select: count(n.id)\n    )\n    \n    people_count = Cinegraph.Repo.one(\n      from n in Cinegraph.Festivals.FestivalNomination,\n      join: c in Cinegraph.Festivals.FestivalCategory, on: n.category_id == c.id,\n      where: n.ceremony_id == 236 and c.tracks_person == true,\n      select: count(n.id)\n    )\n    \n    film_count = Cinegraph.Repo.one(\n      from n in Cinegraph.Festivals.FestivalNomination,\n      join: c in Cinegraph.Festivals.FestivalCategory, on: n.category_id == c.id,\n      where: n.ceremony_id == 236 and c.tracks_person == false,\n      select: count(n.id)\n    )\n    \n    IO.puts(\"\"\\n=== SECOND Import Results ===\"\")\n    IO.puts(\"\"Total nominations: #{total_count}\"\")\n    IO.puts(\"\"People nominations: #{people_count}\"\")\n    IO.puts(\"\"Film nominations: #{film_count}\"\")\n    \n    if people_count == 44 do\n      IO.puts(\"\"\\n✅ SUCCESS! People nominations count remained at 44 - duplicate bug is FIXED!\"\")\n    else\n      IO.puts(\"\"\\n⚠️ WARNING: People nominations changed from 44 to #{people_count}\"\")\n    end\n    \n  {:error, reason} ->\n    IO.puts(\"\"❌ Failed to queue job: #{inspect(reason)}\"\")\nend')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\n-- Final verification of the fix\nSELECT \n    ''Total Oscar 2024 Nominations'' as metric,\n    COUNT(*) as count\nFROM festival_nominations fn\nJOIN festival_ceremonies fc ON fn.ceremony_id = fc.id\nJOIN festival_organizations fo ON fc.organization_id = fo.id\nWHERE fo.abbreviation = ''AMPAS'' AND fc.year = 2024\n\nUNION ALL\n\nSELECT \n    ''People Nominations (Fixed!)'' as metric,\n    COUNT(*) as count\nFROM festival_nominations fn\nJOIN festival_categories fcat ON fn.category_id = fcat.id\nJOIN festival_ceremonies fc ON fn.ceremony_id = fc.id\nJOIN festival_organizations fo ON fc.organization_id = fo.id\nWHERE fo.abbreviation = ''AMPAS'' AND fc.year = 2024 AND fcat.tracks_person = true\n\nUNION ALL\n\nSELECT \n    ''Film Nominations'' as metric,\n    COUNT(*) as count\nFROM festival_nominations fn\nJOIN festival_categories fcat ON fn.category_id = fcat.id\nJOIN festival_ceremonies fc ON fn.ceremony_id = fc.id\nJOIN festival_organizations fo ON fc.organization_id = fo.id\nWHERE fo.abbreviation = ''AMPAS'' AND fc.year = 2024 AND fcat.tracks_person = false\n\nORDER BY metric DESC;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\n-- Check current Oscar 2024 nomination counts\nSELECT \n    ''Total Nominations'' as metric,\n    COUNT(*) as count\nFROM festival_nominations fn\nJOIN festival_ceremonies fc ON fn.ceremony_id = fc.id\nJOIN festival_organizations fo ON fc.organization_id = fo.id\nWHERE fo.abbreviation = ''AMPAS'' AND fc.year = 2024\n\nUNION ALL\n\nSELECT \n    ''People Nominations'' as metric,\n    COUNT(*) as count\nFROM festival_nominations fn\nJOIN festival_categories fcat ON fn.category_id = fcat.id\nJOIN festival_ceremonies fc ON fn.ceremony_id = fc.id\nJOIN festival_organizations fo ON fc.organization_id = fo.id\nWHERE fo.abbreviation = ''AMPAS'' AND fc.year = 2024 AND fcat.tracks_person = true\n\nUNION ALL\n\nSELECT \n    ''Film Nominations'' as metric,\n    COUNT(*) as count\nFROM festival_nominations fn\nJOIN festival_categories fcat ON fn.category_id = fcat.id\nJOIN festival_ceremonies fc ON fn.ceremony_id = fc.id\nJOIN festival_organizations fo ON fc.organization_id = fo.id\nWHERE fo.abbreviation = ''AMPAS'' AND fc.year = 2024 AND fcat.tracks_person = false\n\nUNION ALL\n\nSELECT \n    ''Categories Used'' as metric,\n    COUNT(DISTINCT fcat.id) as count\nFROM festival_nominations fn\nJOIN festival_categories fcat ON fn.category_id = fcat.id\nJOIN festival_ceremonies fc ON fn.ceremony_id = fc.id\nJOIN festival_organizations fo ON fc.organization_id = fo.id\nWHERE fo.abbreviation = ''AMPAS'' AND fc.year = 2024\n\nORDER BY metric;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres PGPASSWORD=postgres psql -h 127.0.0.1 -p 54332 -U postgres -d postgres -c \"\n-- Get current counts before test\nSELECT \n    ''Total Nominations'' as metric,\n    COUNT(*) as count\nFROM festival_nominations fn\nJOIN festival_ceremonies fc ON fn.ceremony_id = fc.id\nJOIN festival_organizations fo ON fc.organization_id = fo.id\nWHERE fo.abbreviation = ''AMPAS'' AND fc.year = 2024\n\nUNION ALL\n\nSELECT \n    ''People Nominations'' as metric,\n    COUNT(*) as count\nFROM festival_nominations fn\nJOIN festival_categories fcat ON fn.category_id = fcat.id\nJOIN festival_ceremonies fc ON fn.ceremony_id = fc.id\nJOIN festival_organizations fo ON fc.organization_id = fo.id\nWHERE fo.abbreviation = ''AMPAS'' AND fc.year = 2024 AND fcat.tracks_person = true\n\nORDER BY metric;\")",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=3ba3f8f9 mix run -e '\n# Manually trigger FestivalDiscoveryWorker for Oscar 2024 ceremony\nalias Cinegraph.Workers.FestivalDiscoveryWorker\n\n# Get the ceremony ID\nimport Ecto.Query\nceremony = Cinegraph.Repo.one(\n  from fc in Cinegraph.Festivals.FestivalCeremony,\n  join: fo in Cinegraph.Festivals.FestivalOrganization, on: fc.organization_id == fo.id,\n  where: fo.abbreviation == \"\"AMPAS\"\" and fc.year == 2024,\n  select: fc\n)\n\nif ceremony do\n  job_args = %{\n    \"\"ceremony_id\"\" => ceremony.id,\n    \"\"source\"\" => \"\"test_duplicate_fix_v3\"\"\n  }\n\n  case FestivalDiscoveryWorker.new(job_args) |> Oban.insert() do\n    {:ok, job} ->\n      IO.puts(\"\"✅ Queued FestivalDiscoveryWorker job #{job.id} for Oscar 2024 ceremony (testing duplicate fix)\"\")\n      \n      # Wait for processing\n      Process.sleep(15000)\n      \n      # Check nomination counts\n      total_count = Cinegraph.Repo.one(\n        from n in Cinegraph.Festivals.FestivalNomination,\n        where: n.ceremony_id == ^ceremony.id,\n        select: count(n.id)\n      )\n      \n      people_count = Cinegraph.Repo.one(\n        from n in Cinegraph.Festivals.FestivalNomination,\n        join: c in Cinegraph.Festivals.FestivalCategory, on: n.category_id == c.id,\n        where: n.ceremony_id == ^ceremony.id and c.tracks_person == true,\n        select: count(n.id)\n      )\n      \n      film_count = Cinegraph.Repo.one(\n        from n in Cinegraph.Festivals.FestivalNomination,\n        join: c in Cinegraph.Festivals.FestivalCategory, on: n.category_id == c.id,\n        where: n.ceremony_id == ^ceremony.id and c.tracks_person == false,\n        select: count(n.id)\n      )\n      \n      IO.puts(\"\"\\n=== After Re-import Results ===\"\")\n      IO.puts(\"\"Total nominations: #{total_count}\"\")\n      IO.puts(\"\"People nominations: #{people_count}\"\")\n      IO.puts(\"\"Film nominations: #{film_count}\"\")\n      \n      if people_count == 44 do\n        IO.puts(\"\"\\n✅ SUCCESS! People nominations count remained at 44 - duplicate bug is FIXED!\"\")\n      else\n        IO.puts(\"\"\\n⚠️ WARNING: People nominations changed from 44 to #{people_count}\"\")\n      end\n      \n    {:error, reason} ->\n      IO.puts(\"\"❌ Failed to queue job: #{inspect(reason)}\"\")\n  end\nelse\n  IO.puts(\"\"Oscar 2024 ceremony not found\"\")\nend\n')",
      "Bash(SUPABASE_DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54332/postgres TMDB_API_KEY=569d36799113067889ac91b76e5dc8f8 OMDB_API_KEY=3ba3f8f9 mix run -e '\n# Run it again to triple-check\nalias Cinegraph.Workers.FestivalDiscoveryWorker\n\nimport Ecto.Query\nceremony = Cinegraph.Repo.one(\n  from fc in Cinegraph.Festivals.FestivalCeremony,\n  join: fo in Cinegraph.Festivals.FestivalOrganization, on: fc.organization_id == fo.id,\n  where: fo.abbreviation == \"\"AMPAS\"\" and fc.year == 2024,\n  select: fc\n)\n\nif ceremony do\n  job_args = %{\n    \"\"ceremony_id\"\" => ceremony.id,\n    \"\"source\"\" => \"\"test_duplicate_fix_third_run\"\"\n  }\n\n  case FestivalDiscoveryWorker.new(job_args) |> Oban.insert() do\n    {:ok, job} ->\n      IO.puts(\"\"✅ Queued FestivalDiscoveryWorker job #{job.id} for third test run\"\")\n      \n      # Wait for processing\n      Process.sleep(15000)\n      \n      # Check nomination counts\n      people_count = Cinegraph.Repo.one(\n        from n in Cinegraph.Festivals.FestivalNomination,\n        join: c in Cinegraph.Festivals.FestivalCategory, on: n.category_id == c.id,\n        where: n.ceremony_id == ^ceremony.id and c.tracks_person == true,\n        select: count(n.id)\n      )\n      \n      IO.puts(\"\"\\n=== Third Run Results ===\"\")\n      IO.puts(\"\"People nominations: #{people_count}\"\")\n      \n      if people_count == 44 do\n        IO.puts(\"\"✅ CONFIRMED: Duplicate bug is completely FIXED!\"\")\n      else\n        IO.puts(\"\"⚠️ Issue still present: #{people_count}\"\")\n      end\n      \n    {:error, reason} ->\n      IO.puts(\"\"❌ Failed to queue job: #{inspect(reason)}\"\")\n  end\nend\n')",
      "WebFetch(domain:en.wikipedia.org)",
      "Bash(--title \"2024 Academy Awards Baseline Data Analysis - Expected Database Metrics\" )",
      "Bash(--body-file OSCARS_2024_BASELINE_ANALYSIS.md )",
      "Bash(--label \"documentation,analysis,awards-data\" )",
      "Bash(--assignee @me)",
      "Bash(--title \"2024 Academy Awards Baseline Data Analysis - Expected Database Metrics\" )",
      "Bash(--body-file OSCARS_2024_BASELINE_ANALYSIS.md )",
      "Bash(--label \"documentation\" )",
      "Bash(git pull:*)",
      "Bash(git restore:*)",
      "Bash(./check_video_constraints.exs)",
      "WebFetch(domain:www.jsdelivr.com)"
    ],
    "deny": []
  }
}